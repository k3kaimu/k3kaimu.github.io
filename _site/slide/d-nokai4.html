<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <meta name="generator" content="pandoc">
  <title>Dの会 #4 資料</title>
  <meta name="apple-mobile-web-app-capable" content="yes" />
  <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
  <link rel="stylesheet" href="reveal.js/css/reveal.min.css"/>
    <style type="text/css">code{white-space: pre;}</style>
    <style type="text/css">
table.sourceCode, tr.sourceCode, td.lineNumbers, td.sourceCode {
  margin: 0; padding: 0; vertical-align: baseline; border: none; }
table.sourceCode { width: 100%; line-height: 100%; }
td.lineNumbers { text-align: right; padding-right: 4px; padding-left: 4px; color: #aaaaaa; border-right: 1px solid #aaaaaa; }
td.sourceCode { padding-left: 5px; }
code > span.kw { color: #007020; font-weight: bold; }
code > span.dt { color: #902000; }
code > span.dv { color: #40a070; }
code > span.bn { color: #40a070; }
code > span.fl { color: #40a070; }
code > span.ch { color: #4070a0; }
code > span.st { color: #4070a0; }
code > span.co { color: #60a0b0; font-style: italic; }
code > span.ot { color: #007020; }
code > span.al { color: #ff0000; font-weight: bold; }
code > span.fu { color: #06287e; }
code > span.er { color: #ff0000; font-weight: bold; }
    </style>
    <link rel="stylesheet" href="reveal.js/css/theme/simple.css" id="theme">
  <link rel="stylesheet" media="print" href="reveal.js/css/print/pdf.css" />
  <!--[if lt IE 9]>
  <script src="reveal.js/lib/js/html5shiv.js"></script>
  <![endif]-->
</head>
<body>
  <div class="reveal">
    <div class="slides">

<section>
    <h1 class="title">Dの会 #4 資料</h1>
    <h3 class="date">2014-11-20 18:30:00</h3>
</section>

<section class="slide level2">

<!--
pandoc -s -t revealjs -V theme:sky -o d-nokai4.html 2014-11-20-d-nokai4.md
-->

<p><a href="{{%20site.baseurl%20}}/slide/d-nokai4.html">資料URL</a></p>
</section>
<section id="range-文字列-連想配列" class="slide level2">
<h1>Range, 文字列, 連想配列</h1>
</section>
<section class="slide level2">

<h3 id="順番">順番</h3>
<ul>
<li>type, qualifier</li>
<li>array, GC and foreach-loop</li>
<li><strong>string, UTF</strong></li>
<li><strong>Associative Array(HashMap)</strong></li>
<li>function(template)</li>
<li>Exception, scope(exit|failure|success), DbC, unittest</li>
<li>revisit function</li>
<li>revisit template-function</li>
<li>struct, union</li>
<li>class, interface,</li>
<li>re-revisit template</li>
</ul>
</section>
<section class="slide level2">

<h3 id="復習-1">復習-1</h3>
<p>Project Euler problem-1より。</p>
<blockquote>
<p>10未満の自然数のうち, 3 もしくは 5 の倍数になっているものは 3, 5, 6, 9 の4つがあり, これらの合計は 23 になる.<br />同じようにして, 1000 未満の 3 か 5 の倍数になっている数字の合計を求めよ.</p>
</blockquote>
<p>正解：233168</p>
</section>
<section class="slide level2">

<h3 id="復習12">復習−1−2</h3>
<p>以下の関数を使って解いてみる</p>
<ul>
<li><code>iota(1, 1000)</code></li>
<li><code>filter!&quot;....&quot;</code></li>
<li><code>reduce!&quot;....&quot;</code></li>
</ul>
<pre class="sourceCode d"><code class="sourceCode d">[<span class="dv">1</span>, <span class="dv">2</span>, <span class="dv">3</span>, <span class="dv">4</span>].filter!<span class="st">&quot;(a &amp; 0x3) == 0&quot;</span>    -&gt; [<span class="dv">4</span>]

[<span class="dv">1</span>, <span class="dv">2</span>, <span class="dv">3</span>, <span class="dv">4</span>].reduce!<span class="st">&quot;a * b&quot;</span>             -&gt; <span class="dv">24</span></code></pre>
</section>
<section class="slide level2">

<h3 id="復習2">復習−2</h3>
<p>Project Euler problem-2より。</p>
<blockquote>
<p>フィボナッチ数列の項は前の2つの項の和である. 最初の2項を 1, 2 とすれば, 最初の10項は以下の通りである.<br />1, 2, 3, 5, 8, 13, 21, 34, 55, 89, ...<br />数列の項の値が400万以下の, 偶数値の項の総和を求めよ.</p>
</blockquote>
<p>正解：4613732</p>
</section>
<section class="slide level2">

<h3 id="復習21">復習−2−1</h3>
<p>以下の関数を使って解いてみる</p>
<ul>
<li><code>recurrence!&quot;....&quot;</code></li>
<li><code>until!&quot;....&quot;</code></li>
<li><code>filter!&quot;....&quot;</code></li>
</ul>
<pre class="sourceCode d"><code class="sourceCode d">recurrence!<span class="st">&quot;a[n-1] * (n+1)&quot;</span>(<span class="dv">1</span>).until!<span class="st">&quot;a &gt; b&quot;</span>(<span class="dv">1000</span>)    -&gt; [<span class="dv">1</span>, <span class="dv">2</span>, <span class="dv">6</span>, <span class="dv">24</span>, <span class="dv">120</span>, <span class="dv">720</span>]</code></pre>
</section>
<section id="range" class="slide level2">
<h1>Range</h1>
<ul>
<li>リストの抽象的表現</li>
</ul>
<pre class="sourceCode d"><code class="sourceCode d"><span class="kw">auto</span> popHead(R)(<span class="kw">ref</span> R r)
{
    enforce(!r.empty);  <span class="co">// 空か？</span>

    <span class="kw">auto</span> e = r.front;   <span class="co">// 先頭要素</span>
    r.popFront();       <span class="co">// 先頭を消す</span>
    <span class="kw">return</span> e;
}</code></pre>
</section>
<section class="slide level2">

<h3 id="配列とrange">配列とRange</h3>
<pre class="sourceCode d"><code class="sourceCode d"><span class="kw">import</span> std.array;

<span class="dt">void</span> main()
{
    <span class="kw">auto</span> arr = [<span class="dv">1</span>, <span class="dv">2</span>, <span class="dv">3</span>, <span class="dv">4</span>];

    writeln(arr.empty);
    writeln(arr.front);
    arr.popFront();
    writeln(arr);
    writeln(arr.empty);
    writeln(arr.front);
    arr = [];
    writeln(arr.empty);
}</code></pre>
</section>
<section class="slide level2">

<h3 id="rangeを作ってみる">Rangeを作ってみる</h3>
<ul>
<li>0, 1, 2, 3, ...</li>
<li>無限レンジ</li>
</ul>
<pre class="sourceCode d"><code class="sourceCode d"><span class="kw">import</span> std.stdio, std.range;

<span class="kw">struct</span> InfSeq{
    <span class="kw">enum</span> <span class="dt">bool</span> empty = <span class="kw">false</span>;    <span class="co">// 終わりなし</span>
    <span class="dt">int</span> front() @property { <span class="kw">return</span> _i; }
    <span class="dt">void</span> popFront() { ++_i; }
    <span class="kw">private</span> <span class="dt">int</span> _i;
}


<span class="dt">void</span> main()
{
    writeln(InfSeq().take(<span class="dv">100</span>));
}</code></pre>
</section>
<section id="準備" class="slide level2">
<h1>準備</h1>
<p>WindowsでUTF文字列を表示させる</p>
<ul>
<li>ターミナルの対応</li>
<li>関数のハイジャック</li>
</ul>
</section>
<section class="slide level2">

<h3 id="ターミナルの対応">ターミナルの対応</h3>
<ul>
<li><code>chcp 65001</code></li>
<li>フォントを変える</li>
</ul>
</section>
<section class="slide level2">

<h3 id="関数ハイジャック">関数ハイジャック</h3>
<pre class="sourceCode d"><code class="sourceCode d"><span class="kw">import</span> std.algorithm;
<span class="kw">import</span> std.conv, std.format, std.string;
<span class="kw">import</span> std.windows.charset;
<span class="kw">import</span> std.stdio;

<span class="kw">version</span>(Windows)
{
  <span class="kw">template</span> writeImpl(<span class="kw">alias</span> f, <span class="dt">string</span> ln)
  { <span class="dt">void</span> writeImpl(T...)(<span class="kw">auto</span> <span class="kw">ref</span> T args)
    { printf(f(forward!args).toMBSz);
      printf(ln); }}

  <span class="kw">alias</span> write = writeImpl!(text, <span class="st">&quot;&quot;</span>);
  <span class="kw">alias</span> writef = writeImpl!(format, <span class="st">&quot;&quot;</span>);
  <span class="kw">alias</span> writeln = writeImpl!(text, <span class="st">&quot;\r\n&quot;</span>);
  <span class="kw">alias</span> writefln = writeImpl!(format, <span class="st">&quot;\r\n&quot;</span>);
}

<span class="dt">void</span> main()
{
    writeln(<span class="st">&quot;ああああ&quot;</span>);
    writef(<span class="st">&quot;嗚呼唖々&quot;</span>);
}</code></pre>
</section>
<section id="utf-32" class="slide level2">
<h1>UTF-32</h1>
<ul>
<li>一文字 == 4byte固定</li>
</ul>
<pre class="sourceCode d"><code class="sourceCode d"><span class="kw">import</span> std.stdio;

<span class="dt">void</span> main()
{
    <span class="co">// dchar, dstring が UTF-32</span>
    <span class="dt">dstring</span>[] ss = [<span class="st">&quot;a&quot;</span>, <span class="st">&quot;あ&quot;</span>, <span class="st">&quot;阿&quot;</span>, <span class="st">&quot;\U0001F363&quot;</span>];

     <span class="kw">foreach</span>(s; ss)
        writefln(<span class="st">`%(%s%) =&gt; %(%02X%)`</span>, [s], (<span class="kw">cast</span>(<span class="kw">immutable</span>(<span class="dt">ubyte</span>)[])s).<span class="dt">dup</span>.<span class="dt">reverse</span>);
}</code></pre>
</section>
<section id="utf-16" class="slide level2">
<h1>UTF-16</h1>
<ul>
<li>基本：1文字 == 2byte</li>
<li>サロゲートペア(2byte*2で一文字)</li>
</ul>
<pre class="sourceCode d"><code class="sourceCode d"><span class="kw">import</span> std.stdio;

<span class="dt">void</span> main()
{
    <span class="co">// wchar, wstring が UTF-32</span>
    <span class="dt">wstring</span>[] ss = [<span class="st">&quot;a&quot;</span>, <span class="st">&quot;あ&quot;</span>, <span class="st">&quot;阿&quot;</span>, <span class="st">&quot;\U0001F363&quot;</span>];

     <span class="kw">foreach</span>(s; ss)
        writefln(<span class="st">`%(%s%) =&gt; %(%02X%)`</span>, [s], (<span class="kw">cast</span>(<span class="kw">immutable</span>(<span class="dt">ubyte</span>)[])s).<span class="dt">dup</span>.<span class="dt">reverse</span>);
}</code></pre>
</section>
<section id="utf-8" class="slide level2">
<h1>UTF-8</h1>
<ul>
<li>1～6 byteまでの可変長</li>
</ul>
<pre class="sourceCode d"><code class="sourceCode d"><span class="kw">import</span> std.stdio;

<span class="dt">void</span> main()
{
    <span class="co">// char, string が UTF-32</span>
    <span class="dt">string</span>[] ss = [<span class="st">&quot;a&quot;</span>, <span class="st">&quot;あ&quot;</span>, <span class="st">&quot;阿&quot;</span>, <span class="st">&quot;\U0001F363&quot;</span>];

     <span class="kw">foreach</span>(s; ss)
        writefln(<span class="st">`%(%s%) =&gt; %(%02X%)`</span>, [s], (<span class="kw">cast</span>(<span class="kw">immutable</span>(<span class="dt">ubyte</span>)[])s).<span class="dt">dup</span>.<span class="dt">reverse</span>);
}</code></pre>
</section>
<section id="問題" class="slide level2">
<h1>問題</h1>
<ul>
<li>文字列の先頭文字を得るには？</li>
<li>ヒント
<ul>
<li>immutable(char|wchar|dchar)[]</li>
</ul></li>
</ul>
<pre class="sourceCode d"><code class="sourceCode d"><span class="kw">auto</span> getHead(S)(S str)
{
    <span class="kw">return</span> str[<span class="dv">0</span>];
}</code></pre>
</section>
<section class="slide level2">

<h3 id="utf-32の場合">UTF-32の場合</h3>
<ul>
<li>1文字は4byte固定</li>
</ul>
<pre class="sourceCode d"><code class="sourceCode d"><span class="kw">import</span> std.stdio;

<span class="dt">void</span> main()
{
    <span class="dt">dstring</span> str = <span class="st">&quot;トヨッキー&quot;</span>;
    writeln(str[<span class="dv">0</span>]);
}</code></pre>
</section>
<section class="slide level2">

<h3 id="utf-8の場合">UTF-8の場合</h3>
<pre class="sourceCode d"><code class="sourceCode d"><span class="kw">import</span> std.stdio;

<span class="dt">void</span> main()
{
    <span class="dt">string</span> str = <span class="st">&quot;トヨッキー&quot;</span>;
    writeln(str[<span class="dv">0</span>]);    <span class="co">// 文字化け</span>
}</code></pre>
</section>
<section class="slide level2">

<h3 id="utf-8可変長">UTF-8：可変長</h3>
<ul>
<li><code>str[0]</code>は先頭の1byteだけ</li>
<li>UTF-32に変換してしまう</li>
<li>Range</li>
</ul>
<pre class="sourceCode d"><code class="sourceCode d"><span class="kw">import</span> std.array, std.stdio, std.utf;

<span class="dt">void</span> main()
{
    <span class="dt">string</span> str = <span class="st">&quot;トヨッキー&quot;</span>;

    <span class="co">// UTF-32に変換して、先頭文字だけ返す</span>
    writeln(str.toUTF32()[<span class="dv">0</span>]);  <span class="co">// dchar</span>

    <span class="co">// 先頭文字をUTF-32にして返す</span>
    writeln(str.front);         <span class="co">// dchar</span>
}</code></pre>
</section>
<section class="slide level2">

<h3 id="utf-16の場合">UTF-16の場合</h3>
<ul>
<li>基本的には1文字は2byte</li>
<li>サロゲートペア：4byteで1文字
<ul>
<li>めったにないけど。</li>
</ul></li>
<li>UTF-8と同じように処理</li>
</ul>
</section>
<section class="slide level2">

<h3 id="文字列のまとめ">文字列のまとめ</h3>
<ul>
<li>UTF-32に一度変換してしまうのが楽</li>
<li>文字列のRangeは、UTF-32のシーケンス</li>
</ul>
<pre class="sourceCode d"><code class="sourceCode d"><span class="dt">void</span> main()
{
    <span class="co">// 推論させると、immutable(char)になる</span>
    <span class="co">// dcharにしたいなら、明示的に書く必要がある</span>
    <span class="kw">foreach</span>(<span class="dt">dchar</span> e; <span class="st">&quot;あああ&quot;</span>)
        writeln(e);
}</code></pre>
</section>
<section class="slide level2">

<h3 id="文字列の問題">文字列の問題</h3>
<ul>
<li><a href="https://k3kaimu.github.io/dmanual/string/">d-manual</a></li>
</ul>
</section>
<section class="slide level2">

<h3 id="入力">入力</h3>
<p>標準入力から一行取得する。</p>
<pre class="sourceCode d"><code class="sourceCode d"><span class="kw">import</span> std.stdio, std.range,
       std.conv, std.string;

<span class="dt">void</span> main()
{
    <span class="kw">immutable</span> n = readln()  <span class="co">// 1行</span>
                 .chomp()   <span class="co">// 末尾\r\n削除</span>
                 .to!<span class="dt">uint</span>;  <span class="co">// 変換</span>

    <span class="co">// 入力の各行に対してループ</span>
    <span class="kw">foreach</span>(line; stdin.byLine)
        writeln(line.take(n));
}</code></pre>
</section>
<section id="連想配列" class="slide level2">
<h1>連想配列</h1>
<pre class="sourceCode d"><code class="sourceCode d"><span class="dt">void</span> main()
{
    <span class="dt">int</span>[<span class="dt">string</span>] aa = [<span class="st">&quot;1&quot;</span> : <span class="dv">1</span>, <span class="st">&quot;2&quot;</span> : <span class="dv">3</span>];

    aa[<span class="st">&quot;4&quot;</span>] = <span class="dv">5</span>;
    <span class="kw">if</span>(<span class="kw">auto</span> p = <span class="st">&quot;3&quot;</span> <span class="kw">in</span> aa)
        writeln(*p);    <span class="co">// aa[&quot;3&quot;]</span>
    <span class="kw">else</span>
        writeln(<span class="st">&quot;aa does not have 3&quot;</span>);

    writeln(aa.<span class="dt">length</span>);

    aa.remove(<span class="st">&quot;4&quot;</span>);
    <span class="kw">assert</span>(<span class="st">&quot;4&quot;</span> !<span class="kw">in</span> aa);
}</code></pre>
</section>
<section class="slide level2">

<h3 id="foreach">foreach</h3>
<pre class="sourceCode d"><code class="sourceCode d"><span class="dt">void</span> main()
{
    <span class="kw">auto</span> madoMagi = [<span class="st">&quot;mado&quot;</span>: <span class="dv">1</span>, <span class="st">&quot;homu&quot;</span>: <span class="dv">2</span>,
                     <span class="st">&quot;saya&quot;</span>: <span class="dv">3</span>, <span class="st">&quot;anko&quot;</span>: <span class="dv">4</span>, <span class="st">&quot;mami&quot;</span>: <span class="dv">5</span>];

    <span class="kw">foreach</span>(k, v; madoMagi)
        writefln(<span class="st">&quot;%s : %s&quot;</span>, k, v);

    writeln();

    <span class="kw">foreach</span>(k, <span class="kw">ref</span> v; madoMagi)
        v = <span class="dv">100</span>;

    writefln(<span class="st">&quot;%-(%s : %s%|\n%)&quot;</span>, madoMagi);
}</code></pre>
</section>
<section class="slide level2">

<h3 id="その他の列挙方法">その他の列挙方法</h3>
<ul>
<li><code>aa.byKey</code>：キーのレンジ</li>
<li><code>aa.keys</code>：キーの配列(新たに確保)</li>
<li><code>aa.byValue</code>：値のレンジ</li>
<li><code>aa.values</code>：値の配列(新たに確保)</li>
</ul>
</section>
<section class="slide level2">

<h3 id="ユーザー定義のキー型">ユーザー定義のキー型</h3>
<ul>
<li>デフォルトではバイナリから算出</li>
<li>ユーザーがカスタマイズ可能</li>
</ul>
<pre class="sourceCode d"><code class="sourceCode d"><span class="co">/// test.d</span>
<span class="kw">import</span> std.stdio;

<span class="kw">struct</span> MyKey
{
    <span class="dt">int</span> a;
    <span class="dt">int</span> b;  <span class="co">// これを無視したい</span>

    <span class="dt">hash_t</span> toHash() <span class="kw">const</span> <span class="kw">nothrow</span> @safe { <span class="kw">return</span> a; }
    <span class="dt">bool</span> opEquals(<span class="kw">ref</span> <span class="kw">const</span> MyKey rhs) <span class="kw">const</span>
    { <span class="kw">return</span> <span class="kw">this</span>.a == rhs.a; }
}

<span class="dt">void</span> main()
{
    <span class="dt">int</span>[MyKey] aa;

    aa[MyKey(<span class="dv">1</span>, <span class="dv">2</span>)] = <span class="dv">12</span>;
    aa[MyKey(<span class="dv">2</span>, <span class="dv">3</span>)] = <span class="dv">3</span>;
    aa[MyKey(<span class="dv">3</span>, <span class="dv">4</span>)] = <span class="dv">4</span>;

    aa[MyKey(<span class="dv">1</span>, <span class="dv">4</span>)] = <span class="dv">8</span>;   <span class="co">// rewrite</span>

    writeln(aa);
}</code></pre>
</section>
<section class="slide level2">

<h3 id="問題-1">問題</h3>
<ul>
<li><a href="https://k3kaimu.github.io/dmanual/associative_array/">d-manual</a></li>
</ul>
</section>
    </div>
  </div>

  <script src="reveal.js/lib/js/head.min.js"></script>
  <script src="reveal.js/js/reveal.min.js"></script>

  <script>

      // Full list of configuration options available here:
      // https://github.com/hakimel/reveal.js#configuration
      Reveal.initialize({
        controls: true,
        progress: true,
        history: true,
        center: true,
        theme: 'sky', // available themes are in /css/theme
        transition: Reveal.getQueryHash().transition || 'default', // default/cube/page/concave/zoom/linear/fade/none

        // Optional libraries used to extend on reveal.js
        dependencies: [
          { src: 'reveal.js/lib/js/classList.js', condition: function() { return !document.body.classList; } },
          { src: 'reveal.js/plugin/zoom-js/zoom.js', async: true, condition: function() { return !!document.body.classList; } },
          { src: 'reveal.js/plugin/notes/notes.js', async: true, condition: function() { return !!document.body.classList; } },
//          { src: 'reveal.js/plugin/search/search.js', async: true, condition: function() { return !!document.body.classList; }, }
//          { src: 'reveal.js/plugin/remotes/remotes.js', async: true, condition: function() { return !!document.body.classList; } }
]});
    </script>
  </body>
</html>
