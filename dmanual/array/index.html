<!DOCTYPE html>
<html lang="ja" xmlns="http://www.w3.org/1999/xhtml" prefix="og: http://ogp.me/ns#">
  <head>
    
<meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<meta name="format-detection" content="telephone=no">
<link rel="alternate" type="application/rss+xml" title="RSS Feed" href="http://k3kaimu.github.io/atom.xml">
<link rel="shortcut icon" href="/favicon.ico">

    <title> 07 配列 | Go to the future</title>
    
<meta property="og:type" content="blog">
<meta property="og:title" content="07 配列">
<meta property="og:description" content="{{ **注意** このページを含むd-manualの全記事は[専用ページ](https://k3kaimu.github.io/dmanual/)へ移行しました。今後は上記の専用ページでご覧ください。}}

{% tree %}

## 配列(Array)とは？

配列というのは「メモリ上に...">
<meta property="og:url" content="http://k3kaimu.github.io/dmanual/array/">

<meta property="og:site_name" content="Go to the future">
<meta property="og:locale" content="ja_JP">
<meta name="twitter:card" content="summary">

<meta name="twitter:site" content="@k3_kaimu">


    
<link rel="stylesheet" href="//netdna.bootstrapcdn.com/bootswatch/3.0.2/cerulean/bootstrap.min.css">
<link rel="stylesheet" href="//netdna.bootstrapcdn.com/font-awesome/4.0.3/css/font-awesome.min.css">
<link rel="stylesheet" href="/assets/css/all.min.css">
<link rel="stylesheet" href="/assets/css/navigation.css">

    
<!--[if lt IE 9]>
  <script src="https://oss.maxcdn.com/libs/html5shiv/3.7.0/html5shiv.js"></script>
  <script src="https://oss.maxcdn.com/libs/respond.js/1.3.0/respond.min.js"></script>
<![endif]-->

  </head>
  <body>
    
<div class="navbar navbar-default navbar-fixed-top" role="navigation">
  <div class="container">
    <div class="navbar-header">
      <a href="/" class="navbar-brand">Go to the future</a>
      <button class="navbar-toggle" type="button" data-toggle="collapse" data-target="#navbar-main">
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
      </button>
    </div>
    <div class="navbar-collapse collapse" id="navbar-main">
      <ul class="nav navbar-nav js_nav">
        <li><a href="/blog/">Blog</a></li>
        <li><a href="/dmanual/">DManual</a></li>
        <li><a href="/dtips/">DTips</a></li>
        <!--<li><a href="/archives/">Index...</a></li>
        -->
        <li class="dropdown">
          <a href="#" class="dropdown-toggle" data-toggle="dropdown">Index...<b class="caret"></b></a>
          <ul class="dropdown-menu">
            <li>
              <a href="/archives/" itemprop="sameAs" content="/archives/">
                <i class="fa fa-archive fa-lg"></i> Archives
              </a>
            </li>
            <li>
              <a href="/categories/" itemprop="sameAs" content="/categories/">
                <i class="fa fa-folder-open fa-lg"></i> Categories
              </a>
            </li>
            <li>
              <a href="/tags/" itemprop="sameAs" content="/tags/">
                <i class="fa fa-tags fa-lg"></i> Tags
              </a>
            </li>
          </ul>
        </li>
      </ul>
      <div id="owner" itemprop="author copyrightHolder editor" itemscope itemtype="http://schema.org/Person">
        <ul class="nav navbar-nav navbar-right">
          <li class="dropdown">
            <a href="#" class="dropdown-toggle" data-toggle="dropdown">k3-kaimu <b class="caret"></b></a>
            <ul class="dropdown-menu">
              
              <li>
                
                <a href="https://www.github.com/k3kaimu" itemprop="sameAs" content="https://www.github.com/k3kaimu">
                  <i class="fa fa-github-square fa-lg"></i> GitHub
                </a>
              </li>
              
              
              <li>
                
                <a href="http://www.twitter.com/k3_kaimu" itemprop="sameAs" content="http://www.twitter.com/k3_kaimu">
                  <i class="fa fa-twitter-square fa-lg"></i> Twitter
                </a>
              </li>
              
              
              
              <li>
                <a href="/atom.xml">
                  <i class="fa fa-rss-square fa-lg fa-lg"></i> Rss
                </a>
              </li>
            </ul>
          </li>
        </ul>
      </div>
    </div>
  </div>
</div>

    <div id="content">
      <div class="container">
        <article itemscope itemtype="http://schema.org/Article" itemref="owner">
          
<div class="row">
  <div class="col-md-12 col-sm-12 col-xs-12">
    <div class="page-header">
      <h1 itemprop="url" content="http://k3kaimu.github.io/dmanual/array/">
        <i class="fa fa-puzzle-piece fa-lg"></i> <span itemprop="name">07 配列</span>
      </h1>
    </div>
  </div>
</div>

          <div class="row">
            <div class="col-md-12 col-sm-12 col-xs-12">
              <div itmprop="articleBody">
                <p><h2 class="content_tree">Contents</h2><div class="content_tree_list"><ul><li>配列(Array)とは？</li><li>スタックとヒープ</li><li>静的配列(Static Array)</li><li>配列とポインタのお話</li><li>スライス</li><ul><li>ヒープ上のメモリの確保</li><li>要素の追加とスライス同士の結合、大きさの拡大縮小</li><li>ガベージコレクタ</li><li>スライス演算子</li><li>スライスを使ったベクトル演算</li><li>スライスの独立性</li></ul><li>スライスや配列の等価テスト(同値テスト)</li><li>スライスや配列の大小比較</li><li>foreachと配列</li><li>Rangeとスライス</li><li>静的配列やスライスのプロパティとメソッド</li><li>多次元配列(配列の配列)</li><li>配列操作のまとめ</li><li>問題 -&gt; <a href="answer.md#array">解答</a></li><li>終わりに</li><li>キーワード</li><li>仕様</li></ul></ul></div></p>

<h2>配列(Array)とは？</h2>

<p>配列というのは「メモリ上に連続した値のリスト(list)」です。
たとえば<code>int</code>型の配列は、<code>int</code>型の値がメモリ上に連続しているリストのことを言います。
配列を構成する個々の値のことを要素(element)とよび、各要素にアクセスするにはメモリ上での順番と同じインデックス(添字, Index)という整数値を使い、<code>arr[idx]</code>とします。
<code>arr</code>は配列型の値で、<code>idx</code>はインデックスを表す整数型の値です。
インデックスはメモリ上での順番に沿って<code>0, 1, 2, 3, ...</code>と割り振れるため、インデックスが0の要素<code>arr[0]</code>を「先頭要素」、インデックスが<code>idx</code>な要素<code>arr[idx]</code>を「<code>idx</code>番目の要素」などと言ったりします。
注意しなければいけないのは、「先頭要素」と「0番目の要素」は同じ意味です。</p>

<p>また、配列は有限の長さ(大きさ)分だけ要素を持ちます。
配列<code>arr</code>の長さは、<code>arr.length</code>で取得可能です。
<code>arr.length</code>が<code>2</code>であれば、配列<code>arr</code>が持つ要素の数は2個で、インデックスは<code>0, 1</code>の2つが有効です。
一般に、有効なインデックスは<code>0</code>から<code>arr.length - 1</code>であり、それ以外のインデックス、たとえば<code>-1</code>とか<code>arr.length</code>でアクセスしようとするとエラーが出ます。</p>

<p><code>arr[idx]</code>は左辺値なので、<code>arr[idx] = value;</code>のように代入も可能です。
最終要素の左辺値を取得するには<code>arr[arr.length - 1]</code>とします。
<code>[]</code>の中では<code>arr.length =&gt; $</code>と書き換えれるので、<code>arr[$-1]</code>も最終要素の左辺値となります。</p>

<p>今までよく出てきた<code>string</code>も実際には「『書き換え不可能な文字』の配列」でした。
先頭文字は<code>str[0]</code>で取得できますし、<code>str[$-1]</code>とすれば最後の文字が得られます。</p>

<p>配列を使う理由は、&quot;大量&quot;の変数を&quot;まとめて&quot;扱いたいからです。
たとえば、文字列<code>&quot;abcd&quot;</code>の各文字にそれぞれ<code>char</code>型の変数を<code>char str0 = &#39;a&#39;, str1 = &#39;b&#39;, str2 = &#39;c&#39;, str3 = &#39;d&#39;;</code>のように割り当てていては使い勝手が悪すぎます。</p>

<h2>スタックとヒープ</h2>

<p>スタック(Stack)領域は、静的にその大きさが決められ、関数の開始時に有効となり、関数の終了とともに消滅するメモリ領域のことです。
関数内で宣言した変数はすべてスタックに置かれます。
(もちろん、ポインタやスライス、クラスといった参照型は、参照先がスタック上にないかもしれないだけで、変数自体はスタック上にあります。)</p>

<p>これに対となるのがヒープ(Heap)領域で、動的に確保可能、つまり実行時に欲しいだけの領域を確保可能です。
また、関数が終了しても存在し続けるメモリ領域で、<code>new</code>演算子や<code>core.memory.GC.malloc</code>などを用いて確保します。
動的に確保するため、実行時に多少の時間的コストもかかります。</p>

<p>通常、スタック領域は1MB程度と小さいので、大量のメモリが必要であればヒープ領域を確保します。</p>

<h2>静的配列(Static Array)</h2>

<p>静的配列は、スタック上に確保される配列で、C言語の配列(mallocで確保する領域ではない)に似ています。
<code>T</code>型の要素を<code>N</code>個もつ静的配列は<code>T[N]</code>という型になります。
静的配列は、それ全体が値的な性質を持っています。
たとえば次のコードでは、静的配列全体をコピーする操作になります。</p>
<div class="highlight"><pre><code class="language-d" data-lang="d"><span class="kt">int</span><span class="p">[</span><span class="mi">16</span><span class="p">]</span> <span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">;</span>

<span class="c1">// a, bに対するいくつかの操作</span>

<span class="n">a</span> <span class="p">=</span> <span class="n">b</span><span class="p">;</span>              <span class="c1">// 要素すべてのコピー</span>
</code></pre></div>
<p>静的配列の長さはコンパイル時に固定され、実行時に変更することはできません。
また、長さの違う静的配列のコピーはコンパイル時にエラーになります。</p>
<div class="highlight"><pre><code class="language-d" data-lang="d"><span class="kt">int</span><span class="p">[</span><span class="mi">16</span><span class="p">]</span> <span class="n">a</span><span class="p">;</span>
<span class="kt">int</span><span class="p">[</span><span class="mi">17</span><span class="p">]</span> <span class="n">b</span><span class="p">;</span>

<span class="n">a</span><span class="p">.</span><span class="n">length</span> <span class="p">=</span> <span class="mi">1024</span><span class="p">;</span>    <span class="c1">// Error: constant a.length is not an lvalue</span>
<span class="n">a</span> <span class="p">=</span> <span class="n">b</span><span class="p">;</span>              <span class="c1">// Error: mismatched array lengths, 16 and 17</span>

<span class="n">a</span> <span class="p">=</span> <span class="n">b</span><span class="p">[</span><span class="mi">0</span> <span class="p">..</span> <span class="mi">16</span><span class="p">];</span>     <span class="c1">// 後ほど説明するスライスに変換してしまえばコピー可能</span>
</code></pre></div>
<p>スタック領域は容量に制限がある(例. 1MB)ので、大きな静的配列を確保するのはオススメしません。
また、静的配列への代入は全要素のコピーなので、大きな配列であればコピーに時間がかかってしまいます。</p>
<div class="highlight"><pre><code class="language-d" data-lang="d"><span class="kt">int</span><span class="p">[</span><span class="mi">1024</span> <span class="p">*</span> <span class="mi">1024</span> <span class="p">*</span> <span class="mi">4</span><span class="p">]</span> <span class="n">a</span><span class="p">;</span>     <span class="c1">// Error: index 4194304 overflow for static array</span>
</code></pre></div>
<p>このような場合には、静的配列は諦めて後述する<code>new int[1024 * 1024 * 4]</code>によってヒープ上に領域を確保するしかありません。</p>

<h2>配列とポインタのお話</h2>

<p>配列というのは、メモリ上に連続する値のリストのことでした。
配列を最もシンプルに表すためには、「メモリ上での位置」と「配列の大きさ」が必要です。
つまり、「配列の先頭要素<code>arr[0]</code>を指すメモリアドレス値」と「配列の大きさ」があれば十分にその配列を表現可能です。
メモリアドレス値はポインタ値(Pointer)と呼ばれ、今までに数回出て来ましたね。</p>
<div class="highlight"><pre><code class="language-d" data-lang="d"><span class="n">T</span><span class="p">*</span> <span class="n">ptr</span><span class="p">;</span>         <span class="c1">// 先頭要素を指すポインタ</span>
<span class="nb">size_t</span> <span class="n">length</span><span class="p">;</span>  <span class="c1">// 配列の長さ</span>
</code></pre></div>
<p>D言語の親であるC言語では、スタック上に確保される静的配列や可変長配列(VLA, Variable Length Array)は、ポインタ的な振る舞いもしますし、<code>sizeof</code>演算子で配列の要素数も取得可能です。
また、大きな配列を確保したければ、<code>malloc</code>や<code>calloc</code>を使ってヒープ上に確保し、以降はポインタ値と長さを表す変数をペアで運用するのが普通です。</p>

<p>D言語は、C言語のこのような流れを継承しているので、ポインタでも配列のようなことができますが、より良く配列を表現するためスライス(Slice)というものを導入しました。
D言語のスライスは、ポインタ値と大きさのペアでしかなく、よく勘違いされるのですが、他の言語の動的配列(たとえばC++の<code>vector</code>やJavaの<code>ArrayList</code>)とは全く異なったコンセプトです。</p>

<h2>スライス</h2>

<p>普通、D言語で「動的配列」と呼ばれたらスライスのことを指します。
実際に、仕様上はスライスは「動的配列型(Dynamic Array)」となっていますが、スライスと呼ばれることが多いので本稿ではスライスとします。</p>

<p>スライスは、スライスの先頭要素へのポインタ値とスライスの長さしか持ちません。
ですから、スライスはポインタからも生成可能ですし、静的配列からも作れます。
スライスの型は<code>T[]</code>となります。
スライスの大きさは、<code>slice.length</code>で取得可能で、<code>slice[idx]</code>でスライスの要素の左辺値を取得可能です。</p>
<div class="highlight"><pre><code class="language-d" data-lang="d"><span class="kt">int</span><span class="p">*</span> <span class="n">p</span><span class="p">;</span>
<span class="nb">size_t</span> <span class="n">size</span><span class="p">;</span>

<span class="c1">// 適当なpとsizeに関する操作, pは配列の先頭要素へのポインタ, sizeは配列の長さ</span>

<span class="kt">int</span><span class="p">[]</span> <span class="n">slice1</span> <span class="p">=</span> <span class="n">p</span><span class="p">[</span><span class="mi">0</span> <span class="p">..</span> <span class="n">size</span><span class="p">];</span>    <span class="c1">// ポインタとサイズからスライスの生成</span>

<span class="kt">int</span><span class="p">[</span><span class="mi">25</span><span class="p">]</span> <span class="n">arr</span><span class="p">;</span>
<span class="kt">int</span><span class="p">[]</span> <span class="n">slice2</span> <span class="p">=</span> <span class="n">arr</span><span class="p">[];</span>           <span class="c1">// 静的配列からスライスの生成</span>

<span class="kt">int</span><span class="p">[]</span> <span class="n">slice3</span><span class="p">;</span>                   <span class="c1">// デフォルト初期化</span>
<span class="n">slice3</span> <span class="p">~=</span> <span class="n">slice1</span><span class="p">;</span>               <span class="c1">// デフォルト初期化値でも追加や連結、拡大可能</span>
</code></pre></div>
<h3>ヒープ上のメモリの確保</h3>

<p>では、ヒープ上に新しい領域を確保するにはどのようにするのでしょうか？
C言語のように<code>malloc</code>や<code>calloc</code>を使うのは安全ではありません。
D言語にはD言語なりの確保方法があります。
<code>new T[n]</code>とすれば、ヒープ上に新しく最低<code>n</code>個の<code>T</code>型の領域が割り当てられ、その領域を示すスライス<code>T[]</code>がその値となります。</p>
<div class="highlight"><pre><code class="language-d" data-lang="d"><span class="kt">int</span><span class="p">[]</span> <span class="n">arr</span> <span class="p">=</span> <span class="k">new</span> <span class="kt">int</span><span class="p">[</span><span class="mi">10000</span><span class="p">];</span>   <span class="c1">// ヒープ上に1万要素を確保し、スライスとして取得</span>
</code></pre></div>
<h3>要素の追加とスライス同士の結合、大きさの拡大縮小</h3>

<p>スライスは動的配列ではありませんが、動的配列のように要素の追加、結合、大きさの拡大縮小も可能です。
D言語のランタイムが賢く動くので、プログラマは少しだけ注意すればほとんど考える必要はありません。</p>
<div class="highlight"><pre><code class="language-d" data-lang="d"><span class="kt">int</span><span class="p">[]</span> <span class="n">arr</span> <span class="p">=</span> <span class="n">foo</span><span class="p">();</span>  <span class="c1">// なにか適当なスライス</span>

<span class="n">arr</span> <span class="p">~=</span> <span class="mi">1</span><span class="p">;</span>           <span class="c1">// 要素の追加</span>
<span class="n">arr</span> <span class="p">~=</span> <span class="n">foo</span><span class="p">();</span>       <span class="c1">// スライスの結合</span>

<span class="n">arr</span> <span class="p">=</span> <span class="n">arr</span> <span class="p">~</span> <span class="n">arr</span><span class="p">;</span>    <span class="c1">// 2項演算子としての結合</span>

<span class="n">arr</span><span class="p">.</span><span class="n">length</span> <span class="p">=</span> <span class="mi">100</span><span class="p">;</span>   <span class="c1">// 大きさの変更</span>
</code></pre></div>
<p>スライスの大きさが大きくなった場合、その前後でスライスの持つポインタ値が一致しない場合があります。
このとき、「スライスを大きくする」操作は実際には「新しいヒープ領域を確保し、メモリの内容をコピーし、その領域を示すスライスにする」という操作になります。
スライスの領域に連続して未使用の予約された領域が存在するならば、ポインタの値は変えずにスライスの大きさを大きくして、その予約された領域へ追加の値をコピーします。
逆を言えば、静的配列やポインタなどから作成されたスライスへの追加や拡大は、絶対に予約領域がありませんから、必ず新しい領域の確保とその領域への全体のコピーが行われます。
スライスで一番難しいのはこの仕様で、新しい領域の確保のタイミングは把握しにくくなります。</p>

<h3>ガベージコレクタ</h3>

<p>スライスはスタックやヒープにかかわらず、動的配列のようなインターフェースを提供することがわかりました。
では、<code>new</code>でヒープ領域を確保したり、追加や連結、拡大によって確保されたヒープ領域のメモリはどのように開放されるのでしょうか？
D言語はガベージコレクタを言語仕様として持つので、これらの開放はガベージコレクタによってなされます。
ですから、プログラマはほとんど何も考えずに、様々なメモリ領域をスライスにでき、さも動的配列のように動作させることができるのです。</p>

<h3>スライス演算子</h3>

<p>ポインタ, 静的配列, スライスから、その領域のスライスを得る方法としてスライス演算子があります。
スライス演算子は<code>p[idxBegin .. idxEnd]</code>と書きます。
<code>idxBegin</code>は新しいスライスの開始インデックス、<code>idxEnd</code>は、最終要素のインデックス+1です。
もし、<code>p</code>がスライスもしくは静的配列であれば、<code>idxBegin</code>, <code>idxEnd</code>の両方は<code>p</code>の長さを表す<code>$</code>を含んだ式にできます。
もし、スライスや静的配列に対して、その領域への新たなスライスが欲しいなら<code>p[0 .. $]</code>と書く代わりに<code>p[]</code>とも書けます。</p>
<div class="highlight"><pre><code class="language-d" data-lang="d"><span class="kt">int</span><span class="p">*</span> <span class="n">p</span> <span class="p">=</span> <span class="n">foo</span><span class="p">();</span>

<span class="kt">int</span><span class="p">[]</span> <span class="n">slice1</span> <span class="p">=</span> <span class="n">p</span><span class="p">[</span><span class="mi">0</span> <span class="p">..</span> <span class="mi">100</span><span class="p">];</span>             <span class="c1">// ポインタから100個の領域のスライス</span>

<span class="kt">int</span><span class="p">[]</span> <span class="n">slice2</span> <span class="p">=</span> <span class="n">slice1</span><span class="p">[</span><span class="mi">10</span> <span class="p">..</span> <span class="p">$];</span>         <span class="c1">// slice1の10番目から最終要素までのスライス</span>

<span class="kt">int</span><span class="p">[</span><span class="mi">40</span><span class="p">]</span> <span class="n">staticArray</span><span class="p">;</span>

<span class="kt">int</span><span class="p">[]</span> <span class="n">slice3</span> <span class="p">=</span> <span class="n">staticArray</span><span class="p">[</span><span class="mi">0</span> <span class="p">..</span> <span class="p">$-</span><span class="mi">10</span><span class="p">];</span>  <span class="c1">// 静的配列staticArrayの前から30個のスライス</span>

<span class="kt">int</span><span class="p">[]</span> <span class="n">emptySlice1</span> <span class="p">=</span> <span class="n">slice3</span><span class="p">[$</span> <span class="p">..</span> <span class="p">$],</span>     <span class="c1">// 長さ0のスライス</span>
      <span class="n">emptySlice2</span> <span class="p">=</span> <span class="n">slice3</span><span class="p">[</span><span class="mi">0</span> <span class="p">..</span> <span class="mi">0</span><span class="p">];</span>     <span class="c1">// 長さ0のスライス</span>

<span class="n">slice3</span> <span class="p">=</span> <span class="n">staticArray</span><span class="p">[];</span>                 <span class="c1">// staticArray[0 .. $]と同じ</span>
</code></pre></div>
<h3>スライスを使ったベクトル演算</h3>

<p>スライスの各要素をコピーしたり、各要素間でベクトル加算などをするときに便利です。
また、SIMD化も狙えるかもしれませんし、foreachやforでループを回すよりも高速になるでしょう。</p>
<div class="highlight"><pre><code class="language-d" data-lang="d"><span class="kt">int</span><span class="p">[]</span> <span class="n">arr1</span> <span class="p">=</span> <span class="k">new</span> <span class="kt">int</span><span class="p">[</span><span class="mi">1024</span><span class="p">],</span>
      <span class="n">arr2</span> <span class="p">=</span> <span class="k">new</span> <span class="kt">int</span><span class="p">[</span><span class="mi">1024</span><span class="p">];</span>

<span class="n">arr1</span><span class="p">[]</span> <span class="p">=</span> <span class="mi">10</span><span class="p">;</span>                    <span class="c1">// 全要素に10を代入</span>
<span class="n">arr2</span><span class="p">[]</span> <span class="p">-=</span> <span class="mi">100</span><span class="p">;</span>                  <span class="c1">// 全要素から100を引く</span>
<span class="n">arr1</span><span class="p">[]</span> <span class="p">*=</span> <span class="n">arr2</span><span class="p">[];</span>               <span class="c1">// 2つのスライスの全要素それぞれを掛け合わせ、arr1に格納。</span>

<span class="n">arr2</span><span class="p">[</span><span class="mi">0</span> <span class="p">..</span> <span class="mi">8</span><span class="p">]</span> <span class="p">*=</span> <span class="n">arr1</span><span class="p">[</span><span class="mi">8</span> <span class="p">..</span> <span class="mi">16</span><span class="p">];</span>  <span class="c1">// 8要素だけの掛け算</span>

<span class="n">arr2</span><span class="p">[</span><span class="mi">8</span> <span class="p">..</span> <span class="p">$]</span> <span class="p">=</span> <span class="n">arr1</span><span class="p">[</span><span class="mi">8</span> <span class="p">..</span> <span class="p">$];</span>    <span class="c1">// メモリのコピー</span>
</code></pre></div>
<h3>スライスの独立性</h3>

<p>たとえば次のコードを考えてみましょう。</p>
<div class="highlight"><pre><code class="language-d" data-lang="d"><span class="kt">int</span><span class="p">[]</span> <span class="n">arr</span> <span class="p">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">];</span>
<span class="kt">int</span><span class="p">[]</span> <span class="n">slice1</span> <span class="p">=</span> <span class="n">arr</span><span class="p">;</span>

<span class="k">assert</span><span class="p">(</span><span class="n">arr</span> <span class="p">==</span> <span class="n">slice1</span><span class="p">);</span>

<span class="n">arr</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="p">=</span> <span class="p">-</span><span class="mi">1</span><span class="p">;</span>                            <span class="c1">// arrの先頭を-1に書き換え</span>
<span class="k">assert</span><span class="p">(</span><span class="n">slice1</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="p">==</span> <span class="p">-</span><span class="mi">1</span><span class="p">);</span>                <span class="c1">// slice1はarrの領域を参照しているだけにすぎない</span>

<span class="n">arr</span> <span class="p">=</span> <span class="n">arr</span><span class="p">[</span><span class="mi">0</span> <span class="p">..</span> <span class="mi">2</span><span class="p">];</span>
<span class="k">assert</span><span class="p">(</span><span class="n">arr</span><span class="p">.</span><span class="n">lengt</span> <span class="p">==</span> <span class="mi">2</span><span class="p">);</span>                 <span class="c1">// arrの大きさは2となる</span>
<span class="k">assert</span><span class="p">(</span><span class="n">slice1</span><span class="p">.</span><span class="n">length</span> <span class="p">==</span> <span class="mi">6</span><span class="p">);</span>             <span class="c1">// たとえarrの大きさが変わってもslice1の大きさに変わりはない</span>

<span class="n">arr</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="p">=</span> <span class="p">-</span><span class="mi">2</span><span class="p">;</span>                            <span class="c1">// arrの先頭要素を書き換えれば</span>
<span class="k">assert</span><span class="p">(</span><span class="n">slice1</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="p">==</span> <span class="p">-</span><span class="mi">2</span><span class="p">);</span>                <span class="c1">// slice1も同一領域を参照しているので書き換わる</span>

<span class="n">arr</span><span class="p">.</span><span class="n">length</span> <span class="p">=</span> <span class="mi">10</span><span class="p">;</span>                        <span class="c1">// arrの大きさを大きくしてみる</span>
<span class="k">assert</span><span class="p">(</span><span class="n">slice1</span><span class="p">.</span><span class="n">length</span> <span class="p">==</span> <span class="mi">6</span><span class="p">);</span>             <span class="c1">// もちろん、slice1の大きさは変わらない</span>

<span class="n">arr</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="p">=</span> <span class="p">-</span><span class="mi">3</span><span class="p">;</span>                            <span class="c1">// しかし、arrの先頭要素を書き換えても</span>
<span class="k">assert</span><span class="p">(</span><span class="n">slice1</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="p">==</span> <span class="p">-</span><span class="mi">2</span><span class="p">);</span>                <span class="c1">// slice1の先頭要素に影響はない。</span>
                                        <span class="c1">// arr.length = 10;で新しい領域にarrの内容がコピーされ、arrはそれを指している。</span>
</code></pre></div>
<p>スライス<code>T[]</code>は、ポインタ<code>T*</code>とサイズ<code>size_t</code>のペアであると考えられます。
また、スライスの縮小だけでは新しい領域が確保されることはありません。
結合や拡大を行なってしまえば、新たに確保される可能性があり、新しい領域が確保された場合には、もちろん他のスライスへの影響は無くなります。</p>

<h2>スライスや配列の等価テスト(同値テスト)</h2>

<p>静的配列やスライスを<code>==</code>演算子や<code>!=</code>演算子で比較すると、全要素が等しいかそうでないかを判定します。
つまり、スライスであれば参照先のポインタには関係ありません。
もし、スライスが同じ領域を指しているかどうかを確認したい場合には<code>is</code>演算子を使います。</p>
<div class="highlight"><pre><code class="language-d" data-lang="d"><span class="kt">int</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span> <span class="n">stArr1</span> <span class="p">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">],</span>
       <span class="n">stArr2</span> <span class="p">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span>
       <span class="n">stArr3</span> <span class="p">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">];</span>

<span class="n">writeln</span><span class="p">(</span><span class="n">stArr1</span> <span class="p">!=</span> <span class="n">stArr2</span><span class="p">);</span>      <span class="c1">// true     要素が違う</span>
<span class="n">writeln</span><span class="p">(</span><span class="n">stArr1</span> <span class="p">==</span> <span class="n">stArr3</span><span class="p">);</span>      <span class="c1">// true     要素は全部同じ</span>

<span class="kt">int</span><span class="p">[]</span> <span class="n">slice1</span> <span class="p">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">],</span>
      <span class="n">slice2</span> <span class="p">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span>
      <span class="n">slice3</span> <span class="p">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">];</span>

<span class="n">writeln</span><span class="p">(</span><span class="n">slice1</span> <span class="p">!=</span> <span class="n">slice2</span><span class="p">);</span>      <span class="c1">// true     要素が違う</span>
<span class="n">writeln</span><span class="p">(</span><span class="n">slice1</span> <span class="p">==</span> <span class="n">slice3</span><span class="p">);</span>      <span class="c1">// true     要素は全部同じ</span>

<span class="n">writeln</span><span class="p">(</span><span class="n">slice1</span> <span class="p">!</span><span class="k">is</span> <span class="n">slice3</span><span class="p">);</span>     <span class="c1">// true     参照している領域が違う</span>

<span class="kt">int</span><span class="p">[]</span> <span class="n">slice4</span> <span class="p">=</span> <span class="n">slice1</span><span class="p">;</span>
<span class="n">writeln</span><span class="p">(</span><span class="n">slice4</span> <span class="k">is</span> <span class="n">slice1</span><span class="p">);</span>      <span class="c1">// true     slice4はslice1と同じ領域を指している</span>

<span class="n">slice4</span> <span class="p">=</span> <span class="n">slice4</span><span class="p">[</span><span class="mi">1</span> <span class="p">..</span> <span class="p">$];</span>
<span class="n">writeln</span><span class="p">(</span><span class="n">slice4</span> <span class="p">!</span><span class="k">is</span> <span class="n">slice1</span><span class="p">);</span>     <span class="c1">// true     指している先(ptr)は同じだが、長さが違う</span>

<span class="n">writeln</span><span class="p">(</span><span class="n">stArr1</span> <span class="p">==</span> <span class="n">slice1</span><span class="p">);</span>      <span class="c1">// true     もちろん、静的配列とスライスの比較も可能</span>
</code></pre></div>
<h2>スライスや配列の大小比較</h2>

<p>Dでは、配列の大小関係も比較できます。
配列の大小は、「辞書」に並ぶように決められています。</p>

<p>たとえば、「あああ」と「ああい」では、「あああ」のほうが(もし辞書に並ぶなら)前にあるでしょう。
よって、「あああ」のほうが「ああい」より小さいとされます。
「ああい」と「ああ」では、両方の先頭2文字は「ああ」ですが「ああ」の方が文字数が少ないので、「ああ」のほうが辞書の前にきます。
ですから、「ああ」のほうが「ああい」より小さいとされるのです。</p>

<p>このようにD言語の配列は、辞書で前に載るものほど小さく、後ろに載るものほど大きくなります。</p>
<div class="highlight"><pre><code class="language-d" data-lang="d"><span class="kt">int</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span> <span class="n">stArr1</span> <span class="p">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">],</span>
       <span class="n">stArr2</span> <span class="p">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">];</span>
<span class="kt">int</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="n">stArr3</span> <span class="p">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">];</span>

<span class="n">writeln</span><span class="p">(</span><span class="n">stArr1</span> <span class="p">&lt;</span> <span class="n">stArr2</span><span class="p">);</span>       <span class="c1">// true</span>
<span class="n">writeln</span><span class="p">(</span><span class="n">stArr1</span> <span class="p">&gt;</span> <span class="n">stArr3</span><span class="p">);</span>       <span class="c1">// true</span>

<span class="kt">int</span><span class="p">[]</span> <span class="n">slice1</span> <span class="p">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">],</span>
      <span class="n">slice2</span> <span class="p">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span>
      <span class="n">slice3</span> <span class="p">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">];</span>

<span class="n">writeln</span><span class="p">(</span><span class="n">slice1</span> <span class="p">&lt;</span> <span class="n">slice2</span><span class="p">);</span>       <span class="c1">// true</span>
<span class="n">writeln</span><span class="p">(</span><span class="n">slice1</span> <span class="p">&gt;</span> <span class="n">slice3</span><span class="p">);</span>       <span class="c1">// true</span>

<span class="n">writeln</span><span class="p">(</span><span class="n">stArr1</span> <span class="p">&lt;</span> <span class="n">slice2</span><span class="p">);</span>       <span class="c1">// もちろん、静的配列とスライスの比較も可能</span>
</code></pre></div>
<p>文字列の比較を行う際にも<code>int[]</code>と同じように、辞書的に大小を比較します。</p>
<div class="highlight"><pre><code class="language-d" data-lang="d"><span class="nb">string</span> <span class="n">str1</span> <span class="p">=</span> <span class="s">&quot;Google&quot;</span><span class="p">,</span>
       <span class="n">str2</span> <span class="p">=</span> <span class="s">&quot;Goggles&quot;</span><span class="p">;</span>

<span class="n">writeln</span><span class="p">(</span><span class="n">str1</span> <span class="p">&gt;</span> <span class="n">str2</span><span class="p">);</span>           <span class="c1">// true</span>
</code></pre></div>
<h2>foreachと配列</h2>

<p><code>foreach range</code>文というのは、すでに説明したとおり、ある範囲をループするのに使います。
今回説明するのは<code>foreach</code>文で、D言語の仕様的には<code>foreach range</code>文とは異なった文です。</p>

<p><code>foreach</code>文では、<code>foreach(&lt;elemement&gt;; &lt;array&gt;)</code>や<code>foreach(&lt;index&gt;, &lt;element&gt;; &lt;array&gt;)</code>と書くことができます。
<code>foreach</code>文は、インデックスが<code>0</code>の要素(先頭要素)から順番に処理されますが、<code>foreach_reverse</code>とした場合にはインデックスが最大の要素(最終要素)から順番に処理されていきます。
例を示しますと、以下のように使えます。</p>
<div class="highlight"><pre><code class="language-d" data-lang="d"><span class="c1">/// test00801.d</span>
<span class="k">import</span> <span class="n">std</span><span class="p">.</span><span class="n">stdio</span><span class="p">,</span> <span class="n">std</span><span class="p">.</span><span class="nb">string</span><span class="p">,</span> <span class="n">std</span><span class="p">.</span><span class="n">array</span><span class="p">,</span> <span class="n">std</span><span class="p">.</span><span class="n">typecons</span><span class="p">;</span>

<span class="kt">void</span> <span class="n">main</span><span class="p">()</span>
<span class="p">{</span>
    <span class="c1">// `e`はスライスの要素の値で、`foreach_reverse`なので最終要素からイテレートする</span>
    <span class="k">foreach_reverse</span><span class="p">(</span><span class="n">e</span><span class="p">;</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">])</span>
        <span class="n">writeln</span><span class="p">(</span><span class="n">e</span><span class="p">);</span>


    <span class="kt">int</span><span class="p">[</span><span class="mi">5</span><span class="p">]</span> <span class="n">arr</span> <span class="p">=</span> <span class="mi">10</span><span class="p">;</span>

    <span class="c1">// `i`はインデックス、`e`は要素の値。もちろん、`i`は`0`から`arr.length-1`まで。</span>
    <span class="c1">// `ref e`となっているので、`e`を通して`arr`の内容を書き換え可能。</span>
    <span class="c1">// 逆を言えば、`ref`がついていなければ、foreach文内で`e`を通して`arr`の書き換えは不可能。</span>
    <span class="c1">// また、`arr`自体をforeach文の中で書き換えるのは不正</span>
    <span class="k">foreach</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="k">ref</span> <span class="n">e</span><span class="p">;</span> <span class="n">arr</span><span class="p">){</span>
        <span class="n">writefln</span><span class="p">(</span><span class="s">&quot;arr[%s] : %s&quot;</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">e</span><span class="p">);</span>
        <span class="n">e</span> <span class="p">=</span> <span class="n">i</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="n">writeln</span><span class="p">(</span><span class="n">arr</span><span class="p">);</span>       <span class="c1">// [0, 1, 2, 3, 4]</span>


    <span class="kt">int</span><span class="p">[]</span> <span class="n">arr2</span> <span class="p">=</span> <span class="k">new</span> <span class="kt">int</span><span class="p">[</span><span class="mi">32</span><span class="p">];</span>
    <span class="n">arr2</span><span class="p">[]</span> <span class="p">=</span> <span class="mi">10</span><span class="p">;</span>

    <span class="c1">// `i`にも`ref`が付いているので、イテレートするインデックスを操作可能。</span>
    <span class="c1">// この例の場合は、`i`は`0, 4, 8, 12, 16, 20, 24, 28`となる。</span>
    <span class="k">foreach</span><span class="p">(</span><span class="k">ref</span> <span class="n">i</span><span class="p">,</span> <span class="k">ref</span> <span class="n">e</span><span class="p">;</span> <span class="n">arr2</span><span class="p">){</span>
        <span class="n">writeln</span><span class="p">(</span><span class="n">i</span><span class="p">);</span>

        <span class="n">e</span> <span class="p">=</span> <span class="n">i</span><span class="p">;</span>
        <span class="n">i</span> <span class="p">+=</span> <span class="mi">3</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="n">writeln</span><span class="p">(</span><span class="n">arr2</span><span class="p">);</span>      <span class="c1">// [0, 10, 10, 10, 4, 10, 10, 10,</span>
                        <span class="c1">//  8, 10, 10, 10, 12, 10, 10, 10,</span>
                        <span class="c1">// 16, 10, 10, 10, 20, 10, 10, 10,</span>
                        <span class="c1">// 24, 10, 10, 10, 28, 10, 10, 10]</span>
<span class="p">}</span>
</code></pre></div><div class="highlight"><pre><code class="language-text" data-lang="text">$ rdmd test00801.d
3
2
1
0
arr[0] : 10
arr[1] : 10
arr[2] : 10
arr[3] : 10
arr[4] : 10
[0, 1, 2, 3, 4]
0
4
8
12
16
20
24
28
[0, 10, 10, 10, 4, 10, 10, 10, 8, 10, 10, 10, 12, 10, 10, 10, 16, 10, 10, 10, 20, 10, 10, 10, 24, 10, 10, 10, 28, 10, 10, 10]
</code></pre></div>
<p>注意しなければならないのは、<code>foreach</code>文中で、イテレート対象のスライスなどに対して要素の追加や削除を行なってはいけません。
つまり、次のコードはコンパイルは通りますが、書いてはいけないコードです。</p>
<div class="highlight"><pre><code class="language-d" data-lang="d"><span class="kt">int</span><span class="p">[]</span> <span class="n">arr</span> <span class="p">=</span> <span class="k">new</span> <span class="kt">int</span><span class="p">[</span><span class="mi">10</span><span class="p">];</span>

<span class="k">foreach</span><span class="p">(</span><span class="n">e</span><span class="p">;</span> <span class="n">arr</span><span class="p">)</span>
    <span class="n">arr</span> <span class="p">~=</span> <span class="mi">1</span><span class="p">;</span>
</code></pre></div>
<p>また、D言語の本家サイト<code>dlang.org</code>や邦訳版TDPLを読む限りでは、indexに<code>ref</code>をつけることは出来ないとなっています。
すなわち、これらに従うのであれば以下のコードはコンパイルできませんが、dmd 2.063から入った変更によって、<code>ref</code>指定できるようになっています。</p>
<div class="highlight"><pre><code class="language-d" data-lang="d"><span class="kt">int</span><span class="p">[]</span> <span class="n">arr</span> <span class="p">=</span> <span class="k">new</span> <span class="kt">int</span><span class="p">[</span><span class="mi">10</span><span class="p">];</span>

<span class="k">foreach</span><span class="p">(</span><span class="k">ref</span> <span class="n">i</span><span class="p">,</span> <span class="n">e</span><span class="p">;</span> <span class="n">arr</span><span class="p">)</span>
    <span class="n">writef</span><span class="p">(</span><span class="s">&quot;%d &quot;</span><span class="p">,</span> <span class="p">++</span><span class="n">i</span><span class="p">);</span>       <span class="c1">// 1 3 5 7 9</span>

<span class="n">writeln</span><span class="p">();</span>
</code></pre></div>
<h2>Rangeとスライス</h2>

<p>D言語には、レンジ(Range)という概念があります。
これは、<code>std.range</code>で定義されています。
Rangeは、リストや配列などのようなデータの構造を一般化したものと言えます。</p>

<p>たとえば、スライスは<code>std.array</code>を<code>import</code>すれば、<code>arr.front</code>, <code>arr.back</code>, <code>arr.popFront()</code>, <code>arr.popBack()</code>, <code>arr.empty</code>, <code>arr.save</code>が使用でき、
インデックスで各要素へアクセス可能で、長さ(<code>.length</code>)を持っているので、<code>Random access range</code>という分類になります。</p>
<div class="highlight"><pre><code class="language-d" data-lang="d"><span class="k">import</span> <span class="n">std</span><span class="p">.</span><span class="n">array</span><span class="p">,</span> <span class="n">std</span><span class="p">.</span><span class="n">stdio</span><span class="p">;</span>

<span class="kt">void</span> <span class="n">main</span><span class="p">()</span>
<span class="p">{</span>
    <span class="kt">int</span><span class="p">[]</span> <span class="n">arr</span> <span class="p">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">];</span>

    <span class="n">writeln</span><span class="p">(</span><span class="n">arr</span><span class="p">.</span><span class="n">empty</span><span class="p">);</span>     <span class="c1">// false    arrは空でない</span>
    <span class="n">writeln</span><span class="p">(</span><span class="n">arr</span><span class="p">.</span><span class="n">front</span><span class="p">);</span>     <span class="c1">// 0        arrの先頭要素は0</span>
    <span class="n">writeln</span><span class="p">(</span><span class="n">arr</span><span class="p">.</span><span class="n">back</span><span class="p">);</span>      <span class="c1">// 3        arrの最終要素は3</span>

    <span class="kt">int</span><span class="p">[]</span> <span class="n">arr2</span> <span class="p">=</span> <span class="n">arr</span><span class="p">.</span><span class="n">save</span><span class="p">;</span>  <span class="c1">// arrをpopFront(), popBack()しても、arr2に影響はない</span>
                            <span class="c1">// スライスでは、ただ単なる代入(arr2 = arr)と等価</span>

    <span class="n">arr</span><span class="p">.</span><span class="n">popFront</span><span class="p">();</span>         <span class="c1">// arrを一つ進める -&gt; arr = arr[1 .. $];と等価</span>
    <span class="n">writeln</span><span class="p">(</span><span class="n">arr</span><span class="p">);</span>           <span class="c1">// [1, 2, 3]</span>
    <span class="n">writeln</span><span class="p">(</span><span class="n">arr</span><span class="p">.</span><span class="n">empty</span><span class="p">);</span>     <span class="c1">// false</span>
    <span class="n">writeln</span><span class="p">(</span><span class="n">arr</span><span class="p">.</span><span class="n">front</span><span class="p">);</span>     <span class="c1">// 1</span>
    <span class="n">writeln</span><span class="p">(</span><span class="n">arr</span><span class="p">.</span><span class="n">back</span><span class="p">);</span>      <span class="c1">// 3</span>

    <span class="n">arr</span><span class="p">.</span><span class="n">popBack</span><span class="p">();</span>          <span class="c1">// arrの後ろを一つ縮める -&gt; arr = arr[0 .. $-1]に等価</span>
    <span class="n">writeln</span><span class="p">(</span><span class="n">arr</span><span class="p">);</span>           <span class="c1">// [1, 2]</span>
    <span class="n">writeln</span><span class="p">(</span><span class="n">arr</span><span class="p">.</span><span class="n">empty</span><span class="p">);</span>     <span class="c1">// false</span>
    <span class="n">writeln</span><span class="p">(</span><span class="n">arr</span><span class="p">.</span><span class="n">front</span><span class="p">);</span>     <span class="c1">// 1</span>
    <span class="n">writeln</span><span class="p">(</span><span class="n">arr</span><span class="p">.</span><span class="n">back</span><span class="p">);</span>      <span class="c1">// 2</span>

    <span class="n">arr</span><span class="p">.</span><span class="n">popFront</span><span class="p">();</span>
    <span class="n">arr</span><span class="p">.</span><span class="n">popFront</span><span class="p">();</span>
    <span class="n">writeln</span><span class="p">(</span><span class="n">arr</span><span class="p">);</span>           <span class="c1">// []</span>
    <span class="n">writeln</span><span class="p">(</span><span class="n">arr</span><span class="p">.</span><span class="n">empty</span><span class="p">);</span>     <span class="c1">// true     arrは空</span>
<span class="p">}</span>
</code></pre></div>
<p>今回はレンジについては詳しく説明しませんが、スライスはRangeという概念に沿っているので、<code>std.range</code>や<code>std.algorithm</code>などの便利な関数が使えます。
以下は<code>std.algorithm.filter</code>を使ってスライス中の偶数要素のみを抽出し、それらを<code>n</code>倍したレンジを返す関数です。</p>
<div class="highlight"><pre><code class="language-d" data-lang="d"><span class="k">import</span> <span class="n">std</span><span class="p">.</span><span class="n">algorithm</span><span class="p">,</span> <span class="n">std</span><span class="p">.</span><span class="n">range</span><span class="p">;</span>


<span class="k">auto</span> <span class="n">evenPassFilter</span><span class="p">(</span><span class="n">T</span><span class="p">,</span> <span class="n">U</span><span class="p">)(</span><span class="n">T</span><span class="p">[]</span> <span class="n">array</span><span class="p">,</span> <span class="n">U</span> <span class="n">n</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">return</span> <span class="n">array</span><span class="p">.</span><span class="n">filter</span><span class="p">!</span><span class="s">&quot;a%2 == 0&quot;</span><span class="p">()</span>
          <span class="p">.</span><span class="n">zip</span><span class="p">(</span><span class="n">repeat</span><span class="p">(</span><span class="n">n</span><span class="p">))</span>
          <span class="p">.</span><span class="n">map</span><span class="p">!</span><span class="s">&quot;a[0] * a[1]&quot;</span><span class="p">();</span>
<span class="p">}</span>


<span class="kt">void</span> <span class="n">main</span><span class="p">()</span>
<span class="p">{</span>
    <span class="n">writeln</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">].</span><span class="n">evenPassFilter</span><span class="p">(</span><span class="mf">2.5</span><span class="p">));</span>     <span class="c1">// [0, 5]</span>
<span class="p">}</span>
</code></pre></div>
<h2>静的配列やスライスのプロパティとメソッド</h2>

<p>プロパティとは何か、メソッドとは何かというお話はここでは気にせず、Dの配列を高効率とするための機能を紹介します。
ちなみに、<code>array.</code>と付いているものは静的配列とスライスの両方で使え、<code>slice.</code>で始まっているものはスライスでしか使えません。</p>

<ul>
<li><code>T* array.ptr</code></li>
</ul>

<p>配列の先頭要素へのポインタ値を返します。</p>
<div class="highlight"><pre><code class="language-d" data-lang="d"><span class="k">import</span> <span class="n">core</span><span class="p">.</span><span class="n">memory</span><span class="p">;</span>

<span class="kt">int</span><span class="p">*</span> <span class="n">p</span> <span class="p">=</span> <span class="k">cast</span><span class="p">(</span><span class="kt">int</span><span class="p">*)</span><span class="n">GC</span><span class="p">.</span><span class="n">malloc</span><span class="p">(</span><span class="kt">int</span><span class="p">.</span><span class="n">sizeof</span> <span class="p">*</span> <span class="mi">10</span><span class="p">);</span>  <span class="c1">// ヒープからint型10要素分のメモリを確保</span>
<span class="kt">int</span><span class="p">[]</span> <span class="n">slice</span> <span class="p">=</span> <span class="n">p</span><span class="p">[</span><span class="mi">0</span> <span class="p">..</span> <span class="mi">10</span><span class="p">];</span>                       <span class="c1">// ポインタpからスライスを作成</span>

<span class="n">writeln</span><span class="p">(</span><span class="n">slice</span><span class="p">.</span><span class="n">ptr</span> <span class="p">==</span> <span class="n">p</span><span class="p">);</span>                        <span class="c1">// true</span>
                                                <span class="c1">// スライスのポインタは、pと同じなので</span>

<span class="n">slice</span> <span class="p">=</span> <span class="n">slice</span><span class="p">[</span><span class="mi">1</span> <span class="p">..</span> <span class="p">$];</span>
<span class="n">writeln</span><span class="p">(</span><span class="n">slice</span><span class="p">.</span><span class="n">ptr</span> <span class="p">==</span> <span class="n">p</span> <span class="p">+</span> <span class="mi">1</span><span class="p">);</span>                    <span class="c1">// true</span>

<span class="kt">int</span><span class="p">[</span><span class="mi">10</span><span class="p">]</span> <span class="n">stArray</span><span class="p">;</span>
<span class="n">slice</span> <span class="p">=</span> <span class="n">stArray</span><span class="p">[];</span>                              <span class="c1">// 静的配列 -&gt; スライスへの変換</span>
<span class="n">writeln</span><span class="p">(</span><span class="n">stArray</span><span class="p">.</span><span class="n">ptr</span> <span class="p">==</span> <span class="n">slice</span><span class="p">.</span><span class="n">ptr</span><span class="p">);</span>              <span class="c1">// true</span>
                                                <span class="c1">// 静的配列をスライスへ変換することは、</span>
                                                <span class="c1">// そのスタック領域へのスライスであるということの証明</span>
</code></pre></div>
<ul>
<li><code>size_t array.length</code></li>
</ul>

<p>配列が格納している要素数を返します。</p>
<div class="highlight"><pre><code class="language-d" data-lang="d"><span class="kt">int</span><span class="p">[]</span> <span class="n">slice</span> <span class="p">=</span> <span class="k">new</span> <span class="kt">int</span><span class="p">[</span><span class="mi">10</span><span class="p">];</span>
<span class="n">writeln</span><span class="p">(</span><span class="n">slice</span><span class="p">.</span><span class="n">length</span><span class="p">);</span>                  <span class="c1">// 10</span>

<span class="n">slice</span> <span class="p">=</span> <span class="n">slice</span><span class="p">[</span><span class="mi">0</span> <span class="p">..</span> <span class="mi">0</span><span class="p">];</span>
<span class="n">writeln</span><span class="p">(</span><span class="n">slice</span><span class="p">.</span><span class="n">length</span><span class="p">);</span>                  <span class="c1">// 0</span>

<span class="kt">int</span><span class="p">[</span><span class="mi">10</span><span class="p">]</span> <span class="n">stArray</span><span class="p">;</span>
<span class="n">writeln</span><span class="p">(</span><span class="n">stArray</span><span class="p">.</span><span class="n">length</span><span class="p">);</span>                <span class="c1">// 10</span>

<span class="k">pragma</span><span class="p">(</span><span class="n">msg</span><span class="p">,</span> <span class="n">stArray</span><span class="p">.</span><span class="n">length</span><span class="p">);</span>            <span class="c1">// 10u (コンパイル時間に出力)</span>
                                        <span class="c1">// 静的配列であればコンパイル時定数</span>
</code></pre></div>
<ul>
<li><code>T[] array.dup</code></li>
</ul>

<p>新しいヒープ領域を確保し、配列のコピーを作ります。結果はスライスです。</p>
<div class="highlight"><pre><code class="language-d" data-lang="d"><span class="kt">int</span><span class="p">[]</span> <span class="n">slice</span> <span class="p">=</span> <span class="k">new</span> <span class="kt">int</span><span class="p">[</span><span class="mi">10</span><span class="p">],</span>
      <span class="n">slice2</span> <span class="p">=</span> <span class="n">slice</span><span class="p">.</span><span class="n">dup</span><span class="p">;</span>

<span class="n">writeln</span><span class="p">(</span><span class="n">slice</span> <span class="p">==</span> <span class="n">slice2</span><span class="p">);</span>
<span class="n">writeln</span><span class="p">(</span><span class="n">slice</span><span class="p">.</span><span class="n">ptr</span> <span class="p">!=</span> <span class="n">slice2</span><span class="p">.</span><span class="n">ptr</span><span class="p">);</span>

<span class="kt">int</span><span class="p">[</span><span class="mi">10</span><span class="p">]</span> <span class="n">stArray</span><span class="p">;</span>
<span class="k">pragma</span><span class="p">(</span><span class="n">msg</span><span class="p">,</span> <span class="k">typeof</span><span class="p">(</span><span class="n">stArray</span><span class="p">.</span><span class="n">dup</span><span class="p">));</span>   <span class="c1">// int[]  (コンパイル時に出力)</span>
</code></pre></div>
<ul>
<li><code>immutable(T)[] array.idup</code></li>
</ul>

<p>新しいヒープ領域を確保し、配列のコピーを作ります。結果の型は要素が<code>immutable</code>なスライスです。
<code>immutable</code>とは、「生まれたら最後、一生書き換えられない」という意味です。</p>
<div class="highlight"><pre><code class="language-d" data-lang="d"><span class="kt">int</span><span class="p">[]</span> <span class="n">slice</span> <span class="p">=</span> <span class="k">new</span> <span class="kt">int</span><span class="p">[</span><span class="mi">10</span><span class="p">];</span>
<span class="k">immutable</span><span class="p">(</span><span class="kt">int</span><span class="p">)[]</span> <span class="n">slice2</span> <span class="p">=</span> <span class="n">slice</span><span class="p">.</span><span class="n">idup</span><span class="p">;</span>

<span class="n">writeln</span><span class="p">(</span><span class="n">slice</span> <span class="p">==</span> <span class="n">slice2</span><span class="p">);</span>
<span class="n">writeln</span><span class="p">(</span><span class="n">slice</span><span class="p">.</span><span class="n">ptr</span> <span class="p">!=</span> <span class="n">slice2</span><span class="p">.</span><span class="n">ptr</span><span class="p">);</span>

<span class="kt">int</span><span class="p">[</span><span class="mi">10</span><span class="p">]</span> <span class="n">stArray</span><span class="p">;</span>
<span class="k">pragma</span><span class="p">(</span><span class="n">msg</span><span class="p">,</span> <span class="k">typeof</span><span class="p">(</span><span class="n">stArray</span><span class="p">.</span><span class="n">idup</span><span class="p">));</span>   <span class="c1">// immutable(int)[]  (コンパイル時に出力)</span>
</code></pre></div>
<p>ちなみに、dmd 2.063から入った変更によって、<code>dup</code>でも<code>idup</code>の機能は満たせます。</p>
<div class="highlight"><pre><code class="language-d" data-lang="d"><span class="kt">int</span><span class="p">[]</span> <span class="n">slice</span> <span class="p">=</span> <span class="k">new</span> <span class="kt">int</span><span class="p">[</span><span class="mi">10</span><span class="p">];</span>
<span class="k">immutable</span><span class="p">(</span><span class="kt">int</span><span class="p">)[]</span> <span class="n">slice2</span> <span class="p">=</span> <span class="n">slice</span><span class="p">.</span><span class="n">dup</span><span class="p">;</span>    <span class="c1">// OK</span>
</code></pre></div>
<ul>
<li><code>T[] array.sort</code></li>
</ul>

<p>配列の要素をインプレース(その場)で昇順(小さい順)に並び替えます。
静的配列であっても、結果の型はスライスです。</p>
<div class="highlight"><pre><code class="language-d" data-lang="d"><span class="kt">int</span><span class="p">[]</span> <span class="n">arr</span> <span class="p">=</span> <span class="p">[</span><span class="mi">3</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">];</span>

<span class="n">writeln</span><span class="p">(</span><span class="n">arr</span><span class="p">.</span><span class="n">sort</span><span class="p">);</span>       <span class="c1">// [1, 2, 3]</span>
</code></pre></div>
<p><code>sort</code>プロパティは<a href="#%E4%BB%95%E6%A7%98">廃止予定</a>なので、<code>std.algorithm.sort</code>を使うのがよいでしょう。</p>
<div class="highlight"><pre><code class="language-d" data-lang="d"><span class="k">import</span> <span class="n">std</span><span class="p">.</span><span class="n">algorithm</span><span class="p">;</span>

<span class="kt">int</span><span class="p">[]</span> <span class="n">arr</span> <span class="p">=</span> <span class="p">[</span><span class="mi">3</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">];</span>

<span class="n">writeln</span><span class="p">(</span><span class="n">sort</span><span class="p">(</span><span class="n">arr</span><span class="p">));</span>     <span class="c1">// [1, 2, 3]</span>
<span class="n">writeln</span><span class="p">(</span><span class="n">arr</span><span class="p">);</span>           <span class="c1">// [1, 2, 3]</span>

<span class="n">arr</span><span class="p">.</span><span class="n">sort</span><span class="p">!</span><span class="s">&quot;a &gt; b&quot;</span><span class="p">();</span>     <span class="c1">// [3, 2, 1]</span>
                        <span class="c1">// 降順並び替え</span>
<span class="n">writeln</span><span class="p">(</span><span class="n">arr</span><span class="p">);</span>
</code></pre></div>
<ul>
<li><code>T[] array.reverse</code></li>
</ul>

<p>配列の要素をインプレースで反転させます。
静的配列であっても、結果の型はスライスです。</p>
<div class="highlight"><pre><code class="language-d" data-lang="d"><span class="kt">int</span><span class="p">[]</span> <span class="n">arr</span> <span class="p">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">];</span>

<span class="n">writeln</span><span class="p">(</span><span class="n">arr</span><span class="p">.</span><span class="n">reverse</span><span class="p">);</span>       <span class="c1">// [3, 2, 1]</span>
<span class="n">writeln</span><span class="p">(</span><span class="n">arr</span><span class="p">.</span><span class="n">reverse</span><span class="p">);</span>       <span class="c1">// [1, 2, 3]</span>
</code></pre></div>
<p><code>sort</code>プロパティと同様に<code>reverse</code>プロパティも<a href="#%E4%BB%95%E6%A7%98">廃止予定</a>なので、<code>std.algorithm.reverse</code>を使うのがよいでしょう。</p>
<div class="highlight"><pre><code class="language-d" data-lang="d"><span class="k">import</span> <span class="n">std</span><span class="p">.</span><span class="n">algorithm</span><span class="p">;</span>

<span class="kt">int</span><span class="p">[]</span> <span class="n">arr</span> <span class="p">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">];</span>

<span class="n">reverse</span><span class="p">(</span><span class="n">arr</span><span class="p">);</span>               <span class="c1">// こうするか</span>
<span class="n">writeln</span><span class="p">(</span><span class="n">arr</span><span class="p">);</span>

<span class="n">arr</span><span class="p">.</span><span class="n">reverse</span><span class="p">();</span>              <span class="c1">// こうする</span>
<span class="n">writeln</span><span class="p">(</span><span class="n">arr</span><span class="p">);</span>
</code></pre></div>
<ul>
<li><code>slice.capacity</code></li>
</ul>

<p>スライスへの追加を行う際に、再割当てされるかどうかを予測したい場合に活用します。
<code>slice.capacity</code>は、そのスライスが、メモリを再確保しないで、最大で何要素まで要素を持つことができるか返します。</p>
<div class="highlight"><pre><code class="language-d" data-lang="d"><span class="kt">int</span><span class="p">[]</span> <span class="n">arr</span><span class="p">;</span>
<span class="n">writeln</span><span class="p">(</span><span class="n">arr</span><span class="p">.</span><span class="n">capacity</span><span class="p">);</span>      <span class="c1">// 0</span>

<span class="n">arr</span> <span class="p">=</span> <span class="k">new</span> <span class="kt">int</span><span class="p">[</span><span class="mi">10</span><span class="p">];</span>
<span class="kt">int</span><span class="p">*</span> <span class="n">before</span> <span class="p">=</span> <span class="n">arr</span><span class="p">.</span><span class="n">ptr</span><span class="p">;</span>

<span class="k">foreach</span><span class="p">(</span><span class="n">i</span><span class="p">;</span> <span class="mi">0</span> <span class="p">..</span> <span class="n">arr</span><span class="p">.</span><span class="n">capacity</span> <span class="p">-</span> <span class="n">arr</span><span class="p">.</span><span class="n">length</span><span class="p">)</span>
    <span class="n">arr</span> <span class="p">~=</span> <span class="n">i</span><span class="p">;</span>               <span class="c1">// メモリの再確保は起こらない</span>

<span class="k">assert</span><span class="p">(</span><span class="n">before</span> <span class="p">==</span> <span class="n">arr</span><span class="p">.</span><span class="n">ptr</span><span class="p">);</span>  <span class="c1">// 追加前と追加後ではポインタは変わっていない</span>
                            <span class="c1">// つまり、最確保されていない</span>
</code></pre></div>
<ul>
<li><code>size_t slice.reserve(size_t n)</code></li>
</ul>

<p>そのスライスが、メモリを再確保しないで、最低<code>n</code>の長さまで拡大、追加できるように、必要であれば再確保します。
返り値は、変更後の<code>slice.capacity</code>です。</p>
<div class="highlight"><pre><code class="language-d" data-lang="d"><span class="kt">int</span><span class="p">[]</span> <span class="n">arr</span> <span class="p">=</span> <span class="k">new</span> <span class="kt">int</span><span class="p">[</span><span class="mi">5</span><span class="p">];</span>
<span class="nb">size_t</span> <span class="n">cap</span> <span class="p">=</span> <span class="n">arr</span><span class="p">.</span><span class="n">reserve</span><span class="p">(</span><span class="n">arr</span><span class="p">.</span><span class="n">length</span> <span class="p">+</span> <span class="mi">5</span><span class="p">);</span>   <span class="c1">// あと最低でも5要素は追加可能にしておく</span>
<span class="k">assert</span><span class="p">(</span><span class="n">cap</span> <span class="p">-</span> <span class="n">arr</span><span class="p">.</span><span class="n">length</span> <span class="p">&gt;=</span> <span class="mi">5</span><span class="p">);</span>              <span class="c1">//追加可能な要素は5以上</span>
</code></pre></div>
<ul>
<li><code>void slice.assumeSafeAppend()</code></li>
</ul>

<p>そのスライスが参照しているメモリの末端までそのスライスが拡張可能であるとランタイムに強制します。
気をつけて行わないと、想定外の動作を起こす可能性があります。</p>
<div class="highlight"><pre><code class="language-d" data-lang="d"><span class="kt">int</span><span class="p">[]</span> <span class="n">arr</span> <span class="p">=</span> <span class="k">new</span> <span class="kt">int</span><span class="p">[</span><span class="mi">10</span><span class="p">],</span>
      <span class="n">arr2</span> <span class="p">=</span> <span class="n">arr</span><span class="p">;</span>
<span class="n">arr</span><span class="p">[]</span> <span class="p">=</span> <span class="mi">1</span><span class="p">;</span>
<span class="n">writeln</span><span class="p">(</span><span class="n">arr2</span><span class="p">);</span>                  <span class="c1">// [1, 1, 1, 1, 1, 1, 1, 1, 1, 1]</span>

<span class="nb">size_t</span> <span class="n">cap</span> <span class="p">=</span> <span class="n">arr</span><span class="p">.</span><span class="n">capacity</span><span class="p">;</span>

<span class="n">arr</span> <span class="p">=</span> <span class="n">arr</span><span class="p">[</span><span class="mi">0</span> <span class="p">..</span> <span class="mi">5</span><span class="p">];</span>
<span class="k">assert</span><span class="p">(</span><span class="n">arr</span><span class="p">.</span><span class="n">capacity</span> <span class="p">==</span> <span class="mi">0</span><span class="p">);</span>      <span class="c1">// arrを拡大することは、arr2を破壊することにつながる</span>
                                <span class="c1">// よって、capacityは0</span>

<span class="n">arr</span><span class="p">.</span><span class="n">assumeSafeAppend</span><span class="p">();</span>
<span class="k">assert</span><span class="p">(</span><span class="n">arr</span><span class="p">.</span><span class="n">capacity</span> <span class="p">==</span> <span class="n">cap</span><span class="p">);</span>    <span class="c1">// 縮小前のcapacityと同じ</span>

<span class="n">arr</span><span class="p">.</span><span class="n">length</span> <span class="p">=</span> <span class="mi">6</span><span class="p">;</span>
<span class="n">writeln</span><span class="p">(</span><span class="n">arr</span><span class="p">);</span>                   <span class="c1">// [1, 1, 1, 1, 1, 0]</span>
                                <span class="c1">// 新しい領域はT.initで初期化</span>
<span class="n">writeln</span><span class="p">(</span><span class="n">arr2</span><span class="p">);</span>                  <span class="c1">// [1, 1, 1, 1, 1, 0, 1, 1, 1, 1]</span>
                                <span class="c1">// arrやarr2に代入していないのに、arr2[5]が0に書き換わっている</span>
                                <span class="c1">// プログラマが意図していないメモリの書き換えになっている</span>
                                <span class="c1">// つまり、assumeSafeAppendはちゃんと管理しなければ安全でない</span>
</code></pre></div>
<h2>多次元配列(配列の配列)</h2>

<p>配列の配列を作成することも可能です。たとえば、<code>int[3][]</code>は、<code>int[3]</code>という静的配列のスライスです。<code>int[][][]</code>であれば、intのスライスのスライスのスライスです。</p>
<div class="highlight"><pre><code class="language-d" data-lang="d"><span class="kt">int</span><span class="p">[</span><span class="mi">3</span><span class="p">][]</span> <span class="n">arr2d</span> <span class="p">=</span> <span class="k">new</span> <span class="kt">int</span><span class="p">[</span><span class="mi">3</span><span class="p">][](</span><span class="mi">10</span><span class="p">);</span>
<span class="n">writeln</span><span class="p">(</span><span class="n">arr2d</span><span class="p">.</span><span class="n">length</span><span class="p">);</span>          <span class="c1">// 10</span>
<span class="n">writeln</span><span class="p">(</span><span class="n">arr2d</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">length</span><span class="p">);</span>       <span class="c1">// 3</span>

<span class="n">arr2d</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="p">=</span> <span class="mi">1</span><span class="p">;</span>
<span class="n">writeln</span><span class="p">(</span><span class="n">arr2d</span><span class="p">[</span><span class="mi">0</span><span class="p">]);</span>              <span class="c1">// [1, 0, 0]</span>

<span class="kt">int</span><span class="p">[][][]</span> <span class="n">arr3d</span> <span class="p">=</span> <span class="k">new</span> <span class="kt">int</span><span class="p">[][][](</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">);</span>

<span class="n">writeln</span><span class="p">(</span><span class="n">arr3d</span><span class="p">.</span><span class="n">length</span><span class="p">);</span>          <span class="c1">// 1</span>
<span class="n">writeln</span><span class="p">(</span><span class="n">arr3d</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">length</span><span class="p">);</span>       <span class="c1">// 2</span>
<span class="n">writeln</span><span class="p">(</span><span class="n">arr3d</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">].</span><span class="n">length</span><span class="p">);</span>    <span class="c1">// 3</span>
</code></pre></div>
<h2>配列操作のまとめ</h2>

<p>よく使用する配列操作を纏めておきます。
実際には、配列とレンジの両方を活用することで効率的なプログラムが書けます。</p>
<div class="highlight"><pre><code class="language-d" data-lang="d"><span class="k">import</span> <span class="n">std</span><span class="p">.</span><span class="n">algorithm</span><span class="p">;</span>
<span class="k">import</span> <span class="n">std</span><span class="p">.</span><span class="n">array</span><span class="p">;</span>

<span class="kt">void</span> <span class="n">main</span><span class="p">()</span>
<span class="p">{</span>
    <span class="p">{</span>
        <span class="kt">int</span><span class="p">[]</span> <span class="n">arr</span> <span class="p">=</span> <span class="k">new</span> <span class="kt">int</span><span class="p">[</span><span class="mi">1024</span><span class="p">];</span>      <span class="c1">// 宣言と初期化と確保</span>
    <span class="p">}</span>
    <span class="p">{</span>
        <span class="kt">int</span><span class="p">[]</span> <span class="n">arr</span><span class="p">;</span>                      <span class="c1">// 宣言とデフォルト初期化</span>
        <span class="n">arr</span><span class="p">.</span><span class="n">length</span> <span class="p">=</span> <span class="mi">1024</span><span class="p">;</span>              <span class="c1">// 拡張</span>
    <span class="p">}</span>

    <span class="kt">int</span><span class="p">[]</span> <span class="n">arr</span><span class="p">;</span>
    <span class="n">arr</span> <span class="p">=</span> <span class="k">new</span> <span class="kt">int</span><span class="p">[</span><span class="mi">1024</span><span class="p">];</span>

    <span class="nb">size_t</span> <span class="n">n</span> <span class="p">=</span> <span class="n">arr</span><span class="p">.</span><span class="n">length</span><span class="p">;</span>              <span class="c1">// 配列の大きさの取得</span>

    <span class="n">n</span> <span class="p">=</span> <span class="mi">5</span><span class="p">;</span>

    <span class="k">auto</span> <span class="n">e</span> <span class="p">=</span> <span class="n">arr</span><span class="p">[</span><span class="n">n</span><span class="p">];</span>                    <span class="c1">// インデックスによるアクセス</span>
    <span class="n">arr</span><span class="p">[</span><span class="n">n</span><span class="p">]</span> <span class="p">=</span> <span class="n">e</span> <span class="p">+</span> <span class="mi">5</span><span class="p">;</span>

    <span class="kt">int</span><span class="p">*</span> <span class="n">p</span> <span class="p">=</span> <span class="p">&amp;</span><span class="n">arr</span><span class="p">[</span><span class="n">n</span><span class="p">];</span>                   <span class="c1">// n番目の要素へのポインタ</span>
    <span class="n">p</span> <span class="p">=</span> <span class="n">arr</span><span class="p">.</span><span class="n">ptr</span><span class="p">;</span>                        <span class="c1">// 先頭要素へのポインタ</span>

    <span class="k">auto</span> <span class="n">arr2</span> <span class="p">=</span> <span class="n">arr</span><span class="p">[</span><span class="n">n</span> <span class="p">..</span> <span class="n">n</span> <span class="p">+</span> <span class="mi">8</span><span class="p">];</span>        <span class="c1">// 配列のn要素目から8個だけの配列を取得</span>

    <span class="n">arr</span> <span class="p">~=</span> <span class="n">e</span><span class="p">;</span>                           <span class="c1">// 末尾に単一要素を追加</span>
    <span class="n">arr</span> <span class="p">~=</span> <span class="n">arr2</span><span class="p">;</span>                        <span class="c1">// 末尾に他の配列を追加</span>

    <span class="n">arr</span><span class="p">.</span><span class="n">popBack</span><span class="p">();</span>                      <span class="c1">// 末尾の単一要素削除</span>
    <span class="n">arr</span> <span class="p">=</span> <span class="n">arr</span><span class="p">[</span><span class="mi">0</span> <span class="p">..</span> <span class="p">$</span> <span class="p">-</span> <span class="n">n</span><span class="p">];</span>              <span class="c1">// 末尾のn個の要素削除</span>

    <span class="n">arr</span><span class="p">.</span><span class="n">insertInPlace</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">e</span><span class="p">);</span>            <span class="c1">// 先頭に単一要素の追加</span>
    <span class="n">arr</span> <span class="p">=</span> <span class="p">[</span><span class="n">e</span><span class="p">]</span> <span class="p">~</span> <span class="n">arr</span><span class="p">;</span>                    <span class="c1">// 同上</span>
    <span class="n">arr</span><span class="p">.</span><span class="n">insertInPlace</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">arr2</span><span class="p">);</span>         <span class="c1">// 先頭に他の配列を追加</span>
    <span class="n">arr</span> <span class="p">=</span> <span class="n">arr2</span> <span class="p">~</span> <span class="n">arr</span><span class="p">;</span>                   <span class="c1">// 同上</span>

    <span class="n">arr</span><span class="p">.</span><span class="n">popFront</span><span class="p">();</span>                     <span class="c1">// 先頭の単一要素削除</span>
    <span class="n">arr</span> <span class="p">=</span> <span class="n">arr</span><span class="p">[</span><span class="n">n</span> <span class="p">..</span> <span class="p">$];</span>                  <span class="c1">// 先頭のn個の要素削除</span>

    <span class="n">arr</span><span class="p">.</span><span class="n">insertInPlace</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">e</span><span class="p">);</span>            <span class="c1">// n番目に単一要素を追加</span>
    <span class="n">arr</span><span class="p">.</span><span class="n">insertInPlace</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">arr2</span><span class="p">);</span>         <span class="c1">// n番目に配列を追加</span>

    <span class="n">arr</span> <span class="p">=</span> <span class="n">arr</span><span class="p">.</span><span class="n">remove</span><span class="p">(</span><span class="n">n</span><span class="p">);</span>                <span class="c1">// n番目の単一要素を削除</span>

    <span class="k">import</span> <span class="n">std</span><span class="p">.</span><span class="n">typecons</span><span class="p">;</span>
    <span class="n">arr</span> <span class="p">=</span> <span class="n">arr</span><span class="p">.</span><span class="n">remove</span><span class="p">(</span><span class="n">tuple</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">n</span> <span class="p">+</span> <span class="mi">5</span><span class="p">));</span>  <span class="c1">// n～n+4番目までの要素を削除</span>

    <span class="n">arr</span><span class="p">.</span><span class="n">sort</span><span class="p">();</span>                         <span class="c1">// 昇順ソート(std.algorithm.sort)</span>
    <span class="n">arr</span><span class="p">.</span><span class="n">sort</span><span class="p">!</span><span class="s">&quot;a &gt; b&quot;</span><span class="p">();</span>                 <span class="c1">// 降順ソート(std.algorithm.sort)</span>

    <span class="n">arr</span><span class="p">.</span><span class="n">sort</span><span class="p">;</span>                           <span class="c1">// 昇順ソート(プロパティ)</span>

    <span class="n">arr</span><span class="p">.</span><span class="n">reverse</span><span class="p">();</span>                      <span class="c1">// 配列の反転(std.algorithm.reverse)</span>
    <span class="n">arr</span><span class="p">.</span><span class="n">reverse</span><span class="p">;</span>                        <span class="c1">// 配列の反転(プロパティ)</span>
<span class="p">}</span>
</code></pre></div>
<h2>問題 -&gt; <a href="answer.md#array">解答</a></h2>

<ul>
<li>問1<br>
<code>int</code>型の配列<code>arr</code>を適当に6要素初期化し、その内容を1要素ずつ改行して表示するプログラムを作ってください。<br>
たとえば、<code>[0, 2, 4, 1, 3, 5]</code>と初期化されているなら以下のように表示すること。</li>
</ul>
<div class="highlight"><pre><code class="language-text" data-lang="text">0
2
4
1
3
5
</code></pre></div>
<ul>
<li><p>問2<br>
問2のプログラムとは逆順で表示させるようにしてください。<code>foreach</code>文を使ったなら<code>for</code>文でやってみましょう。</p></li>
<li><p>問3<br>
<code>writefln</code>や<code>writef</code>のフォーマット指定は、詳細に指定可能です。たとえば、問2のプログラムであれば以下のように書けます。</p></li>
</ul>
<div class="highlight"><pre><code class="language-d" data-lang="d"><span class="k">import</span> <span class="n">std</span><span class="p">.</span><span class="n">stdio</span><span class="p">;</span>

<span class="kt">void</span> <span class="n">main</span><span class="p">()</span>
<span class="p">{</span>
    <span class="kt">int</span><span class="p">[]</span> <span class="n">arr</span> <span class="p">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">5</span><span class="p">];</span>

    <span class="n">writefln</span><span class="p">(</span><span class="s">&quot;%(%s\n%)&quot;</span><span class="p">,</span> <span class="n">arr</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div>
<p><code>%(</code>から<code>%)</code>までをサブフォーマット(Sub-format)といい、配列の1要素のフォーマット指定になります。
ただし、最終要素のみは<code>%s</code>などの書式指定子もしくは<code>%|</code>のデリミタ(区切り文字, Delimiter)の出現位置までしか表示しません。
デリミタの方が優先度が高く、たとえ前方に<code>%s</code>などの書式指定子あっても<code>%|</code>までを区切りとします。
また、<code>%|</code>以降に<code>%s</code>などの書式指定子やデリミタ<code>%|</code>を置くことはできません。
(<code>%(%|%d%)</code>や<code>%(%s%|%|%)</code>は不正なフォーマット)</p>

<p>では、各要素を<code>[001]</code>のように<code>[]</code>でくくって3桁ずつ表示するにはどうすればいいでしょうか？
ヒントとして、<code>%(-%s-%|\n%)</code>というようにデリミタ<code>%|</code>を使うことで、以下の様な出力が得られます。</p>
<div class="highlight"><pre><code class="language-text" data-lang="text">-0-
-2-
-4-
-1-
-3-
-5-
</code></pre></div>
<ul>
<li><p>問4<br>
<code>new int[10];</code>とすることで、10要素の配列を確保し、各要素にインデックス値<code>idx</code>の10倍の値<code>idx * 10</code>を格納し、表示するプログラムを書いてください。
出力のフォーマットはどのような形式でも構いません。</p></li>
<li><p>問題募集中</p></li>
</ul>

<h2>終わりに</h2>

<p>配列の中でもスライスは、D言語の特徴的な機能の一つです。
スライスを使えば、本当に思った通りにプログラムが動くので、バグを起こしにくくなります。
C++での<code>vector</code>と比較すれば、使い勝手ではDのスライスが圧勝するでしょうね。
(というより、機能や概念が違うから比較すべきではないかも)
私はC言語にも、ガベージコレクタはなくても、スライスだけでも導入して欲しいと思ってます。
もちろん、ガベージコレクタがなくなっているので結合や追加はできませんが、Cでも十分綺麗なコードが書けるはずです。</p>

<p>次は文字の配列である「文字列」について解説します。
D言語の文字列は、他言語とくらべて圧倒的に操作しやすくなっています。</p>

<h2>キーワード</h2>

<ul>
<li>配列(Array)</li>
<li>リスト(List)</li>
<li>要素(Element)</li>
<li>長さ(<code>arr.length</code>, <code>&amp;</code>)</li>
<li>添字(Index)</li>
<li>スタック(Stack)</li>
<li>ヒープ(Heap)</li>
<li>静的配列(<code>T[N]</code>)</li>
<li>スライス(<code>T[]</code>, 動的配列, Slice, Dynamic Array)</li>
<li>ポインタ(<code>T*</code>, Pointer)</li>
<li><code>new</code></li>
<li>結合(<code>~=</code>, <code>~</code>)</li>
<li>ガベージコレクタ(Garbage Collector, GC)</li>
<li>スライス演算子(<code>arr[]</code>, <code>arr[]</code>)</li>
<li><code>foreach</code>文</li>
<li>Range</li>
<li>多重配列</li>
</ul>

<h2>仕様</h2>

<ul>
<li>静的配列              <a href="http://www.kmonos.net/alang/d/arrays.html#static-arrays">日本語</a> <a href="http://dlang.org/arrays.html#static-arrays">英語</a></li>
<li>動的配列(スライスのこと)     <a href="http://www.kmonos.net/alang/d/arrays.html#dynamic-arrays">日本語</a> <a href="http://dlang.org/arrays.html#dynamic-arrays">英語</a></li>
<li><code>foreach</code>文            <a href="http://www.kmonos.net/alang/d/statement.html#ForeachStatement">日本語</a> <a href="http://dlang.org/statement.html#ForeachStatement">英語</a></li>
<li><code>sort</code> と <code>reverse</code> の廃止について <a href="http://dlang.org/deprecate.html#.sort%20and%20.reverse%20properties%20for%20arrays">英語</a></li>
</ul>

              </div>
            </div>
          </div>
          <div class="row">
  <div class="col-md-12 col-sm-12 col-xs-12">
    <div class="page-footer">
      <div class="list-group">
        <a href="/archives/#y-2013" class="list-group-item col-md-3 col-sm-4 col-xs-6">
          <i class="fa fa fa-archive fa-lg"></i> 
          <em itemprop="datePublished" content="2013-06-23">
            23 Jun 2013
          </em>
        </a>
        
        <a href="/categories/#dmanual" class="list-group-item col-md-3 col-sm-4 col-xs-6">
          <i class="fa fa-folder-open fa-lg"></i> <em itemprop="keywords">Dmanual</em>
          <span class="badge">0</span>
        </a>
        
        
        <a href="/tags/#dmanual" class="list-group-item col-md-3 col-sm-4 col-xs-6">
          <i class="fa fa-tag fa-lg"></i> <em itemprop="keywords">dmanual</em>
          <span class="badge">4</span>
        </a>
        
    </div>
    <div id="disqus_thread"></div>
    <script type="text/javascript">
        /* * * CONFIGURATION VARIABLES: EDIT BEFORE PASTING INTO YOUR WEBPAGE * * */
        var disqus_shortname = 'dmanual'; // required: replace example with your forum shortname

        /* * * DON'T EDIT BELOW THIS LINE * * */
        (function() {
            var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
            dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
            (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
        })();
    </script>
    <noscript>Please enable JavaScript to view the <a href="http://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
    <a href="http://disqus.com" class="dsq-brlink">comments powered by <span class="logo-disqus">Disqus</span></a>
  </div>
</div>
        </article>
      </div>
    </div>
    
<div class="footer">
  <div class="container">
    <hr/>
    <div class="row">
      <div class="col-md-12 col-sm-12 col-xs-12">
        <ul class="nav nav-pills">
          
          <li>
            <a href="https://www.github.com/k3kaimu">
              <i class="fa fa-github-square fa-lg"></i> GitHub
            </a>
          </li>
          
          
          <li>
            <a href="http://www.twitter.com/k3_kaimu">
              <i class="fa fa-twitter-square fa-lg"></i> Twitter
            </a>
          </li>
          
          
          
          <li>
            <a href="/atom.xml">
              <i class="fa fa-rss-square fa-lg"></i> Rss
            </a>
          </li>
          <li class="pull-right visible-md visible-lg">
            <a href="#top">
              <i class="fa fa-arrow-circle-up fa-lg"></i> Back to top
            </a>
          </li>
        </ul>
      </div>
    </div>
    <div class="row">
      <div class="col-md-12 col-sm-12 col-xs-12">        
        <p>
          &copy; k3-kaimu 2014 
          with help from <a href="https://github.com/ogaclejapan/jekyllstrap" target="_blank" title="jekyllstrap is Jekyll template based on Bootstrap.">Jekyllstrap</a>.
        </p>
        <p>
          Based on <a href="http://jekyllrb.com/" target="_blank">Jekyll</a>. 
          Themes from <a href="http://getbootstrap.com/" target="_blank">Bootstrap</a> and <a href="http://bootswatch.com/" target="_blank">Bootswatch</a>. 
          Icons from <a href="http://fontawesome.io/" target="_blank">Font Awesome</a>.
        </p>
        <p>
        <a href="https://github.com/k3kaimu/k3kaimu.github.io/commits/src/dmanual/array.md">View this page's history on GitHub</a>
        </p>
      </div>
    </div>
    <div class="row">
    <form action="http://www.google.com/cse" id="cse-search-box">
<input type="hidden" name="cx" value="004390249242222246033:d_53xmyptd0" />
<input type="hidden" name="ie" value="UTF-8" />
<input type="text" name="q" size="31" />
<input type="submit" name="sa" value="&#xf00e;" />
</form>
<script type="text/javascript" src="//www.google.com/cse/brand?form=cse-search-box&lang=ja"></script>

    </div>
  </div>
</div>


    
<div id="back-to-top">
  <a href="#top"><i class="fa fa-arrow-circle-up fa-5x"></i></a>
</div>

    
<script src="//code.jquery.com/jquery-2.0.3.min.js"></script>
<script src="//netdna.bootstrapcdn.com/bootstrap/3.0.3/js/bootstrap.min.js"></script>
<script src="/assets/js/all.min.js"></script>



    


  </body>
</html>
