<!DOCTYPE html>
<html lang="ja" xmlns="http://www.w3.org/1999/xhtml" prefix="og: http://ogp.me/ns#">
  <head>
    
<meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<meta name="format-detection" content="telephone=no">
<link rel="alternate" type="application/rss+xml" title="RSS Feed" href="http://k3kaimu.github.io/atom.xml">
<link rel="shortcut icon" href="/favicon.ico">

    <title> 11 関数 | Go to the future</title>
    
<meta property="og:type" content="blog">
<meta property="og:title" content="11 関数">
<meta property="og:description" content="{{ **注意** このページを含むd-manualの全記事は[専用ページ](https://k3kaimu.github.io/dmanual/)へ移行しました。今後は専用ページでご覧ください。}}

{% tree %}

## 関数とは？

関数(function)は、

1. データを...">
<meta property="og:url" content="http://k3kaimu.github.io/dmanual/function/">

<meta property="og:site_name" content="Go to the future">
<meta property="og:locale" content="ja_JP">
<meta name="twitter:card" content="summary">

<meta name="twitter:site" content="@k3_kaimu">


    
<link rel="stylesheet" href="//netdna.bootstrapcdn.com/bootswatch/3.0.2/cerulean/bootstrap.min.css">
<link rel="stylesheet" href="//netdna.bootstrapcdn.com/font-awesome/4.0.3/css/font-awesome.min.css">
<link rel="stylesheet" href="/assets/css/all.min.css">
<link rel="stylesheet" href="/assets/css/navigation.css">

    
<!--[if lt IE 9]>
  <script src="https://oss.maxcdn.com/libs/html5shiv/3.7.0/html5shiv.js"></script>
  <script src="https://oss.maxcdn.com/libs/respond.js/1.3.0/respond.min.js"></script>
<![endif]-->

  </head>
  <body>
    
<div class="navbar navbar-default navbar-fixed-top" role="navigation">
  <div class="container">
    <div class="navbar-header">
      <a href="/" class="navbar-brand">Go to the future</a>
      <button class="navbar-toggle" type="button" data-toggle="collapse" data-target="#navbar-main">
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
      </button>
    </div>
    <div class="navbar-collapse collapse" id="navbar-main">
      <ul class="nav navbar-nav js_nav">
        <li><a href="/blog/">Blog</a></li>
        <li><a href="/dmanual/">DManual</a></li>
        <li><a href="/dtips/">DTips</a></li>
        <!--<li><a href="/archives/">Index...</a></li>
        -->
        <li class="dropdown">
          <a href="#" class="dropdown-toggle" data-toggle="dropdown">Index...<b class="caret"></b></a>
          <ul class="dropdown-menu">
            <li>
              <a href="/archives/" itemprop="sameAs" content="/archives/">
                <i class="fa fa-archive fa-lg"></i> Archives
              </a>
            </li>
            <li>
              <a href="/categories/" itemprop="sameAs" content="/categories/">
                <i class="fa fa-folder-open fa-lg"></i> Categories
              </a>
            </li>
            <li>
              <a href="/tags/" itemprop="sameAs" content="/tags/">
                <i class="fa fa-tags fa-lg"></i> Tags
              </a>
            </li>
          </ul>
        </li>
      </ul>
      <div id="owner" itemprop="author copyrightHolder editor" itemscope itemtype="http://schema.org/Person">
        <ul class="nav navbar-nav navbar-right">
          <li class="dropdown">
            <a href="#" class="dropdown-toggle" data-toggle="dropdown">k3-kaimu <b class="caret"></b></a>
            <ul class="dropdown-menu">
              
              <li>
                
                <a href="https://www.github.com/k3kaimu" itemprop="sameAs" content="https://www.github.com/k3kaimu">
                  <i class="fa fa-github-square fa-lg"></i> GitHub
                </a>
              </li>
              
              
              <li>
                
                <a href="http://www.twitter.com/k3_kaimu" itemprop="sameAs" content="http://www.twitter.com/k3_kaimu">
                  <i class="fa fa-twitter-square fa-lg"></i> Twitter
                </a>
              </li>
              
              
              
              <li>
                <a href="/atom.xml">
                  <i class="fa fa-rss-square fa-lg fa-lg"></i> Rss
                </a>
              </li>
            </ul>
          </li>
        </ul>
      </div>
    </div>
  </div>
</div>

    <div id="content">
      <div class="container">
        <article itemscope itemtype="http://schema.org/Article" itemref="owner">
          
<div class="row">
  <div class="col-md-12 col-sm-12 col-xs-12">
    <div class="page-header">
      <h1 itemprop="url" content="http://k3kaimu.github.io/dmanual/function/">
        <i class="fa fa-puzzle-piece fa-lg"></i> <span itemprop="name">11 関数</span>
      </h1>
    </div>
  </div>
</div>

          <div class="row">
            <div class="col-md-12 col-sm-12 col-xs-12">
              <div itmprop="articleBody">
                <p><h2 class="content_tree">Contents</h2><div class="content_tree_list"><ul><li>関数とは？</li><ul><li>関数による処理のまとめ</li></ul><li>関数の基礎</li><ul><li>宣言の書き方と関数本体</li><li>関数の引数</li></ul><li>デフォルト引数</li><li>引数の記憶域クラス</li><li>可変個引数関数</li><li>オブジェクトを形成する引数</li><li>返値型推論</li><li>関数の属性</li><ul><li>プロパティ関数<code>@property</code></li><li>関数のメモリ安全性</li><li>純粋関数<code>pure</code></li><li>例外を投げない関数<code>nothrow</code></li><li>UDA(User Defined Attribute)</li><li><code>const</code>, <code>immutable</code>, <code>inout</code>, <code>abstract</code>, <code>final</code></li><li>ガベージコレクタが動かない関数<code>@nogc</code></li></ul><li>関数オーバーロード(多重定義, overload)</li><li>ローカル<code>static</code>変数</li><li>ネスト関数</li><li>関数ポインタ</li><li>デリゲート<code>delegate</code></li><li>関数のリテラルとラムダ</li><li>UFCS(Uniform Function Call Syntax)</li><li>CTFE(Compile Time Function Execution)</li><li>問題</li><li>終わりに</li><li>キーワード</li><li>仕様</li></ul></ul></div></p>

<h2>関数とは？</h2>

<p><b>関数</b>(function)は、</p>

<ol>
<li>データを受け取って、</li>
<li>データの加工や、何か処理を行い、</li>
<li>結果を返す</li>
</ol>

<p>ものです。</p>

<p>関数が受け取るデータのことを、<b>引数</b>(argument)といい、
関数が返す結果を<b>返り値</b>または<b>戻り値</b>(return value)といいます。</p>

<p>数学での関数<code>f(x, y, z, ...)</code>は、引数が同じであれば、常に同じ結果を返します。
しかし、プログラムの関数はそうではありません。</p>

<p>プログラムの関数では、同じ引数が与えられたとしても、外界の状態によっては計算結果が変わるからです。
たとえば、「コンソールで入力された数を<code>int</code>型で返す」関数<code>readInt</code>があったとします。
その関数は「何も受け取らず、ただ<code>int</code>型を返すような関数」だと定義できます。
この関数の返す値は人間がコンソールに入れる値に左右されます。</p>

<h3>関数による処理のまとめ</h3>

<p>頻繁に使う処理をまとめて関数にしておくことによってソースコードの可読性やメンテナンス性が向上します。
たとえば、もし、配列の総和を返す関数<code>sum</code>が定義されているなら、総和を計算する箇所では<code>foreach</code>文の代わりに<code>sum</code>関数を使って書くことができます。</p>
<div class="highlight"><pre><code class="language-d" data-lang="d"><span class="c1">// before: sumを使わない</span>
<span class="p">{</span>
    <span class="kt">int</span> <span class="n">s</span><span class="p">;</span>              <span class="c1">// 合計</span>

    <span class="k">foreach</span><span class="p">(</span><span class="n">e</span><span class="p">;</span> <span class="n">arr1</span><span class="p">)</span>
        <span class="n">s</span> <span class="p">+=</span> <span class="n">e</span><span class="p">;</span>


    <span class="kt">int</span> <span class="n">av</span><span class="p">;</span>             <span class="c1">// 平均</span>

    <span class="k">foreach</span><span class="p">(</span><span class="n">e</span><span class="p">;</span> <span class="n">arr2</span><span class="p">)</span>
        <span class="n">av</span> <span class="p">+=</span> <span class="n">e</span><span class="p">;</span>

    <span class="n">av</span> <span class="p">/=</span> <span class="n">arr2</span><span class="p">.</span><span class="n">length</span><span class="p">;</span>
<span class="p">}</span>


<span class="c1">// after: sumを使う</span>
<span class="p">{</span>
    <span class="kt">int</span> <span class="n">s</span> <span class="p">=</span> <span class="n">sum</span><span class="p">(</span><span class="n">arr1</span><span class="p">),</span>
        <span class="n">av</span> <span class="p">=</span> <span class="n">sum</span><span class="p">(</span><span class="n">arr2</span><span class="p">)</span> <span class="p">/</span> <span class="n">arr2</span><span class="p">.</span><span class="n">length</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div>
<p>もし、プログラミング言語に関数という機能がないとしたら、プログラミングという作業は非常につらい作業になったことでしょう。
もしくは、ユーザーは関数を定義できない言語だとしたら、あなたはプログラムを書くことを辞めたくなるはずです。
それほど、関数が行う処理の「隠蔽」と「まとめ」は重要なのです。</p>

<h2>関数の基礎</h2>

<h3>宣言の書き方と関数本体</h3>

<p>D言語では、引数リスト<code>ParameterList</code>を受け取り、<code>ReturnType</code>を返す関数を以下のように書きます。
この基本の構文は、C言語やC++などの言語と同じ構文です。</p>
<div class="highlight"><pre><code class="language-d" data-lang="d"><span class="n">ReturnType</span> <span class="n">functionName</span><span class="p">(</span><span class="n">ParameterList</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">FunctionBody</span>
<span class="p">}</span>
</code></pre></div>
<p><b>関数本体</b>(<code>FunctionBody</code>)は省略して、<b>関数プロトタイプ</b>のみにすることができます。
その場合には、<code>{FunctionBody}</code>の代わりに<code>;</code>を付けておきます。</p>
<div class="highlight"><pre><code class="language-d" data-lang="d"><span class="n">ReturnType</span> <span class="n">functionName</span><span class="p">(</span><span class="n">ParameterList</span><span class="p">);</span>
</code></pre></div>
<p>たとえば、<code>int</code>型の値を2つ受け取って、それらの和を返す関数<code>addInt</code>は、次のように書きます。</p>
<div class="highlight"><pre><code class="language-d" data-lang="d"><span class="kt">int</span> <span class="n">addInt</span><span class="p">(</span><span class="kt">int</span> <span class="n">a</span><span class="p">,</span> <span class="kt">int</span> <span class="n">b</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">return</span> <span class="n">a</span> <span class="p">+</span> <span class="n">b</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div>
<p><code>return</code>文は<code>return &lt;expr&gt;;</code>という形式をとり、機能は「<code>&lt;expr&gt;</code>を返し、処理を呼び出し元に復帰する文」です。
簡単にいえば、呼び出し元に結果を返してから、その関数を即座に終了させる効果があります。
返り値がある関数では、必ず<code>return</code>で値を返して関数を終了させます。</p>

<p>もちろん<code>return</code>文は、次のように関数の任意の場所に書くことができます。</p>
<div class="highlight"><pre><code class="language-d" data-lang="d"><span class="kt">int</span> <span class="n">foo</span><span class="p">(</span><span class="kt">int</span> <span class="n">a</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">if</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
        <span class="k">while</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
            <span class="k">do</span>
                <span class="k">return</span> <span class="n">a</span><span class="p">;</span>
            <span class="k">while</span><span class="p">(</span><span class="n">a</span><span class="p">);</span>

    <span class="k">return</span> <span class="n">a</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div>
<p><a href="#Q1">Goto: 問題1 「readIntを実装しよう」</a><br>
<a href="#Q2">Goto: 問題2 「sumを実装しよう」</a>  </p>

<p>関数のすべての条件分岐や最後に<code>return</code>が無ければ、コンパイルエラーとなります。
ということは、関数内の絶対に到達し得ない場所にも<code>return</code>が必要である、ということになります。
なぜなら、コンパイラでは「絶対に到達し得ない場所」という判断が行えず、また絶対に<code>return</code>しなければ、その関数が値を返さずに終了してしまうという事態に陥るからです。</p>

<p>次の状況を想像してみましょう。
関数人であるB君は、同じく関数人であるAさんに愛情(引数)をもらって一生懸命働きます。
しかし、B君はAさんに給料(返り値)を渡しませんでした。
そんな状況は有ってはならないのです。
もちろん、最初から見返りがない(返り値型が<code>void</code>)場合はいいのですが。</p>
<div class="highlight"><pre><code class="language-d" data-lang="d"><span class="c1">// 意味のない関数</span>
<span class="kt">int</span> <span class="n">foo</span><span class="p">(</span><span class="kt">int</span> <span class="n">a</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">if</span><span class="p">(</span><span class="n">a</span> <span class="p">||</span> <span class="p">!</span><span class="n">a</span><span class="p">){</span>
        <span class="k">while</span><span class="p">(</span><span class="n">a</span><span class="p">){</span>
            <span class="k">if</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
                <span class="k">return</span> <span class="n">a</span><span class="p">;</span>
        <span class="p">}</span>
    <span class="p">}</span>

    <span class="c1">// ここには絶対到達しない</span>
    <span class="c1">// しかし、returnしておかないとコンパイラに怒られる</span>
    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div>
<p>絶対に到達し得ないのに<code>return 0;</code>と書いていると、他人が読んだ時に「こいつ何書いてるんだ？」というふうに思われてしまします。
また、<code>return 0;</code>というコードを入れることによって、その関数が失敗したから<code>0</code>を返したのか、成功した結果の<code>0</code>なのかわからなくなります。
よって、このような場合には<code>return</code>の代わりに<code>assert(0);</code>を入れてあげます。</p>
<div class="highlight"><pre><code class="language-d" data-lang="d"><span class="c1">// 意味のない関数</span>
<span class="kt">int</span> <span class="n">foo</span><span class="p">(</span><span class="kt">int</span> <span class="n">a</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">if</span><span class="p">(</span><span class="n">a</span> <span class="p">||</span> <span class="p">!</span><span class="n">a</span><span class="p">){</span>
        <span class="k">while</span><span class="p">(</span><span class="n">a</span><span class="p">){</span>
            <span class="k">if</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
                <span class="k">return</span> <span class="n">a</span><span class="p">;</span>
        <span class="p">}</span>
    <span class="p">}</span>

    <span class="c1">// ここには絶対到達しない</span>
    <span class="k">assert</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div>
<p><code>assert(0);</code>があれば、<code>return</code>がなくてもコンパイルは通ります。
もしその<code>assert(0);</code>が実行されてしまったとしても次のようなメッセージと共にプログラムはただちに終了します。</p>
<div class="highlight"><pre><code class="language-text" data-lang="text">core.exception.AssertError@foo(10): Assertion failure
----------------
0x0040323B
0x0040201E
0x0040202A
0x00402633
0x00402231
0x00402054
0x75B933AA in BaseThreadInitThunk
0x772F9EF2 in RtlInitializeExceptionChain
0x772F9EC5 in RtlInitializeExceptionChain
----------------
</code></pre></div>
<p>次の状況を想像してみましょう。
関数人であるB君は、同じく関数人であるAさんに愛情(引数)をもらって一生懸命働きます。
しかし、B君はAさんに給料(返り値)を渡しませんでした。
実は、関数人には爆弾(<code>assert(0);</code>)が仕かけられています。
その爆弾が爆発するのは、恩など(返り値)を返さなかったときです。
つまり、B君は爆発しました。
悲しいことに、B君が爆発してしまったがために給料がもらえなかったAさんは、Aさん自身の仕事を遂行できなくなりました。
その結果、AさんはAさんの親(関数Aの呼び出し元)に給料を送ることができなくなりました。
すると、Aさんの爆弾も爆発し、つまり最終的にはmain関数ちゃんまでもが爆発して、プログラム界は破滅します。</p>

<p><a href="#Q3">Goto: 問題3 「コンパイルできない！」</a>  </p>

<p>何も返さない関数を書きたいのであれば、<code>ReturnType</code>を<code>void</code>とします。
そのような関数では、<code>return</code>を関数中に書く必要はなく、関数を途中で終わらせたい場合にだけ<code>return;</code>と書きます。
返り値がない関数で、<code>return</code>文が実行されることなく関数の最後まで到達した場合には、<code>return</code>文と同様の効果により関数が終了します。</p>
<div class="highlight"><pre><code class="language-d" data-lang="d"><span class="kt">void</span> <span class="n">foo</span><span class="p">(</span><span class="kt">int</span> <span class="n">a</span><span class="p">,</span> <span class="kt">int</span> <span class="n">b</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">if</span><span class="p">(</span><span class="n">a</span> <span class="p">&gt;</span> <span class="mi">0</span><span class="p">)</span>
        <span class="k">return</span><span class="p">;</span> <span class="c1">// a &gt; 0 の場合には、関数は終わり、即座に処理が呼び出し元に戻る</span>
    <span class="k">else</span>
        <span class="n">writeln</span><span class="p">(</span><span class="n">b</span> <span class="p">-</span> <span class="n">a</span><span class="p">);</span>

    <span class="c1">// a &lt;= 0 の場合にはここまで来て、処理が呼び出し元に戻る</span>
<span class="p">}</span>
</code></pre></div>
<p>この説明が分かりにくければ、<code>main</code>関数を思い出してみましょう。
<code>main</code>関数は、<code>ReturnType</code>が<code>void</code>な関数でしたが、<code>return</code>文をいちいち入れませんでしたね。
しかし、<code>main</code>関数はちゃんと終了していました。</p>

<p><code>return</code>文を入れて、<code>main</code>関数を途中で強制的に終わらせることもできます。</p>
<div class="highlight"><pre><code class="language-d" data-lang="d"><span class="k">import</span> <span class="n">std</span><span class="p">.</span><span class="n">conv</span><span class="p">,</span> <span class="n">std</span><span class="p">.</span><span class="n">stdio</span><span class="p">,</span> <span class="n">std</span><span class="p">.</span><span class="nb">string</span><span class="p">;</span>


<span class="c1">/// 例：コンソールで入力された数字をint型で返す関数</span>
<span class="kt">int</span> <span class="n">readInt</span><span class="p">()</span>
<span class="p">{</span>
    <span class="k">return</span> <span class="n">readln</span><span class="p">().</span><span class="n">strip</span><span class="p">().</span><span class="n">to</span><span class="p">!</span><span class="kt">int</span><span class="p">();</span>
<span class="p">}</span>


<span class="kt">void</span> <span class="n">main</span><span class="p">()</span>
<span class="p">{</span>
    <span class="n">writeln</span><span class="p">(</span><span class="s">&quot;main&quot;</span><span class="p">);</span>
    <span class="n">writeln</span><span class="p">(</span><span class="s">&quot;10以上整数を入力すると終了----&quot;</span><span class="p">);</span>

    <span class="k">if</span><span class="p">(</span><span class="n">readInt</span><span class="p">()</span> <span class="p">&gt;=</span> <span class="mi">10</span><span class="p">)</span>     <span class="c1">// ある条件を満たせば、</span>
        <span class="k">return</span><span class="p">;</span>             <span class="c1">// 終了</span>

    <span class="n">writeln</span><span class="p">(</span><span class="s">&quot;end&quot;</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div>
<p><a href="#Q4">Goto: 問題4 「helpメッセージを表示せよ」</a>  </p>

<h3>関数の引数</h3>

<p>関数は引数を受け取りますが、関数宣言で書かれている<code>int a</code>や<code>int b</code>を<b>仮引数</b>(parameter)といいます。
逆に、<code>addInt(4, 5)</code>とした場合の<code>4</code>や<code>5</code>は<b>実引数</b>(argument)といわれます。</p>

<p>関数本体が無い場合、もしくは仮引数を関数本体で使わない場合には、仮引数を省略して型だけにすることもできます。</p>
<div class="highlight"><pre><code class="language-d" data-lang="d"><span class="c1">// intを3つ受け取るが、関数本体がないので仮引数は型だけしか書かない</span>
<span class="kt">int</span> <span class="n">add</span><span class="p">(</span><span class="kt">int</span><span class="p">,</span> <span class="kt">int</span><span class="p">,</span> <span class="kt">int</span><span class="p">);</span>
</code></pre></div>
<p>通常、実引数は仮引数にコピーされて関数に渡されます。
つまり、値型であれば仮引数を変更しても実引数には影響しませんが、参照型であればその参照(住所)をコピーしますから、コピーされた参照を通して参照元に影響を与える可能性があります。</p>
<div class="highlight"><pre><code class="language-d" data-lang="d"><span class="c1">// aは値型</span>
<span class="kt">void</span> <span class="n">addToValue</span><span class="p">(</span><span class="kt">int</span> <span class="n">a</span><span class="p">,</span> <span class="kt">int</span> <span class="n">b</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">a</span> <span class="p">+=</span> <span class="n">b</span><span class="p">;</span>
<span class="p">}</span>


<span class="c1">// aはポインタ(参照型)</span>
<span class="kt">void</span> <span class="n">addToRef</span><span class="p">(</span><span class="kt">int</span><span class="p">*</span> <span class="n">a</span><span class="p">,</span> <span class="kt">int</span> <span class="n">b</span><span class="p">)</span>
<span class="p">{</span>
    <span class="p">*</span><span class="n">a</span> <span class="p">+=</span> <span class="n">b</span><span class="p">;</span>        <span class="c1">// ポインタの参照先のインクリメント</span>
                    <span class="c1">// 呼び出し元に影響を与える操作</span>

    <span class="n">a</span> <span class="p">=</span> <span class="kc">null</span><span class="p">;</span>       <span class="c1">// ポインタの書き換え</span>
                    <span class="c1">// この操作では呼び出し元に影響はない</span>
<span class="p">}</span>


<span class="kt">void</span> <span class="n">main</span><span class="p">()</span>
<span class="p">{</span>
    <span class="kt">int</span> <span class="n">m</span> <span class="p">=</span> <span class="mi">2</span><span class="p">,</span>
        <span class="n">n</span> <span class="p">=</span> <span class="mi">13</span><span class="p">;</span>

    <span class="n">addToValue</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="n">n</span><span class="p">);</span>
    <span class="n">writefln</span><span class="p">(</span><span class="s">&quot;m: %s, n:%s&quot;</span><span class="p">,</span> <span class="n">m</span><span class="p">,</span> <span class="n">n</span><span class="p">);</span>      <span class="c1">// 2, 13</span>

    <span class="n">addToRef</span><span class="p">(&amp;</span><span class="n">m</span><span class="p">,</span> <span class="n">n</span><span class="p">);</span>                    <span class="c1">// ポインタ(参照型)を渡す</span>
    <span class="n">writefln</span><span class="p">(</span><span class="s">&quot;m: %s, n:%s&quot;</span><span class="p">,</span> <span class="n">m</span><span class="p">,</span> <span class="n">n</span><span class="p">);</span>      <span class="c1">// 15, 13</span>
                                        <span class="c1">// m が書き換えられてる！</span>
<span class="p">}</span>
</code></pre></div>
<p>宣言された仮引数の型のリストと実引数の型のリストが一致しなければコンパイル時にエラーがでます。</p>
<div class="highlight"><pre><code class="language-d" data-lang="d"><span class="c1">// test00901.d</span>
<span class="kt">int</span> <span class="n">add</span><span class="p">(</span><span class="kt">int</span> <span class="n">a</span><span class="p">,</span> <span class="kt">int</span> <span class="n">b</span><span class="p">)</span> <span class="p">{</span> <span class="k">return</span> <span class="n">a</span> <span class="p">+</span> <span class="n">b</span><span class="p">;</span> <span class="p">}</span>

<span class="kt">void</span> <span class="n">main</span><span class="p">()</span>
<span class="p">{</span>
    <span class="kt">int</span> <span class="n">a</span> <span class="p">=</span> <span class="n">add</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">5</span><span class="p">),</span>
        <span class="n">b</span> <span class="p">=</span> <span class="n">add</span><span class="p">(</span><span class="mi">3</span><span class="p">),</span>             <span class="c1">// Error: function test00901.add (int a, int b) is not callable using argument types (int)</span>
        <span class="n">c</span> <span class="p">=</span> <span class="n">add</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">),</span>       <span class="c1">// Error: function test00901.add (int a, int b) is not callable using argument types (int, int, int)</span>
        <span class="n">d</span> <span class="p">=</span> <span class="n">add</span><span class="p">(</span><span class="mf">3.0</span><span class="p">,</span> <span class="mi">4</span><span class="p">);</span>        <span class="c1">// Error: function test00901.add (int a, int b) is not callable using argument types (double, int)</span>
<span class="p">}</span>
</code></pre></div>
<h2>デフォルト引数</h2>

<p>仮引数にはデフォルト値を設定することができます。
デフォルト値が設定された仮引数に渡す実引数は省略することができます。
省略された場合には、仮引数に設定されたデフォルト値が仮引数の値となります。</p>

<p>しかし、デフォルト値を設定したとしても、その仮引数の後ろにデフォルト値が設定されていない仮引数がある場合にはコンパイルエラーとなります。</p>
<div class="highlight"><pre><code class="language-d" data-lang="d"><span class="kt">int</span> <span class="n">getValue</span><span class="p">(</span><span class="kt">int</span><span class="p">*</span> <span class="n">p</span><span class="p">,</span> <span class="nb">size_t</span> <span class="n">idx</span> <span class="p">=</span> <span class="mi">0</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">return</span> <span class="n">p</span><span class="p">[</span><span class="n">idx</span><span class="p">];</span>
<span class="p">}</span>


<span class="c1">// idxはデフォルト値が設定されているが、後ろにデフォルト値が設定されていない v があるのでエラー</span>
<span class="c1">// Error: default argument expected for v</span>
<span class="cm">/*</span>
<span class="cm">bool getAndTest(int* p, size_t idx = 0, int v)</span>
<span class="cm">{</span>
<span class="cm">    return p[idx] == v;</span>
<span class="cm">}</span>
<span class="cm">*/</span>

<span class="c1">// デフォルト値は2つ以上の引数にも設定可能</span>
<span class="kt">int</span> <span class="n">getValue2d</span><span class="p">(</span><span class="kt">int</span><span class="p">**</span> <span class="n">p</span><span class="p">,</span> <span class="nb">size_t</span> <span class="n">i</span> <span class="p">=</span> <span class="mi">0</span><span class="p">,</span> <span class="nb">size_t</span> <span class="n">j</span> <span class="p">=</span> <span class="mi">0</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">return</span> <span class="n">p</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">];</span>
<span class="p">}</span>


<span class="kt">void</span> <span class="n">main</span><span class="p">()</span>
<span class="p">{</span>
    <span class="kt">int</span><span class="p">*</span> <span class="n">p</span> <span class="p">=</span> <span class="p">(</span><span class="k">new</span> <span class="kt">int</span><span class="p">[</span><span class="mi">10</span><span class="p">]).</span><span class="n">ptr</span><span class="p">;</span>
    <span class="k">foreach</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="k">ref</span> <span class="n">e</span><span class="p">;</span> <span class="n">p</span><span class="p">[</span><span class="mi">0</span> <span class="p">..</span> <span class="mi">10</span><span class="p">])</span>
        <span class="n">e</span> <span class="p">=</span> <span class="n">i</span><span class="p">;</span>

    <span class="n">p</span><span class="p">[</span><span class="mi">0</span> <span class="p">..</span> <span class="mi">10</span><span class="p">].</span><span class="n">reverse</span><span class="p">;</span>

    <span class="n">writeln</span><span class="p">(</span><span class="n">p</span><span class="p">[</span><span class="mi">0</span> <span class="p">..</span> <span class="mi">10</span><span class="p">]);</span>            <span class="c1">// [9, 8, 7, 6, 5, 4, 3, 2, 1, 0]</span>

    <span class="c1">// idxを指定して呼び出し</span>
    <span class="n">writeln</span><span class="p">(</span><span class="n">getValue</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="mi">4</span><span class="p">));</span>        <span class="c1">// 5</span>

    <span class="c1">// idxを省略して呼び出すと、idxは0であると解釈される</span>
    <span class="n">writeln</span><span class="p">(</span><span class="n">getValue</span><span class="p">(</span><span class="n">p</span><span class="p">));</span>           <span class="c1">// 9</span>

    <span class="kt">int</span><span class="p">**</span> <span class="n">pp</span> <span class="p">=</span> <span class="p">&amp;</span><span class="n">p</span><span class="p">;</span>
    <span class="n">writeln</span><span class="p">(</span><span class="n">getValue2d</span><span class="p">(</span><span class="n">pp</span><span class="p">));</span>          <span class="c1">// 9</span>
<span class="p">}</span>
</code></pre></div>
<h2>引数の記憶域クラス</h2>

<p>関数の引数にも、普通の変数と同様に<a href="variable_type.md#%E8%A8%98%E6%86%B6%E5%9F%9F%E3%82%AF%E3%83%A9%E3%82%B9storage-class">記憶域クラス(storage class)</a>を付けることができます。</p>

<p>一切記憶域クラスがついていない引数は、値が(参照型ならその参照が)コピーされます。
これに対して、<code>ref</code>や<code>out</code>, <code>lazy</code>は特殊な渡され方をされます。</p>

<ul>
<li><p><code>const</code></p>

<p><code>const</code>が付けられた仮引数の型は<code>const(Type)</code>となり、その仮引数は書き換え不可能になります。
<code>const T arg</code>と<code>const(T) arg</code>は同じ意味です。</p>

<p><code>const</code>な引数は、mutableな値(<code>const</code>, <code>immutable</code>ではない)でも非mutableな値(<code>const</code>か<code>immutable</code>)でも、受け取ることができます。</p>

<p>(「mutableな」とは、「変更可能な」という意味です。)</p>

<p><a href="variable_type.md#const"><code>const</code>型の解説</a></p>
<div class="highlight"><pre><code class="language-d" data-lang="d"><span class="kt">int</span> <span class="n">getValue</span><span class="p">(</span><span class="k">const</span> <span class="kt">int</span><span class="p">*</span> <span class="n">p</span><span class="p">)</span>
<span class="p">{</span>
    <span class="c1">//*p += 3;                  // pはconst(int*)型、*pはconst(int)型なので書き換え不可</span>

    <span class="k">return</span> <span class="p">*</span><span class="n">p</span><span class="p">;</span>                  <span class="c1">// *pはconst(int)型なので、int型として返せる</span>
<span class="p">}</span>
</code></pre></div></li>
<li><p><code>immutable</code></p>

<p><code>immutable</code>記憶域クラスとなっている引数はその引数の型が<code>immutable(Type)</code>となります。</p>

<p><code>immutable</code>記憶域クラスな引数は<code>immutable</code>な値しか受け付けません。
もちろん、引数はコピーされるため<code>immutable</code>でない値型も受け付けます。
値型であれば<code>immutable</code>なコピーを作ることができるからです。</p>

<p><a href="variable_type.md#immutable"><code>immutable</code>型の解説</a></p>
<div class="highlight"><pre><code class="language-d" data-lang="d"><span class="k">immutable</span><span class="p">(</span><span class="kt">int</span><span class="p">)*</span> <span class="n">getValue</span><span class="p">(</span><span class="k">immutable</span> <span class="kt">int</span><span class="p">*</span> <span class="n">p</span><span class="p">)</span>
<span class="p">{</span>
    <span class="c1">//*p += 3;                  // pはimmutable(int*)型、*pはimmutable(int*)型なので書き換え不可</span>

    <span class="k">return</span> <span class="p">*</span><span class="n">p</span><span class="p">;</span>                  <span class="c1">// *pはimmutable(int*)型なので、immutable(int)*型として返せる</span>
<span class="p">}</span>
</code></pre></div></li>
<li><p><code>inout</code></p>

<p>このストレージクラスとなった引数は<code>inout</code>型になります。
仮引数に<code>inout</code>型を一つでも含む関数はinout関数と呼ばれます。
inout関数は、その関数を呼び出す実引数によって関数の返り値の型が変わります。</p>

<p>まずは仮引数に<code>inout</code>型を1つだけ含む関数<code>inout(int[]) getFront(inout(int[]) x);</code>について考えてみましょう。
この関数には<code>int[]</code>や<code>const(int[])</code>、さらには<code>immutable(int[])</code>型の値を渡すことが出来ます。
<code>getFront</code>関数の返り値は、実引数が<code>int[]</code>の場合には<code>int[]</code>が、<code>const(int[])</code>の場合には<code>const(int[])</code>が、そして<code>immutable(int[])</code>の場合には<code>immutable(int[])</code>になります。</p>

<p>コンパイラが3つのパターンについて<code>getFront</code>関数を生成しているわけではないことに注意しましょう。
コンパイラは、呼び出し毎に、実引数の型を調査して、それに見合った返り値の型を設定しているのです。</p>

<p>次に、仮引数に<code>inout</code>型が1つよりも多く存在した場合ですが、コンパイラは呼び出し毎にすべての<code>inout</code>仮引数に対する実引数を調査します。
コンパイラによる実引数の調査の結果、コンパイラは次のように返り値の型を変更します。</p>

<ol>
<li><code>inout</code>に対応する型がすべて<code>immutable</code>であれば返り値の<code>inout</code>も<code>immutable</code>に置き換わった型になります。</li>
<li><code>inout</code>に対応するすべての実引数の型がmutable(<code>const</code>でも<code>immutable</code>でもない)であれば、返り値の<code>inout</code>は取り除かれます。</li>
<li>1や2にマッチしなかった場合は返り値の<code>inout</code>は<code>const</code>に置き換わります。</li>
</ol>
<div class="highlight"><pre><code class="language-d" data-lang="d"><span class="k">inout</span><span class="p">(</span><span class="kt">int</span><span class="p">)[]</span> <span class="n">foo</span><span class="p">(</span><span class="k">inout</span><span class="p">(</span><span class="kt">int</span><span class="p">[])</span> <span class="n">x</span><span class="p">,</span> <span class="k">inout</span><span class="p">(</span><span class="kt">int</span><span class="p">[])</span> <span class="n">y</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">return</span> <span class="n">x</span> <span class="p">~</span> <span class="n">y</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="n">main</span><span class="p">()</span>
<span class="p">{</span>
    <span class="kt">int</span><span class="p">[]</span> <span class="n">marr</span> <span class="p">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">];</span>
    <span class="k">const</span> <span class="n">carr</span> <span class="p">=</span> <span class="n">marr</span><span class="p">;</span>
    <span class="k">immutable</span> <span class="n">iarr</span> <span class="p">=</span> <span class="n">marr</span><span class="p">.</span><span class="n">dup</span><span class="p">;</span>

    <span class="c1">// (mutable, mutable) =&gt; mutable</span>
    <span class="k">auto</span> <span class="n">a</span> <span class="p">=</span> <span class="n">foo</span><span class="p">(</span><span class="n">marr</span><span class="p">,</span> <span class="n">marr</span><span class="p">);</span>
    <span class="k">static</span> <span class="k">assert</span><span class="p">(</span><span class="k">is</span><span class="p">(</span><span class="k">typeof</span><span class="p">(</span><span class="n">a</span><span class="p">)</span> <span class="p">==</span> <span class="kt">int</span><span class="p">[]));</span>

    <span class="c1">// (mutable, const) =&gt; const</span>
    <span class="k">auto</span> <span class="n">b</span> <span class="p">=</span> <span class="n">foo</span><span class="p">(</span><span class="n">marr</span><span class="p">,</span> <span class="n">carr</span><span class="p">);</span>
    <span class="k">static</span> <span class="k">assert</span><span class="p">(</span><span class="k">is</span><span class="p">(</span><span class="k">typeof</span><span class="p">(</span><span class="n">b</span><span class="p">)==</span> <span class="k">const</span><span class="p">(</span><span class="kt">int</span><span class="p">)[]));</span>

    <span class="c1">// (mutable, immutable) =&gt; const</span>
    <span class="k">auto</span> <span class="n">c</span> <span class="p">=</span> <span class="n">foo</span><span class="p">(</span><span class="n">marr</span><span class="p">,</span> <span class="n">iarr</span><span class="p">);</span>
    <span class="k">static</span> <span class="k">assert</span><span class="p">(</span><span class="k">is</span><span class="p">(</span><span class="k">typeof</span><span class="p">(</span><span class="n">c</span><span class="p">)</span> <span class="p">==</span> <span class="k">const</span><span class="p">(</span><span class="kt">int</span><span class="p">)[]));</span>

    <span class="c1">// (const, immutable) =&gt; const</span>
    <span class="k">auto</span> <span class="n">d</span> <span class="p">=</span> <span class="n">foo</span><span class="p">(</span><span class="n">carr</span><span class="p">,</span> <span class="n">iarr</span><span class="p">);</span>
    <span class="k">static</span> <span class="k">assert</span><span class="p">(</span><span class="k">is</span><span class="p">(</span><span class="k">typeof</span><span class="p">(</span><span class="n">d</span><span class="p">)</span> <span class="p">==</span> <span class="k">const</span><span class="p">(</span><span class="kt">int</span><span class="p">)[]));</span>

    <span class="c1">// (immutable, immutable) =&gt; immutable</span>
    <span class="k">auto</span> <span class="n">e</span> <span class="p">=</span> <span class="n">foo</span><span class="p">(</span><span class="n">iarr</span><span class="p">,</span> <span class="n">iarr</span><span class="p">);</span>
    <span class="k">static</span> <span class="k">assert</span><span class="p">(</span><span class="k">is</span><span class="p">(</span><span class="k">typeof</span><span class="p">(</span><span class="n">e</span><span class="p">)</span> <span class="p">==</span> <span class="k">immutable</span><span class="p">(</span><span class="kt">int</span><span class="p">)[]));</span>
<span class="p">}</span>
</code></pre></div>
<p>また、inout関数内でのみ<code>inout</code>型の変数を宣言できます。
<code>inout(T)</code>という型は<code>const(T)</code>へは暗黙変換可能ですが、<code>T</code>や<code>immutable(T)</code>へは暗黙変換できません。</p>
<div class="highlight"><pre><code class="language-d" data-lang="d"><span class="k">import</span> <span class="n">std</span><span class="p">.</span><span class="n">traits</span><span class="p">;</span>

<span class="kt">void</span> <span class="n">foo</span><span class="p">(</span><span class="k">inout</span><span class="p">(</span><span class="kt">int</span><span class="p">)[]</span> <span class="n">x</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">inout</span><span class="p">(</span><span class="kt">int</span><span class="p">)[]</span> <span class="n">y</span> <span class="p">=</span> <span class="n">x</span><span class="p">;</span>
    <span class="k">auto</span> <span class="n">z</span> <span class="p">=</span> <span class="n">x</span> <span class="p">~</span> <span class="n">y</span><span class="p">;</span>
    <span class="k">static</span> <span class="k">assert</span><span class="p">(</span><span class="k">is</span><span class="p">(</span><span class="k">typeof</span><span class="p">(</span><span class="n">z</span><span class="p">)</span> <span class="p">==</span> <span class="k">inout</span><span class="p">(</span><span class="kt">int</span><span class="p">)[]));</span>

    <span class="c1">//int[] mz = z;     Error</span>
    <span class="k">const</span> <span class="n">cz</span> <span class="p">=</span> <span class="n">z</span><span class="p">;</span>
    <span class="c1">//immutable iz = z; Error</span>

    <span class="c1">// inout と mutable の CommonType =&gt; const</span>
    <span class="k">static</span> <span class="k">assert</span><span class="p">(</span><span class="k">is</span><span class="p">(</span><span class="n">CommonType</span><span class="p">!(</span><span class="k">inout</span><span class="p">(</span><span class="kt">int</span><span class="p">)[],</span> <span class="kt">int</span><span class="p">[])</span>
        <span class="p">==</span> <span class="k">const</span><span class="p">(</span><span class="kt">int</span><span class="p">)[]));</span>

    <span class="c1">// inout と const の CommonType =&gt; const</span>
    <span class="k">static</span> <span class="k">assert</span><span class="p">(</span><span class="k">is</span><span class="p">(</span><span class="n">CommonType</span><span class="p">!(</span><span class="k">inout</span><span class="p">(</span><span class="kt">int</span><span class="p">)[],</span> <span class="k">const</span><span class="p">(</span><span class="kt">int</span><span class="p">)[])</span>
        <span class="p">==</span> <span class="k">const</span><span class="p">(</span><span class="kt">int</span><span class="p">)[]));</span>

    <span class="c1">// inout と immutable の CommonType =&gt; inout(const(int))</span>
    <span class="k">static</span> <span class="k">assert</span><span class="p">(</span><span class="k">is</span><span class="p">(</span><span class="n">CommonType</span><span class="p">!(</span><span class="k">inout</span><span class="p">(</span><span class="kt">int</span><span class="p">)[],</span> <span class="k">immutable</span><span class="p">(</span><span class="kt">int</span><span class="p">)[])</span>
        <span class="p">==</span> <span class="k">inout</span><span class="p">(</span><span class="k">const</span><span class="p">(</span><span class="kt">int</span><span class="p">))[]));</span>
<span class="p">}</span>
</code></pre></div></li>
<li><p><code>shared</code></p>

<p>この記憶域クラスとなっている引数の型は、<code>shared</code>型になります。</p>

<p><a href="variable_type.md#shared"><code>shared</code>型の解説</a></p></li>
<li><p><code>scope</code></p>

<p><code>scope</code>が付いた引数は、その引数が持つ参照をその関数の外部に移動することができなくなります。
つまり、値型な引数に<code>scope</code>をつけても意味はありませんが、スライスやデリゲート、クラスなどのような参照を持つ型はグローバル変数に代入したり、関数から返すことはできなくなります。</p>
<div class="highlight"><pre><code class="language-d" data-lang="d"><span class="kt">int</span><span class="p">[]</span> <span class="n">gSlice</span><span class="p">;</span>               <span class="c1">// global変数</span>

<span class="kt">int</span><span class="p">[]</span> <span class="n">foo</span><span class="p">(</span><span class="k">scope</span> <span class="kt">int</span><span class="p">[]</span> <span class="n">x</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">gSlice</span> <span class="p">=</span> <span class="n">x</span><span class="p">;</span>             <span class="c1">// コンパイルエラー</span>
    <span class="k">return</span> <span class="n">x</span><span class="p">;</span>               <span class="c1">// コンパイルエラー</span>
<span class="p">}</span>
</code></pre></div>
<p>ただし、現在のdmd(dmd 2.063.2)では、この<code>scope</code>は機能していないようで、上記のようなコードもコンパイルが通ってしまいます。</p>

<p>bugzilla</p>

<ul>
<li><a href="http://d.puremagic.com/issues/show_bug.cgi?id=6931">Issue 6931</a></li>
</ul></li>
<li><p><code>in</code></p>

<p><code>const scope</code>と等しくなります。
よって、<code>const</code>同様に変更ができなくなります。
参照型に対しては、参照を関数外部に持っていくことも出来ないようになります。</p>

<p><small>ただし、現在のdmd(dmd 2.063.2)では<code>scope</code>記憶域クラスは機能してないようなので、<code>const</code>に等価な記憶域クラス？[要出典]</small></p></li>
<li><p><code>ref</code></p>

<p>実引数として左辺値を受け取り、仮引数への操作はすべて受け取った実引数への操作になります。
つまり、左辺値を関数内で操作し、関数を超えてその左辺値に影響を与えたい場合に利用します。</p>
<div class="highlight"><pre><code class="language-d" data-lang="d"><span class="kt">int</span> <span class="n">moveFront</span><span class="p">(</span><span class="k">ref</span> <span class="kt">int</span><span class="p">[]</span> <span class="n">arr</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">auto</span> <span class="n">dst</span> <span class="p">=</span> <span class="n">arr</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>

    <span class="n">arr</span> <span class="p">=</span> <span class="n">arr</span><span class="p">[</span><span class="mi">1</span> <span class="p">..</span> <span class="p">$];</span>
    <span class="k">return</span> <span class="n">dst</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="n">main</span><span class="p">()</span>
<span class="p">{</span>
    <span class="kt">int</span><span class="p">[]</span> <span class="n">arr</span> <span class="p">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">];</span>
    <span class="n">writeln</span><span class="p">(</span><span class="n">moveFront</span><span class="p">(</span><span class="n">arr</span><span class="p">));</span>        <span class="c1">// 0</span>
    <span class="n">writeln</span><span class="p">(</span><span class="n">arr</span><span class="p">.</span><span class="n">length</span><span class="p">);</span>            <span class="c1">// 3</span>
                                    <span class="c1">// arrが変更されている</span>

    <span class="n">writeln</span><span class="p">(</span><span class="n">moveFront</span><span class="p">(</span><span class="n">arr</span><span class="p">));</span>        <span class="c1">// 1</span>
    <span class="n">writeln</span><span class="p">(</span><span class="n">arr</span><span class="p">.</span><span class="n">length</span><span class="p">);</span>            <span class="c1">// 2</span>
                                    <span class="c1">// arrが変更されている</span>
<span class="p">}</span>
</code></pre></div></li>
<li><p><code>auto ref</code></p>

<p>この記憶域クラスは、テンプレート関数でのみ使用可能になります。
なので今は気にする必要はありませんが、機能としては「<code>ref</code>で引数が取れるなら<code>ref</code>でとる」という記憶域クラスです。
つまり、呼び出した際の実引数が左辺値であれば参照<code>ref</code>で受け取って、右辺値なら<code>non-ref</code>で受け取ります。</p></li>
<li><p><code>out</code></p>

<p>左辺値を受け取るという特性は<code>ref</code>と同じですが、関数に入る時点でその参照の値がデフォルト初期化値<code>.init</code>で初期化され、以降は<code>ref</code>と同様の動作になります。</p>

<p>返り値以外に出力をしたい場合に使用します。</p>
<div class="highlight"><pre><code class="language-d" data-lang="d"><span class="kt">int</span> <span class="n">findMax</span><span class="p">(</span><span class="k">in</span> <span class="kt">int</span><span class="p">[]</span> <span class="n">arr</span><span class="p">,</span> <span class="k">out</span> <span class="nb">size_t</span> <span class="n">idx</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">foreach</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">e</span><span class="p">;</span> <span class="n">arr</span><span class="p">)</span>
        <span class="k">if</span><span class="p">(</span><span class="n">e</span> <span class="p">&gt;</span> <span class="n">arr</span><span class="p">[</span><span class="n">idx</span><span class="p">])</span>
            <span class="n">idx</span> <span class="p">=</span> <span class="n">i</span><span class="p">;</span>
    <span class="k">return</span> <span class="n">arr</span><span class="p">[</span><span class="n">idx</span><span class="p">];</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="n">main</span><span class="p">()</span>
<span class="p">{</span>
    <span class="c1">// どうせ、findMax呼び出し時に初期化されるからvoidでもよい</span>
    <span class="nb">size_t</span> <span class="n">idx</span> <span class="p">=</span> <span class="kt">void</span><span class="p">;</span>

    <span class="n">writeln</span><span class="p">(</span><span class="n">findMax</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span> <span class="n">idx</span><span class="p">));</span>     <span class="c1">// 5</span>
    <span class="n">writeln</span><span class="p">(</span><span class="n">idx</span><span class="p">);</span>                               <span class="c1">// 2</span>
<span class="p">}</span>
</code></pre></div></li>
<li><p><code>lazy</code></p>

<p>この記憶域クラスでは、実引数の評価は遅延評価され、関数内で必要になった時に初めて評価されます。</p>

<p>仕組みとしては、引数を返すデリゲートを作り、そのデリゲートを呼び出しています。
つまり、<code>foo(expr)</code>が<code>foo((){return expr;})</code>になります。
デリゲートについては、後ほど説明するので、「遅延評価され、仮引数を複数回評価すると、実引数も複数回評価される」とだけ覚えておいてください。</p>
<div class="highlight"><pre><code class="language-d" data-lang="d"><span class="kt">int</span> <span class="n">get</span><span class="p">(</span><span class="kt">int</span><span class="p">*</span> <span class="n">p</span><span class="p">,</span> <span class="k">lazy</span> <span class="kt">int</span> <span class="n">defValue</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">return</span> <span class="n">p</span> <span class="p">?</span> <span class="p">*</span><span class="n">p</span> <span class="p">:</span> <span class="n">defValue</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="n">main</span><span class="p">()</span>
<span class="p">{</span>
    <span class="kt">int</span> <span class="n">a</span> <span class="p">=</span> <span class="mi">3</span><span class="p">;</span>

    <span class="n">writeln</span><span class="p">(</span><span class="n">get</span><span class="p">(&amp;</span><span class="n">a</span><span class="p">,</span> <span class="p">++</span><span class="n">a</span><span class="p">));</span>      <span class="c1">// 3</span>
                                <span class="c1">// get(&amp;a, (){ return ++a; })に等価</span>

    <span class="n">writeln</span><span class="p">(</span><span class="n">get</span><span class="p">(</span><span class="kc">null</span><span class="p">,</span> <span class="p">++</span><span class="n">a</span><span class="p">));</span>    <span class="c1">// 4</span>
                                <span class="c1">// get(null, (){ return ++a; })に等価</span>
<span class="p">}</span>
</code></pre></div>
<p>次のように複数回評価することもできます。</p>
<div class="highlight"><pre><code class="language-d" data-lang="d"><span class="k">import</span> <span class="n">std</span><span class="p">.</span><span class="n">array</span><span class="p">;</span>
<span class="k">import</span> <span class="n">std</span><span class="p">.</span><span class="n">stdio</span><span class="p">;</span>

<span class="kt">int</span><span class="p">[]</span> <span class="n">callN</span><span class="p">(</span><span class="k">lazy</span> <span class="kt">int</span> <span class="n">v</span><span class="p">,</span> <span class="nb">size_t</span> <span class="n">n</span><span class="p">)</span>
<span class="p">{</span>
    <span class="c1">// 配列に要素を追加していく場合には、std.array.appenderを使う</span>
    <span class="k">auto</span> <span class="n">app</span> <span class="p">=</span> <span class="n">appender</span><span class="p">!(</span><span class="kt">int</span><span class="p">[])();</span>

    <span class="c1">// n回評価して、追加していく</span>
    <span class="k">foreach</span><span class="p">(</span><span class="n">unused</span><span class="p">;</span> <span class="mi">0</span> <span class="p">..</span> <span class="n">n</span><span class="p">)</span>
        <span class="n">app</span><span class="p">.</span><span class="n">put</span><span class="p">(</span><span class="n">v</span><span class="p">);</span>

    <span class="k">return</span> <span class="n">app</span><span class="p">.</span><span class="n">data</span><span class="p">;</span>            <span class="c1">// appenderが管理している配列を返す</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="n">main</span><span class="p">()</span>
<span class="p">{</span>
    <span class="kt">int</span> <span class="n">a</span> <span class="p">=</span> <span class="mi">3</span><span class="p">;</span>

    <span class="n">writeln</span><span class="p">(</span><span class="n">callN</span><span class="p">(++</span><span class="n">a</span><span class="p">,</span> <span class="mi">3</span><span class="p">));</span>               <span class="c1">// [4, 5, 6]</span>
<span class="p">}</span>
</code></pre></div>
<p><code>lazy</code>がどれほど素晴らしい機能なのかを体験するために、次のソースコードをコンパイルして実行してみましょう。</p>
<div class="highlight"><pre><code class="language-d" data-lang="d"><span class="k">import</span> <span class="n">std</span><span class="p">.</span><span class="n">stdio</span><span class="p">;</span>
<span class="k">import</span> <span class="n">std</span><span class="p">.</span><span class="n">datetime</span><span class="p">;</span>

<span class="kt">int</span> <span class="n">tarai_lazy</span><span class="p">(</span><span class="kt">int</span> <span class="n">x</span><span class="p">,</span> <span class="kt">int</span> <span class="n">y</span><span class="p">,</span> <span class="k">lazy</span> <span class="kt">int</span> <span class="n">z</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">x</span> <span class="p">&lt;=</span> <span class="n">y</span><span class="p">)</span> <span class="k">return</span> <span class="n">y</span><span class="p">;</span>
    <span class="k">return</span> <span class="n">tarai_lazy</span><span class="p">(</span><span class="n">tarai_lazy</span><span class="p">(</span><span class="n">x</span><span class="p">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">z</span><span class="p">),</span> <span class="n">tarai_lazy</span><span class="p">(</span><span class="n">y</span><span class="p">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">z</span><span class="p">,</span> <span class="n">x</span><span class="p">),</span> <span class="n">tarai_lazy</span><span class="p">(</span><span class="n">z</span><span class="p">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">));</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="n">tarai</span><span class="p">(</span><span class="kt">int</span> <span class="n">x</span><span class="p">,</span> <span class="kt">int</span> <span class="n">y</span><span class="p">,</span> <span class="kt">int</span> <span class="n">z</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">x</span> <span class="p">&lt;=</span> <span class="n">y</span><span class="p">)</span> <span class="k">return</span> <span class="n">y</span><span class="p">;</span>
    <span class="k">return</span> <span class="n">tarai</span><span class="p">(</span><span class="n">tarai</span><span class="p">(</span><span class="n">x</span><span class="p">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">z</span><span class="p">),</span> <span class="n">tarai</span><span class="p">(</span><span class="n">y</span><span class="p">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">z</span><span class="p">,</span> <span class="n">x</span><span class="p">),</span> <span class="n">tarai</span><span class="p">(</span><span class="n">z</span><span class="p">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">));</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="n">main</span><span class="p">()</span>
<span class="p">{</span>
    <span class="p">{</span>
        <span class="k">auto</span> <span class="n">mt</span> <span class="p">=</span> <span class="n">measureTime</span><span class="p">!(</span><span class="n">a</span> <span class="p">=&gt;</span> <span class="n">writefln</span><span class="p">(</span><span class="s">&quot;non-lazy: %s[usecs]&quot;</span><span class="p">,</span> <span class="n">a</span><span class="p">.</span><span class="n">usecs</span><span class="p">))();</span>
        <span class="n">tarai</span><span class="p">(</span><span class="mi">10</span><span class="p">,</span> <span class="mi">8</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
    <span class="p">}</span>

    <span class="p">{</span>
        <span class="k">auto</span> <span class="n">mt</span> <span class="p">=</span> <span class="n">measureTime</span><span class="p">!(</span><span class="n">a</span> <span class="p">=&gt;</span> <span class="n">writefln</span><span class="p">(</span><span class="s">&quot;lazy: %s[usecs]&quot;</span><span class="p">,</span> <span class="n">a</span><span class="p">.</span><span class="n">usecs</span><span class="p">))();</span>
        <span class="n">tarai_lazy</span><span class="p">(</span><span class="mi">10</span><span class="p">,</span> <span class="mi">8</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div>
<p>実行結果はどのように出ましたか？
私の環境では、以下のように出力されました。</p>
<div class="highlight"><pre><code class="language-text" data-lang="text">non-lazy: 3344[usecs]
lazy: 1[usecs]
</code></pre></div>
<p>先ほどのプログラムは、「<a href="http://ja.wikipedia.org/wiki/%E7%AB%B9%E5%86%85%E9%96%A2%E6%95%B0">たらい回し関数(竹内関数)</a>」のD言語での実装でした。
たらい回し関数は、関数自体が短く、引数<code>x, y, z</code>が小さな数であったとしても、計算量が膨大な数になってしまう関数です。
私の環境だと<code>tarai(10, 8, 0)</code>に3ミリ秒程度かかったということになります。</p>

<p>しかし、遅延評価バージョン(<code>tarai_lazy(10, 8, 0)</code>)では、たった1マイクロ秒で計算が終わってます。
<code>tarai</code>と<code>tarai_lazy</code>の違いは、引数が<code>lazy int z</code>になってるだけです。
たらい回し関数は、<code>z</code>が遅延評価されると途端に計算量が低下する関数なので、このように<code>tarai_lazy</code>は高速なのです。</p></li>
</ul>

<h2>可変個引数関数</h2>

<p>引数に取りたい実引数の数が、実行条件によって変わることがあります。
たとえば、<code>writeln</code>や<code>writefln</code>などの<code>write</code>系の関数は、引数をいくらでも取ることができます。</p>

<p>このような関数を作るのには、様々な方法があります。</p>

<ul>
<li><p>同じ型の引数を可変個取りたい場合</p>

<p>たとえば、次のように文字列をいくつか受け取って、それらを連結した文字列を返す関数は、次のように書けます。</p>
<div class="highlight"><pre><code class="language-d" data-lang="d"><span class="nb">string</span> <span class="n">chainString</span><span class="p">(</span><span class="nb">string</span><span class="p">[]</span> <span class="n">str</span><span class="p">...)</span>
<span class="p">{</span>
    <span class="nb">string</span> <span class="n">chained</span><span class="p">;</span>

    <span class="k">foreach</span><span class="p">(</span><span class="n">e</span><span class="p">;</span> <span class="n">str</span><span class="p">)</span>
        <span class="n">chained</span> <span class="p">~=</span> <span class="n">e</span><span class="p">;</span>

    <span class="k">return</span> <span class="n">chained</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="n">main</span><span class="p">()</span>
<span class="p">{</span>
    <span class="n">writeln</span><span class="p">(</span><span class="n">chainString</span><span class="p">());</span>
    <span class="n">writeln</span><span class="p">(</span><span class="n">chainString</span><span class="p">(</span><span class="s">&quot;foo&quot;</span><span class="p">));</span>
    <span class="n">writeln</span><span class="p">(</span><span class="n">chainString</span><span class="p">(</span><span class="s">&quot;foo&quot;</span><span class="p">,</span> <span class="s">&quot;bar&quot;</span><span class="p">));</span>
    <span class="n">writeln</span><span class="p">(</span><span class="n">chainString</span><span class="p">(</span><span class="s">&quot;foo&quot;</span><span class="p">,</span> <span class="s">&quot;bar&quot;</span><span class="p">,</span> <span class="s">&quot;hoge&quot;</span><span class="p">));</span>
<span class="p">}</span>
</code></pre></div>
<p>可変長パラメータである<code>str</code>に、引数のリストが入ります。
<code>str</code>を関数外に移動することは不正です
(つまり、<code>scope</code>が暗黙的に付いていると考えれる？[要出典])。</p>

<p>実際には、静的配列にすることもできます。
たとえば、いくつかの数を受け取って、その中で最も大きな整数を返す関数は次のように書けます。</p>
<div class="highlight"><pre><code class="language-d" data-lang="d"><span class="n">T</span> <span class="n">max</span><span class="p">(</span><span class="n">T</span><span class="p">,</span> <span class="nb">size_t</span> <span class="n">N</span><span class="p">)(</span><span class="n">T</span><span class="p">[</span><span class="n">N</span><span class="p">]</span> <span class="n">nums</span><span class="p">...)</span>
<span class="k">if</span><span class="p">(</span><span class="n">N</span> <span class="p">&gt;</span> <span class="mi">0</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">T</span> <span class="n">v</span> <span class="p">=</span> <span class="n">nums</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>

    <span class="k">foreach</span><span class="p">(</span><span class="n">e</span><span class="p">;</span> <span class="n">nums</span><span class="p">[</span><span class="mi">1</span> <span class="p">..</span> <span class="p">$])</span>
        <span class="n">v</span> <span class="p">=</span> <span class="n">v</span> <span class="p">&gt;</span> <span class="n">e</span> <span class="p">?</span> <span class="n">v</span> <span class="p">:</span> <span class="n">e</span><span class="p">;</span>

    <span class="k">return</span> <span class="n">v</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="n">main</span><span class="p">()</span>
<span class="p">{</span>
    <span class="n">writeln</span><span class="p">(</span><span class="n">max</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">));</span>       <span class="c1">// 3</span>
<span class="p">}</span>
</code></pre></div>
<p>この関数は、テンプレート関数(Template Function)といい、任意の型Tと0より大きい任意のNに対してマッチするテンプレート関数です。</p></li>
<li><p>異なる型の引数を可変個取りたい場合</p>

<p><code>writeln</code>や<code>writefln</code>などは異なる型の引数を任意個取ることができます。
このような関数は可変個引数関数と呼ばれ、普通はテンプレートを使って作ります。</p>
<div class="highlight"><pre><code class="language-d" data-lang="d"><span class="kt">void</span> <span class="n">main</span><span class="p">()</span>
<span class="p">{</span>
    <span class="n">println</span><span class="p">(</span><span class="s">&quot; : &quot;</span><span class="p">,</span> <span class="s">&quot;foo&quot;</span><span class="p">,</span> <span class="s">&quot;bar&quot;</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">4</span><span class="p">);</span>     <span class="c1">// foo : bar : 2 : 4</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="n">println</span><span class="p">(</span><span class="n">T</span><span class="p">...)(</span><span class="nb">string</span> <span class="n">sep</span><span class="p">,</span> <span class="n">T</span> <span class="n">values</span><span class="p">)</span>
<span class="p">{</span>
    <span class="c1">// valuesはforeachで回せる</span>
    <span class="k">foreach</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">e</span><span class="p">;</span> <span class="n">values</span><span class="p">){</span>
        <span class="k">if</span><span class="p">(</span><span class="n">i</span> <span class="p">!=</span> <span class="mi">0</span><span class="p">)</span>
            <span class="n">write</span><span class="p">(</span><span class="n">sep</span><span class="p">);</span>

        <span class="n">write</span><span class="p">(</span><span class="n">e</span><span class="p">);</span>
    <span class="p">}</span>

    <span class="n">writeln</span><span class="p">();</span>

    <span class="cm">/* Tもforeachで回せる</span>
<span class="cm">    foreach(i, Unused; values){</span>
<span class="cm">        write(values[i]);</span>

<span class="cm">        if(i != T.length - 1)</span>
<span class="cm">            write(sep);</span>
<span class="cm">    }</span>

<span class="cm">    writeln();</span>
<span class="cm">    */</span>
<span class="p">}</span>
</code></pre></div>
<p>これについてはテンプレートの章で説明するとして、今回は全く使われない方法で可変個引数関数を作ります。
この方法にはCスタイルとDスタイルがありますが、全く使う機会がないのでさらっと流してしまいます。
詳しい仕様を知りたい場合には、<a href="http://www.kmonos.net/alang/d/function.html#variadic">可変個引数 - プログラミング言語D</a>を読みましょう。</p>

<ul>
<li><p>Cスタイルな可変個引数関数</p>

<p>関数の宣言は以下のようになります。</p>
<div class="highlight"><pre><code class="language-d" data-lang="d"><span class="k">extern</span><span class="p">(</span><span class="n">C</span><span class="p">)</span> <span class="kt">void</span> <span class="n">foo</span><span class="p">(</span><span class="kt">int</span> <span class="n">a</span><span class="p">,</span> <span class="p">...);</span>
<span class="c1">// extern(C) void bar(...);             // エラー</span>
</code></pre></div>
<p><code>...</code>の部分が可変個の引数を受け取れる部分です。
関数引数が<code>...</code>だけではいけません。
最低1つは可変個でない引数が必要です。
ちなみに、<code>extern(C)</code>は、「この関数はC言語みたいな関数だよ」ということです。</p></li>
<li><p>Dスタイルな可変個引数関数</p>
<div class="highlight"><pre><code class="language-d" data-lang="d"><span class="kt">void</span> <span class="n">foo</span><span class="p">(</span><span class="kt">int</span> <span class="n">a</span><span class="p">,</span> <span class="p">...);</span>
<span class="kt">void</span> <span class="n">bar</span><span class="p">(...);</span>                          <span class="c1">// OK</span>
</code></pre></div>
<p>Dスタイルの可変個引数関数では、<code>_argptr</code>と<code>_arguments</code>という変数にアクセスできます。
<code>import core.vararg;</code>とし、<code>va_arg!T(_argptr)</code>で型<code>T</code>の引数を取ることが出来ます。
また、<code>va_arg</code>で引数を取ったあと次に<code>va_arg</code>を呼び出す場合は、その次の変数が読み出せます。</p>

<p><code>_arguments</code>という引数には、可変個引数部分の引数の型の情報が格納されています。
型は<code>TypeInfo[]</code>で、<code>if(_arguments[i] == typeid(int)){}</code>のように、<code>i</code>番目の引数の型が<code>int</code>型かどうか比較ができます。</p>

<p>これから例として先ほどの<code>println</code>関数を作りたいのですが、あらためて引数とその動作を以下に示します。</p>
<div class="highlight"><pre><code class="language-d" data-lang="d"><span class="n">println</span><span class="p">(</span><span class="s">&quot; : &quot;</span><span class="p">,</span> <span class="s">&quot;foo&quot;</span><span class="p">,</span> <span class="s">&quot;bar&quot;</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">4</span><span class="p">);</span>     <span class="c1">// foo : bar : 2 : 4</span>
<span class="n">println</span><span class="p">(</span><span class="s">&quot;, &quot;</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="sc">&#39;c&#39;</span><span class="p">,</span> <span class="s">&quot;foo&quot;</span><span class="p">);</span>        <span class="c1">// 1, 2, c, foo</span>
</code></pre></div>
<p>対応する型は簡単化のために<code>int, char, string</code>でいいでしょう。
さて、<code>print</code>関数の動作と仕様がわかったので、実装していきたいと思います。</p>

<p><code>_arguments</code>は<code>TypeInfo[]</code>ですから、<code>foreach</code>で回すのが適切でしょう。
各要素で型を判別して、<code>va_arg!T</code>で引数を取得します。
よって、実装は次のようになります。</p>
<div class="highlight"><pre><code class="language-d" data-lang="d"><span class="k">import</span> <span class="n">core</span><span class="p">.</span><span class="n">vararg</span><span class="p">;</span>
<span class="k">import</span> <span class="n">std</span><span class="p">.</span><span class="n">stdio</span><span class="p">;</span>       <span class="c1">// write, writelnを使うから</span>

<span class="kt">void</span> <span class="n">println</span><span class="p">(</span><span class="nb">string</span> <span class="n">sep</span><span class="p">,</span> <span class="p">...)</span>
<span class="p">{</span>
    <span class="k">foreach</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">type</span><span class="p">;</span> <span class="n">_arguments</span><span class="p">){</span>
        <span class="k">if</span><span class="p">(</span><span class="n">type</span> <span class="p">==</span> <span class="k">typeid</span><span class="p">(</span><span class="kt">int</span><span class="p">))</span>
            <span class="n">write</span><span class="p">(</span><span class="n">va_arg</span><span class="p">!</span><span class="kt">int</span><span class="p">(</span><span class="n">_argptr</span><span class="p">));</span>
        <span class="k">else</span> <span class="k">if</span><span class="p">(</span><span class="n">type</span> <span class="p">==</span> <span class="k">typeid</span><span class="p">(</span><span class="kt">char</span><span class="p">))</span>
            <span class="n">write</span><span class="p">(</span><span class="n">va_arg</span><span class="p">!</span><span class="kt">char</span><span class="p">(</span><span class="n">_argptr</span><span class="p">));</span>
        <span class="k">else</span> <span class="k">if</span><span class="p">(</span><span class="n">type</span> <span class="p">==</span> <span class="k">typeid</span><span class="p">(</span><span class="nb">string</span><span class="p">))</span>
            <span class="n">write</span><span class="p">(</span><span class="n">va_arg</span><span class="p">!</span><span class="nb">string</span><span class="p">(</span><span class="n">_argptr</span><span class="p">));</span>
        <span class="k">else</span>
            <span class="k">assert</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>

        <span class="k">if</span><span class="p">(</span><span class="n">i</span> <span class="p">!=</span> <span class="n">_arguments</span><span class="p">.</span><span class="n">length</span> <span class="p">-</span> <span class="mi">1</span><span class="p">)</span>
            <span class="n">write</span><span class="p">(</span><span class="n">sep</span><span class="p">);</span>
    <span class="p">}</span>

    <span class="n">writeln</span><span class="p">();</span>
<span class="p">}</span>
</code></pre></div></li>
</ul></li>
</ul>

<h2>オブジェクトを形成する引数</h2>

<p>関数に渡されたの引数で、クラスのコンストラクタを走らせ、インスタンスを組み立てることができます。</p>
<div class="highlight"><pre><code class="language-d" data-lang="d"><span class="k">class</span> <span class="n">Foo</span><span class="p">{</span> <span class="k">this</span><span class="p">(</span><span class="kt">int</span> <span class="n">x</span><span class="p">,</span> <span class="kt">int</span> <span class="n">y</span><span class="p">){}</span> <span class="p">}</span>

<span class="c1">// Fooのコンストラクタが呼ばれる</span>
<span class="kt">void</span> <span class="n">foo</span><span class="p">(</span><span class="n">Foo</span> <span class="n">foo</span><span class="p">...)</span>    <span class="c1">// fooには暗黙的にscopeが付いているようなもの</span>
<span class="p">{</span>
    <span class="n">writeln</span><span class="p">(</span><span class="n">foo</span><span class="p">);</span>
<span class="p">}</span>


<span class="kt">void</span> <span class="n">main</span><span class="p">()</span>
<span class="p">{</span>
    <span class="n">foo</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">);</span>  <span class="c1">// Fooのコンストラクタは(int, int)</span>
<span class="p">}</span>
</code></pre></div>
<h2>返値型推論</h2>

<p>関数の返り値の型が複雑で長くなる場合があります。
その場合は、返り値の型を<code>auto</code>と書いておけば、<code>return</code>文から返り値の型が推論されるようになり便利です。</p>

<p>また、<code>auto ref</code>とすることで、参照で返すかどうかも推論されます。</p>
<div class="highlight"><pre><code class="language-d" data-lang="d"><span class="k">import</span> <span class="n">std</span><span class="p">.</span><span class="n">algorithm</span><span class="p">;</span>

<span class="c1">// この関数の返り値の型は MapResult!(unaryFun, FilterResult!(unaryFun, int[]))</span>
<span class="k">auto</span> <span class="n">func</span><span class="p">(</span><span class="kt">int</span><span class="p">[]</span> <span class="n">arr</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">return</span> <span class="n">arr</span><span class="p">.</span><span class="n">filter</span><span class="p">!</span><span class="s">&quot;a &gt; 2&quot;</span><span class="p">().</span><span class="n">map</span><span class="p">!</span><span class="s">&quot;a &gt;&gt; 1&quot;</span><span class="p">();</span>
<span class="p">}</span>


<span class="c1">// 引数が左辺値(lvalue)なら、返り値もlvalue</span>
<span class="k">auto</span> <span class="k">ref</span> <span class="n">add1</span><span class="p">()(</span><span class="k">auto</span> <span class="k">ref</span> <span class="kt">int</span> <span class="n">x</span><span class="p">)</span>         <span class="c1">// 仮引数記憶域クラスのauto refは、テンプレート関数専用なので`()`が必要</span>
<span class="p">{</span>
    <span class="n">x</span> <span class="p">+=</span> <span class="mi">1</span><span class="p">;</span>
    <span class="k">return</span> <span class="n">x</span><span class="p">;</span>
<span class="p">}</span>


<span class="kt">void</span> <span class="n">main</span><span class="p">()</span>
<span class="p">{</span>
    <span class="kt">int</span> <span class="n">a</span><span class="p">;</span>
    <span class="p">++</span><span class="n">add1</span><span class="p">(</span><span class="n">a</span><span class="p">);</span>      <span class="c1">// 返り値がlvalueなので、インクリメントできる</span>
    <span class="n">writeln</span><span class="p">(</span><span class="n">a</span><span class="p">);</span>     <span class="c1">// 2</span>

    <span class="c1">//++add1(10);   // Error: add1(10) is not an lvalue</span>
                    <span class="c1">// 10は右辺値(rvalue)なので、lvalueで返せない</span>
<span class="p">}</span>
</code></pre></div>
<h2>関数の属性</h2>

<p>関数に属性をつけることで、コンパイラにその関数の情報を与えることができます。
たとえば、<code>@property</code>という属性を、引数が0個の関数に付けると、<code>()</code>を省略して呼び出すことができます。
また、外部に影響を与えないということが静的に保証されている関数には<code>pure</code>が付きます。</p>

<h3>プロパティ関数<code>@property</code></h3>

<p>引数の数が0, 1, 2個の場合にのみ有効な属性です。
この属性が付いた関数は、次のような構文で関数を呼び出すことができるようになります。</p>
<div class="highlight"><pre><code class="language-d" data-lang="d"><span class="k">import</span> <span class="n">std</span><span class="p">.</span><span class="n">stdio</span><span class="p">;</span>


<span class="c1">// 引数の数が0個のプロパティ関数</span>
<span class="kt">int</span> <span class="n">foo</span><span class="p">()</span> <span class="nd">@property</span>
<span class="p">{</span>
    <span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>


<span class="c1">// 引数の数が1つのプロパティ関数</span>
<span class="kt">int</span> <span class="n">bar</span><span class="p">(</span><span class="kt">int</span> <span class="n">a</span><span class="p">)</span> <span class="nd">@property</span>
<span class="p">{</span>
    <span class="k">return</span> <span class="n">a</span><span class="p">;</span>
<span class="p">}</span>


<span class="c1">// 引数の数が2つのプロパティ関数</span>
<span class="kt">int</span> <span class="n">add</span><span class="p">(</span><span class="kt">int</span> <span class="n">a</span><span class="p">,</span> <span class="kt">int</span> <span class="n">b</span><span class="p">)</span> <span class="nd">@property</span>
<span class="p">{</span>
    <span class="k">return</span> <span class="n">a</span> <span class="p">+</span> <span class="n">b</span><span class="p">;</span>
<span class="p">}</span>


<span class="c1">//Error: properties can only have zero, one, or two parameter</span>
<span class="cm">/*</span>
<span class="cm">int tri(int a, int b, int c) @property pure nothrow @safe</span>
<span class="cm">{</span>
<span class="cm">    return a + b + c;</span>
<span class="cm">}</span>
<span class="cm">*/</span>


<span class="kt">void</span> <span class="n">main</span><span class="p">()</span>
<span class="p">{</span>
    <span class="n">writeln</span><span class="p">(</span><span class="n">foo</span><span class="p">);</span>               <span class="c1">// 1</span>
                                <span class="c1">// 引数の数が0の@property関数はカッコ()無しで変数みたいに呼べる</span>
    <span class="n">writeln</span><span class="p">(</span><span class="n">foo</span><span class="p">());</span>             <span class="c1">// もちろん、カッコ付きで読んでもOK</span>

    <span class="n">writeln</span><span class="p">(</span><span class="n">bar</span> <span class="p">=</span> <span class="mi">12</span><span class="p">);</span>          <span class="c1">// 12</span>
                                <span class="c1">// 引数の数が1つだと、プロパティ関数がさも代入されるかのような構文で呼べる</span>
                                <span class="c1">// この場合は、bar(12)に等価</span>
    <span class="n">writeln</span><span class="p">(</span><span class="mf">12.</span><span class="n">bar</span><span class="p">);</span>            <span class="c1">// UFCSとプロパティ関数の組み合わせ</span>

    <span class="n">writeln</span><span class="p">(</span><span class="mf">1.</span><span class="n">add</span> <span class="p">=</span> <span class="mi">15</span><span class="p">);</span>        <span class="c1">// 16</span>
                                <span class="c1">// 引数の数が2つだと、first.func = secondのような構文でも呼べるようになる。</span>
                                <span class="c1">// この場合はadd(1, 15)に等しい</span>
<span class="p">}</span>
</code></pre></div>
<p>プロパティ関数でない関数であっても、プロパティ関数のように呼び出すことは可能です。
しかし、dmdでは<code>-property</code>を指定することで、プロパティ関数でない関数がプロパティ関数のような構文で呼ばれている箇所がエラーになります。</p>

<p>構造体やクラスについては後の章で説明しますが、それらのメンバ関数がプロパティ関数の場合にも同様に呼び出すことができます。</p>
<div class="highlight"><pre><code class="language-d" data-lang="d"><span class="k">import</span> <span class="n">std</span><span class="p">.</span><span class="n">stdio</span><span class="p">;</span>


<span class="k">struct</span> <span class="n">S</span>
<span class="p">{</span>
    <span class="c1">// 引数の数は0個</span>
    <span class="kt">int</span> <span class="n">foo</span><span class="p">()</span> <span class="nd">@property</span>
    <span class="p">{</span>
        <span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
    <span class="p">}</span>


    <span class="c1">// 引数の数は1個</span>
    <span class="kt">int</span> <span class="n">bar</span><span class="p">(</span><span class="kt">int</span> <span class="n">a</span><span class="p">)</span> <span class="nd">@property</span>
    <span class="p">{</span>
        <span class="k">return</span> <span class="n">a</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">}</span>


<span class="kt">void</span> <span class="n">main</span><span class="p">()</span>
<span class="p">{</span>
    <span class="n">S</span> <span class="n">s</span><span class="p">;</span>

    <span class="n">writeln</span><span class="p">(</span><span class="n">s</span><span class="p">.</span><span class="n">foo</span><span class="p">);</span>             <span class="c1">// 1</span>
                                <span class="c1">// メンバ関数の場合でも、引数の数が0個なら、関数呼び出しのカッコが省略できる</span>
    <span class="n">writeln</span><span class="p">(</span><span class="n">s</span><span class="p">.</span><span class="n">foo</span><span class="p">());</span>           <span class="c1">// もちろん、カッコ付きで読んでもOK</span>

    <span class="n">writeln</span><span class="p">(</span><span class="n">s</span><span class="p">.</span><span class="n">bar</span> <span class="p">=</span> <span class="mi">12</span><span class="p">);</span>        <span class="c1">// 12</span>
                                <span class="c1">// メンバ関数の場合でも、引数の数が1つだと、さも代入されるかのような構文で呼べる</span>
                                <span class="c1">// この場合は、s.bar(12)に等価</span>
<span class="p">}</span>
</code></pre></div>
<h3>関数のメモリ安全性</h3>

<p>D言語には、
- 未定義動作を引き起こさないこと(<b>メモリ安全性</b>といいます)を保証する
- メモリ安全性を保証できない場合でも、そのようなコードを検証しやすくする</p>

<p>ための仕組みが用意されています。</p>

<p>関数に後述する属性を付けることでこの仕組みを利用することができ、未定義動作が原因の不可解で再現性のないバグを防ぐことができます。<br>
メモリ安全性についての属性は3つあり、付けられた属性によって、関数を以下のように分類することができます。</p>

<ul>
<li><p><b>セーフ関数</b><code>@safe</code></p>

<p><b>セーフ関数</b>(safe function)は、その関数内でのすべての操作がメモリ安全な関数で、未定義動作を引き起こさないことがコンパイラによって保証されます。
そのため、次のような制約があります。</p>

<ul>
<li>インラインアセンブラは書けない</li>
<li><code>cast</code>によって、<code>const</code>や<code>immutable</code>, <code>shared</code>を取り除くことができない</li>
<li><code>cast</code>によって、<code>immutable</code>や<code>shared</code>を付加することができない</li>
<li><code>cast</code>によって、ポインタ型<code>T*</code>を、<code>void*</code>以外の他のポインタ型<code>U*</code>へ変換できない</li>
<li><code>cast</code>による、ポインタでない型から、ポインタ型へ変換できない</li>
<li>ポインタ値の変更(加算, 減算, ...etc)不可</li>
<li>ポインタが指している要素以外は触れない(ptr[idx]は不可)</li>
<li>ポインタ型を含む<code>union</code>は触れない</li>
<li><code>class Exception</code>派生でない例外の<code>catch</code>ができない</li>
<li>システム関数(後述)の呼び出しができない</li>
<li>ローカル変数や関数引数へのアドレスの取得ができない</li>
<li><code>__gshared</code>な変数を触ることができない</li>
</ul>

<p><small>正確には、以下を参照:<br>
<a href="http://www.kmonos.net/alang/d/function.html#safe-functions">関数#safe-functions - プログラミング言語 D (日本語訳)</a><br>
<a href="http://dlang.org/function.html#safe-functions">Functions#safe-functions - D Programming Language</a><br>
<a href="http://www.kmonos.net/alang/d/safed.html">SafeD - プログラミング言語 D (日本語訳)</a><br>
<a href="http://dlang.org/safed.html">SafeD - D Programming Language</a></small>  </p>

<p>セーフ関数はコンパイル時に解析され、セーフ関数であるのにメモリ安全でない操作をしている場合には、コンパイルエラーとなります。</p>
<div class="highlight"><pre><code class="language-d" data-lang="d"><span class="kt">int</span> <span class="n">foo</span><span class="p">(</span><span class="kt">int</span><span class="p">*</span> <span class="n">p</span><span class="p">)</span> <span class="cm">/*@safe*/</span>
<span class="p">{</span>
    <span class="k">return</span> <span class="n">p</span><span class="p">[</span><span class="mi">1</span><span class="p">];</span>            <span class="c1">// *(p + 1)なので、fooはセーフ関数になれない</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="n">foo_safe</span><span class="p">(</span><span class="kt">int</span><span class="p">*</span> <span class="n">p</span><span class="p">)</span> <span class="nd">@safe</span>
<span class="p">{</span>
    <span class="k">return</span> <span class="n">p</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>            <span class="c1">// *pと等価なのでOK</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="n">bar</span><span class="p">(</span><span class="kt">int</span><span class="p">[]</span> <span class="n">arr</span><span class="p">)</span> <span class="nd">@safe</span>
<span class="p">{</span>
    <span class="nb">size_t</span> <span class="n">idx</span> <span class="p">=</span> <span class="mi">1</span><span class="p">;</span>
    <span class="k">return</span> <span class="n">arr</span><span class="p">[</span><span class="n">idx</span><span class="p">];</span>        <span class="c1">// 配列(スライス)に対するidxアクセスはOK</span>
<span class="p">}</span>
</code></pre></div></li>
<li><p><b>信頼済み関数</b><code>@trusted</code></p>

<p><b>信頼済み関数</b>(trusted function)は、関数内ではメモリ安全ではない操作を行なっているけれども関数全体としてみれば安全であるような関数です。
信頼済み関数では、操作の静的な制約はありませんが、メモリ安全であることをプログラマが保証しなければいけません。
このため、関数を定義するプログラマは未定義動作を引き起こさないように注意する必要があります。</p>
<div class="highlight"><pre><code class="language-d" data-lang="d"><span class="kt">int</span> <span class="n">foo</span><span class="p">(</span><span class="kt">int</span><span class="p">[]</span> <span class="n">arr</span><span class="p">)</span> <span class="nd">@trusted</span>
<span class="p">{</span>
    <span class="k">return</span> <span class="n">arr</span><span class="p">.</span><span class="n">ptr</span><span class="p">[</span><span class="n">arr</span><span class="p">.</span><span class="n">length</span> <span class="p">-</span> <span class="mi">1</span><span class="p">];</span>   <span class="c1">// ポインタが指している要素以外に触っているので、fooはセーフ関数になれない</span>
                            <span class="c1">// しかし、プログラマが保証するならば、信頼済み関数になれる</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="n">foo_safe</span><span class="p">(</span><span class="kt">int</span><span class="p">*</span> <span class="n">p</span><span class="p">)</span> <span class="nd">@safe</span>
<span class="p">{</span>
    <span class="k">return</span> <span class="n">p</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>
<span class="p">}</span>
</code></pre></div></li>
<li><p><b>システム関数</b><code>@system</code></p>

<p><b>システム関数</b>(system function)は、<code>@safe</code>でも<code>@trusted</code>でもない関数です。属性に<code>@system</code>を付けることで、システム関数であることを明示することもできます。
システム関数は、操作の静的な制約がなく、メモリ安全であることを誰も保証してくれないので、これらの関数を定義するときや使用するときには未定義動作を引き起こさないように注意する必要があります。</p>
<div class="highlight"><pre><code class="language-d" data-lang="d"><span class="kt">int</span> <span class="n">foo</span><span class="p">(){}</span>             <span class="c1">// デフォルトではsystem関数</span>
<span class="kt">int</span> <span class="n">hoge</span><span class="p">()</span> <span class="nd">@system</span> <span class="p">{}</span>   <span class="c1">// 明示的にsystem関数であることを表す</span>

<span class="kt">int</span> <span class="n">bar</span><span class="p">()</span> <span class="nd">@safe</span> <span class="p">{}</span>      <span class="c1">// system関数じゃなくて、safe関数</span>
<span class="kt">int</span> <span class="n">baz</span><span class="p">()</span> <span class="nd">@trusted</span> <span class="p">{}</span>   <span class="c1">// system関数じゃなくて、trusted関数</span>
</code></pre></div></li>
</ul>

<h3>純粋関数<code>pure</code></h3>

<p>純粋関数とは、その関数が外部に影響を与えないことが静的に保証されている関数です。
つまり、I/O(入出力)は禁止、グローバル変数は触れません。
ネスト関数の場合には外のスコープも触ってはいけません。
もちろん、impureな関数(<code>pure</code>でない関数)を呼び出すことはできません。
以上の性質によって、純粋関数は引数以外の外部の影響に左右されずに動作します。</p>

<p>ただし、<code>pure</code>な関数でも引数が配列型などの参照型であれば、その引数を通して関数の外部に影響を与える可能性があります。
このような<code>pure</code>の振る舞いについては、後の章で詳しく説明します。</p>
<div class="highlight"><pre><code class="language-d" data-lang="d"><span class="kt">int</span> <span class="n">globalValue</span><span class="p">;</span>

<span class="k">immutable</span> <span class="kt">int</span> <span class="n">imm</span><span class="p">;</span>
<span class="k">const</span> <span class="kt">int</span><span class="p">*</span> <span class="n">cptr</span><span class="p">;</span>

<span class="kt">void</span> <span class="n">foo</span><span class="p">(</span><span class="kt">int</span> <span class="n">x</span><span class="p">,</span> <span class="kt">int</span> <span class="n">y</span><span class="p">)</span> <span class="k">pure</span>
<span class="p">{</span>
    <span class="c1">//globalValue = x;          // NG</span>
                                <span class="c1">// グローバル変数の書き換えは不可</span>

    <span class="n">x</span> <span class="p">=</span> <span class="n">imm</span><span class="p">;</span>                    <span class="c1">// OK</span>
                                <span class="c1">// immutableなグローバル変数の読み込みは可能</span>

    <span class="c1">//x = *cptr;                // NG</span>
                                <span class="c1">// constなポインタは、ポインタ値はconstだが、値は変化するので、読み込み不可</span>

    <span class="k">static</span> <span class="kt">int</span> <span class="n">z</span><span class="p">;</span>
    <span class="c1">//z = x;                    // NG</span>
                                <span class="c1">// static変数の書き換えは不可</span>

    <span class="k">throw</span> <span class="k">new</span> <span class="n">Exception</span><span class="p">(</span><span class="s">&quot;例外はOK&quot;</span><span class="p">);</span>

    <span class="kt">int</span><span class="p">[]</span> <span class="n">arr</span> <span class="p">=</span> <span class="k">new</span> <span class="kt">int</span><span class="p">[</span><span class="n">x</span><span class="p">];</span>     <span class="c1">// newはOK</span>
<span class="p">}</span>
</code></pre></div>
<h3>例外を投げない関数<code>nothrow</code></h3>

<p>例外についてはまだ説明していませんが、例外とは、プログラムがある処理をしている最中に起こった異常や、その異常を知らせるメッセージのことです。
「例外を投げる」とは、「異常が発生したというメッセージを発行する」ということになります。
例外は<code>throw ex;</code>で投げることができ、<code>catch</code>されるまで関数を遡っていきます。
<code>main</code>関数までさかのぼり、最終的に<code>catch</code>されなければプログラムは終了します。</p>

<p>ToDo: <a href="exception.md">例外の章へ</a></p>

<p><code>nothrow</code>関数は、そんな例外を絶対に投げないことが静的に保証されている関数です。
また、例外は関数を貫いて伝搬するため、<code>nothrow</code>関数内では<code>nothrow</code>関数しか呼ぶことが出来ません。</p>
<div class="highlight"><pre><code class="language-d" data-lang="d"><span class="kt">void</span> <span class="n">bar</span><span class="p">(){}</span>                                <span class="c1">// nothrow関数でない</span>

<span class="kt">void</span> <span class="n">foo</span><span class="p">()</span> <span class="k">nothrow</span>
<span class="p">{</span>
    <span class="c1">//throw new Exception(&quot;exception&quot;);     // nothrow関数内では例外を投げれない</span>
    <span class="c1">//bar();                                // barはnothrow関数でないので、呼べない</span>
<span class="p">}</span>
</code></pre></div>
<p>例外を投げる可能性のある操作を関数内部に持っていても、その操作が<code>try</code>文中にあり、例外が関数外部にもれないのであれば構いません。</p>
<div class="highlight"><pre><code class="language-d" data-lang="d"><span class="kt">void</span> <span class="n">bar</span><span class="p">(){}</span>                                <span class="c1">// nothrow関数でない</span>

<span class="kt">void</span> <span class="n">foo</span><span class="p">()</span> <span class="k">nothrow</span>
<span class="p">{</span>
    <span class="k">try</span><span class="p">{</span>
        <span class="k">throw</span> <span class="k">new</span> <span class="n">Exception</span><span class="p">(</span><span class="s">&quot;exception:&quot;</span><span class="p">);</span>  <span class="c1">// tryの中にあるのでOK</span>
        <span class="n">bar</span><span class="p">();</span>                              <span class="c1">// 同上</span>
    <span class="p">}</span>
    <span class="k">catch</span><span class="p">(</span><span class="n">Exception</span> <span class="n">ex</span><span class="p">){}</span>
<span class="p">}</span>
</code></pre></div>
<p>ちなみに、整数の0除算や配列の範囲外参照, <code>assert</code>の失敗では、すべてエラーが投げられますが、これは例外ではないので、<code>nothrow</code>関数内でこれらの操作を行うことは可能です。</p>
<div class="highlight"><pre><code class="language-d" data-lang="d"><span class="kt">void</span> <span class="n">foo</span><span class="p">()</span> <span class="k">nothrow</span>
<span class="p">{</span>
    <span class="k">throw</span> <span class="k">new</span> <span class="n">Error</span><span class="p">(</span><span class="s">&quot;error&quot;</span><span class="p">);</span>               <span class="c1">// OK</span>
                                            <span class="c1">// 例外じゃなくてエラー</span>

    <span class="kt">int</span><span class="p">[]</span> <span class="n">arr</span><span class="p">;</span>
    <span class="k">auto</span> <span class="n">b</span> <span class="p">=</span> <span class="n">arr</span><span class="p">[</span><span class="mi">1</span><span class="p">];</span>                        <span class="c1">// エラーが投げられるが、例外でないのでOK</span>

    <span class="n">b</span> <span class="p">/=</span> <span class="mi">0</span><span class="p">;</span>                                 <span class="c1">// エラーが投げられるが、例外でないのでOK</span>
<span class="p">}</span>
</code></pre></div>
<h3>UDA(User Defined Attribute)</h3>

<p>ToDo: <a href="uda.md">UDAの章へ</a></p>

<h3><code>const</code>, <code>immutable</code>, <code>inout</code>, <code>abstract</code>, <code>final</code></h3>

<p>これらの属性は構造体<code>struct</code>やクラス<code>class</code>のメンバー関数でのみ使用することができます。</p>

<p>ToDo: <a href="union.md">共用体の章へ</a>
ToDo: <a href="struct.md">構造体の章へ</a>
ToDo: <a href="class.md">クラスの章へ</a></p>

<h3>ガベージコレクタが動かない関数<code>@nogc</code></h3>

<p>Dでは、言語仕様にガベージコレクタが含まれていますが、組み込みやゲームの開発などでは、ガベージコレクタが邪魔になる場合があります。
<code>@nogc</code>は、その関数内ではガベージコレクタが絶対起動しないということを保証します。</p>

<p>実行時にガベージコレクタが動かない関数であれば、<code>@nogc</code>属性を付加することで、<code>@nogc</code>関数となります。</p>

<p>この属性は、DMD v2.066 より追加されました。</p>
<div class="highlight"><pre><code class="language-d" data-lang="d"><span class="k">import</span> <span class="n">core</span><span class="p">.</span><span class="n">stdc</span><span class="p">.</span><span class="n">stdlib</span><span class="p">;</span>

<span class="c1">// この関数では、ガベージコレクタが動かない</span>
<span class="kt">void</span> <span class="n">fooNoGC</span><span class="p">()</span> <span class="nd">@nogc</span>
<span class="p">{</span>
    <span class="kt">int</span><span class="p">[</span><span class="mi">1024</span><span class="p">]</span> <span class="n">stack</span><span class="p">;</span>                <span class="c1">// stackのアロケーション</span>
    <span class="kt">int</span><span class="p">[]</span> <span class="n">slice</span> <span class="p">=</span> <span class="n">stack</span><span class="p">[</span><span class="mi">0</span> <span class="p">..</span> <span class="p">$/</span><span class="mi">2</span><span class="p">];</span>  <span class="c1">// スライス</span>

    <span class="c1">// Cヒープからの確保</span>
    <span class="kt">int</span><span class="p">*</span> <span class="n">p</span> <span class="p">=</span> <span class="k">cast</span><span class="p">(</span><span class="kt">int</span><span class="p">*)</span><span class="n">malloc</span><span class="p">(</span><span class="kt">int</span><span class="p">.</span><span class="n">sizeof</span> <span class="p">*</span> <span class="mi">1024</span><span class="p">);</span>
    <span class="k">if</span><span class="p">(!</span><span class="n">p</span><span class="p">)</span> <span class="k">return</span><span class="p">;</span>
    <span class="k">scope</span><span class="p">(</span><span class="n">exit</span><span class="p">)</span> <span class="p">{</span> <span class="n">free</span><span class="p">(</span><span class="n">p</span><span class="p">);</span> <span class="n">p</span> <span class="p">=</span> <span class="kc">null</span><span class="p">;</span> <span class="p">};</span>
<span class="p">}</span>
</code></pre></div>
<h2>関数オーバーロード(多重定義, overload)</h2>

<p>D言語の関数は、引数が違えば、同じ関数名の関数を宣言することができます。</p>

<p>たとえば、C言語には「データをフォーマット指定して文字列に書き込みを行う」関数が<code>stdio.h</code>に以下のように複数あります。
それぞれは引数の型だけがことなるだけで、それらの関数の意味はすべて同じです。
しかし、C言語には関数のオーバーロードという機能がないので、各関数の名前が被ってはいけないという言語仕様上の制約があります。
ですから、<code>sprintf</code>系の関数では、その引数に応じて、先頭に<code>v</code>や<code>n</code>を付けて呼び出す関数を区別してやる必要があります。</p>
<div class="highlight"><pre><code class="language-c" data-lang="c"><span class="c1">// Cでのsprintf系</span>
<span class="kt">int</span> <span class="nf">sprintf</span><span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="n">str</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">format</span><span class="p">,</span> <span class="p">...);</span>
<span class="kt">int</span> <span class="nf">snprintf</span><span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="n">str</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">n</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">format</span><span class="p">,</span> <span class="p">...);</span>
<span class="kt">int</span> <span class="nf">vsprintf</span><span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="n">str</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">format</span><span class="p">,</span> <span class="kt">va_list</span> <span class="n">arg</span><span class="p">);</span>
<span class="kt">int</span> <span class="nf">vsnprintf</span><span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="n">str</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">n</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">format</span><span class="p">,</span> <span class="kt">va_list</span> <span class="n">arg</span><span class="p">);</span>
</code></pre></div>
<p>逆に、関数オーバーロードの機能があるD言語では、これらの関数は次のように、すべて<code>sprintf</code>という関数名で宣言することが可能です。</p>
<div class="highlight"><pre><code class="language-d" data-lang="d"><span class="c1">// もし、Dでsprintf系をつくるならば</span>
<span class="kt">int</span> <span class="n">sprintf</span><span class="p">(</span><span class="kt">char</span><span class="p">*</span> <span class="n">str</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span><span class="p">*</span> <span class="n">format</span><span class="p">,</span> <span class="p">...);</span>
<span class="kt">int</span> <span class="n">sprintf</span><span class="p">(</span><span class="kt">char</span><span class="p">*</span> <span class="n">str</span><span class="p">,</span> <span class="nb">size_t</span> <span class="n">n</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span><span class="p">*</span> <span class="n">format</span><span class="p">,</span> <span class="p">...);</span>
<span class="kt">int</span> <span class="n">sprintf</span><span class="p">(</span><span class="kt">char</span><span class="p">*</span> <span class="n">str</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span><span class="p">*</span> <span class="n">format</span><span class="p">,</span> <span class="kt">void</span><span class="p">*</span> <span class="n">argptr</span><span class="p">,</span> <span class="n">TypeInfo</span><span class="p">[]</span> <span class="n">arguments</span><span class="p">);</span>
<span class="kt">int</span> <span class="n">sprintf</span><span class="p">(</span><span class="kt">char</span><span class="p">*</span> <span class="n">str</span><span class="p">,</span> <span class="nb">size_t</span> <span class="n">n</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span><span class="p">*</span> <span class="n">format</span><span class="p">,</span> <span class="kt">void</span><span class="p">*</span> <span class="n">argptr</span><span class="p">,</span> <span class="n">TypeInfo</span><span class="p">[]</span> <span class="n">arguments</span><span class="p">);</span>
</code></pre></div>
<p>呼び出すときは引数にもっともマッチした関数が呼ばれます。
「もっともマッチした関数」とは、以下の優先順位でもっとも高い関数です。</p>

<ol>
<li>完全にマッチしている</li>
<li><code>const</code>付きでマッチしている</li>
<li>暗黙の型変換によるマッチ</li>
<li>マッチしていない</li>
</ol>
<div class="highlight"><pre><code class="language-d" data-lang="d"><span class="k">import</span> <span class="n">std</span><span class="p">.</span><span class="n">stdio</span><span class="p">;</span>

<span class="kt">void</span> <span class="n">foo</span><span class="p">(</span><span class="kt">int</span><span class="p">){</span> <span class="n">writeln</span><span class="p">(</span><span class="s">&quot;int&quot;</span><span class="p">);</span> <span class="p">}</span>
<span class="kt">void</span> <span class="n">foo</span><span class="p">(</span><span class="k">in</span> <span class="kt">int</span><span class="p">){</span> <span class="n">writeln</span><span class="p">(</span><span class="s">&quot;in int&quot;</span><span class="p">);</span> <span class="p">}</span>      <span class="c1">// in は const scope のこと</span>

<span class="kt">void</span> <span class="n">bar</span><span class="p">(</span><span class="k">in</span> <span class="kt">int</span><span class="p">){</span> <span class="n">writeln</span><span class="p">(</span><span class="s">&quot;in int&quot;</span><span class="p">);</span> <span class="p">}</span>
<span class="kt">void</span> <span class="n">bar</span><span class="p">(</span><span class="kt">long</span><span class="p">){</span> <span class="n">writeln</span><span class="p">(</span><span class="s">&quot;long&quot;</span><span class="p">);</span> <span class="p">}</span>

<span class="kt">void</span> <span class="n">hoge</span><span class="p">(</span><span class="kt">float</span><span class="p">){</span> <span class="n">writeln</span><span class="p">(</span><span class="s">&quot;float&quot;</span><span class="p">);</span> <span class="p">}</span>
<span class="kt">void</span> <span class="n">hoge</span><span class="p">(</span><span class="kt">double</span><span class="p">){</span> <span class="n">writeln</span><span class="p">(</span><span class="s">&quot;double&quot;</span><span class="p">);</span> <span class="p">}</span>

<span class="kt">void</span> <span class="n">main</span><span class="p">()</span>
<span class="p">{</span>
    <span class="n">foo</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>                 <span class="c1">// int</span>
    <span class="n">foo</span><span class="p">(</span><span class="k">cast</span><span class="p">(</span><span class="k">const</span><span class="p">)</span><span class="mi">1</span><span class="p">);</span>      <span class="c1">// in int</span>

    <span class="n">bar</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>                 <span class="c1">// in int</span>
                            <span class="c1">// 暗黙変換よりもconstは優先される</span>
    <span class="n">bar</span><span class="p">(</span><span class="k">cast</span><span class="p">(</span><span class="kt">long</span><span class="p">)</span><span class="mi">1</span><span class="p">);</span>       <span class="c1">// long</span>

    <span class="n">hoge</span><span class="p">(</span><span class="mf">1.0L</span><span class="p">);</span>           <span class="c1">// コンパイルエラー:realはfloat, doubleの両方に等しく暗黙変換可能</span>
    <span class="cm">/*</span>
<span class="cm">    example.d(21): Error: function foo.hoge called with argument types:</span>
<span class="cm">        ((real))</span>
<span class="cm">    matches both:</span>
<span class="cm">        example.d(9): foo.hoge(float _param_0)</span>
<span class="cm">    and:</span>
<span class="cm">        example.d(10): foo.hoge(double _param_0)</span>
<span class="cm">    */</span>
<span class="p">}</span>
</code></pre></div>
<p>同一名称の関数が異なるモジュールに属している際には、コンパイラによる最適な関数の選択方法は複雑になります。
関数の呼び出しがあると、コンパイラはまずはモジュール毎にその関数の<b>オーバーロード集合</b>(overload set)を形成します。
次のステージでは、それぞれのモジュールでもっともマッチする関数を選択します。
前ステージでのマッチする関数の合計がただ一つの場合、つまりは、ただひとつのモジュールだけしかマッチしなければ、そのマッチした関数が呼ばれます。
そうでなければ(複数のモジュールでマッチしたのなら)、コンパイルエラーとなります。</p>
<div class="highlight"><pre><code class="language-d" data-lang="d"><span class="c1">// foo1.d</span>
<span class="k">import</span> <span class="n">std</span><span class="p">.</span><span class="n">stdio</span><span class="p">;</span>

<span class="kt">void</span> <span class="n">foo</span><span class="p">(</span><span class="kt">int</span><span class="p">){</span> <span class="n">writeln</span><span class="p">(</span><span class="s">&quot;foo1.foo(int)&quot;</span><span class="p">);</span> <span class="p">}</span>
<span class="kt">void</span> <span class="n">foo</span><span class="p">(</span><span class="k">in</span> <span class="kt">int</span><span class="p">){</span> <span class="n">writeln</span><span class="p">(</span><span class="s">&quot;foo1.foo(in int)&quot;</span><span class="p">);</span> <span class="p">}</span>
</code></pre></div><div class="highlight"><pre><code class="language-d" data-lang="d"><span class="c1">// foo2.d</span>
<span class="k">import</span> <span class="n">std</span><span class="p">.</span><span class="n">stdio</span><span class="p">;</span>

<span class="kt">void</span> <span class="n">foo</span><span class="p">(</span><span class="kt">long</span><span class="p">){</span> <span class="n">writeln</span><span class="p">(</span><span class="s">&quot;foo2.foo(long)&quot;</span><span class="p">);</span> <span class="p">}</span>
<span class="kt">void</span> <span class="n">foo</span><span class="p">(</span><span class="kt">real</span><span class="p">){</span> <span class="n">writeln</span><span class="p">(</span><span class="s">&quot;foo2.foo(real)&quot;</span><span class="p">);</span> <span class="p">}</span>
</code></pre></div><div class="highlight"><pre><code class="language-d" data-lang="d"><span class="c1">// main.d</span>

<span class="k">import</span> <span class="n">foo1</span><span class="p">,</span> <span class="n">foo2</span><span class="p">;</span>

<span class="kt">void</span> <span class="n">main</span><span class="p">()</span>
<span class="p">{</span>
    <span class="c1">//foo(1);       // Error: foo2.foo at foo2.d(4) conflicts with foo1.foo at foo1.d(4)</span>
                    <span class="c1">// モジュールfoo1ではfoo(int)が、foo2ではfoo(long)がマッチし、</span>
                    <span class="c1">// 結果的に2つ以上のモジュールでマッチしたのでエラー</span>

    <span class="n">foo</span><span class="p">(</span><span class="kt">long</span><span class="p">.</span><span class="n">max</span><span class="p">);</span>  <span class="c1">// foo2.foo(long)</span>
    <span class="n">foo</span><span class="p">(</span><span class="mf">1.0</span><span class="p">);</span>       <span class="c1">// foo2.foo(real)</span>
                    <span class="c1">// 上記2つともに、モジュールfoo2でのみマッチする</span>
<span class="p">}</span>
</code></pre></div>
<p>もし、<code>foo1</code>と<code>foo2</code>に分けられたオーバーロード集合を一つに結合したい場合には、次のように<code>alias</code>を使います。</p>
<div class="highlight"><pre><code class="language-d" data-lang="d"><span class="k">import</span> <span class="n">foo1</span><span class="p">,</span> <span class="n">foo2</span><span class="p">;</span>

<span class="c1">// モジュールfoo1とfoo2の、fooに関するオーバーロード集合を一つに結合する</span>
<span class="k">alias</span> <span class="n">foo</span> <span class="p">=</span> <span class="n">foo1</span><span class="p">.</span><span class="n">foo</span><span class="p">;</span>
<span class="k">alias</span> <span class="n">foo</span> <span class="p">=</span> <span class="n">foo2</span><span class="p">.</span><span class="n">foo</span><span class="p">;</span>

<span class="kt">void</span> <span class="n">main</span><span class="p">()</span>
<span class="p">{</span>
    <span class="n">foo</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>         <span class="c1">// foo1.foo(int)</span>
    <span class="n">foo</span><span class="p">(</span><span class="kt">long</span><span class="p">.</span><span class="n">max</span><span class="p">);</span>  <span class="c1">// foo2.foo(long)</span>
    <span class="n">foo</span><span class="p">(</span><span class="mf">1.0</span><span class="p">);</span>       <span class="c1">// foo2.foo(real)</span>
<span class="p">}</span>
</code></pre></div>
<p>オーバーロード集合を結合せずとも、明示的に所属するモジュールを指定してやることで解決します。</p>
<div class="highlight"><pre><code class="language-d" data-lang="d"><span class="k">import</span> <span class="n">foo1</span><span class="p">,</span> <span class="n">foo2</span><span class="p">;</span>

<span class="kt">void</span> <span class="n">main</span><span class="p">()</span>
<span class="p">{</span>
    <span class="n">foo1</span><span class="p">.</span><span class="n">foo</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>         <span class="c1">// foo1.foo(int)</span>
    <span class="n">foo2</span><span class="p">.</span><span class="n">foo</span><span class="p">(</span><span class="kt">long</span><span class="p">.</span><span class="n">max</span><span class="p">);</span>  <span class="c1">// foo2.foo(long)</span>
    <span class="n">foo2</span><span class="p">.</span><span class="n">foo</span><span class="p">(</span><span class="mf">1.0</span><span class="p">);</span>       <span class="c1">// foo2.foo(real)</span>
<span class="p">}</span>
</code></pre></div>
<h2>ローカル<code>static</code>変数</h2>

<p>関数内には<code>static</code>と付いた変数を宣言することができます。
静的変数は「その関数だけが触れるグローバル変数」となります。</p>
<div class="highlight"><pre><code class="language-d" data-lang="d"><span class="kt">void</span> <span class="n">foo</span><span class="p">()</span>
<span class="p">{</span>
    <span class="k">static</span> <span class="kt">int</span> <span class="n">cnt</span><span class="p">;</span>

    <span class="n">writefln</span><span class="p">(</span><span class="s">&quot;%s回目の呼び出し&quot;</span><span class="p">,</span> <span class="p">++</span><span class="n">cnt</span><span class="p">);</span>
<span class="p">}</span>


<span class="kt">void</span> <span class="n">main</span><span class="p">()</span>
<span class="p">{</span>
    <span class="n">foo</span><span class="p">();</span>          <span class="c1">// 1回目の呼び出し</span>
    <span class="n">foo</span><span class="p">();</span>          <span class="c1">// 2回目の呼び出し</span>
    <span class="n">foo</span><span class="p">();</span>          <span class="c1">// 3回目の呼び出し</span>
    <span class="n">foo</span><span class="p">();</span>          <span class="c1">// 4回目の呼び出し</span>
<span class="p">}</span>
</code></pre></div>
<p>ローカル<code>static</code>変数を初期化するには、初期化値がコンパイル時定数である必要があります。
つまり、実行時に決まるような値で初期化できません。
このような場合は<code>static bool firstCall</code>というような変数を用いて、初期化しましょう。</p>
<div class="highlight"><pre><code class="language-d" data-lang="d"><span class="nb">string</span> <span class="n">foo</span><span class="p">(</span><span class="nb">string</span> <span class="n">line</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">static</span> <span class="kt">bool</span> <span class="n">firstCall</span> <span class="p">=</span> <span class="kc">true</span><span class="p">;</span>       <span class="c1">// リテラルはコンパイル時定数</span>
    <span class="k">static</span> <span class="kt">int</span> <span class="n">hold</span><span class="cm">/* = line*/</span><span class="p">;</span>         <span class="c1">// ローカル変数や仮引数はコンパイル時定数ではない</span>

    <span class="c1">// 第一回目の関数呼び出しのときにのみ中の文が実行される</span>
    <span class="k">if</span><span class="p">(</span><span class="n">firstCall</span><span class="p">){</span>
        <span class="n">hold</span> <span class="p">=</span> <span class="n">line</span><span class="p">;</span>
        <span class="n">firstCall</span> <span class="p">=</span> <span class="p">!</span><span class="n">firstCall</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="k">return</span> <span class="n">hold</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div>
<p><a href="#Q5">Goto: 問題5 「Grand Total」</a><br>
<a href="#Q6">Goto: 問題6 「Tagged Grand Total」</a>  </p>

<h2>ネスト関数</h2>

<p>なんと関数内には関数を記述できます！
また、その関数は外側の関数のシンボルを参照することができます。
もし、ネスト関数が<code>static</code>であれば、その外部の関数の<code>static</code>なものしか参照できません。</p>
<div class="highlight"><pre><code class="language-d" data-lang="d"><span class="kt">void</span> <span class="n">main</span><span class="p">()</span>
<span class="p">{</span>
    <span class="kt">int</span> <span class="n">a</span><span class="p">;</span>
    <span class="k">static</span> <span class="kt">int</span> <span class="n">s</span><span class="p">;</span>

    <span class="kt">void</span> <span class="n">inc</span><span class="p">(){</span> <span class="p">++</span><span class="n">a</span><span class="p">;</span> <span class="p">}</span>

    <span class="k">static</span> <span class="kt">void</span> <span class="n">inc_static</span><span class="p">(){</span> <span class="p">++</span><span class="n">s</span><span class="p">;</span> <span class="p">}</span>    <span class="c1">// staticなものだけ触れる</span>

    <span class="n">writeln</span><span class="p">(</span><span class="n">a</span><span class="p">);</span>         <span class="c1">// 0</span>
    <span class="n">inc</span><span class="p">();</span>
    <span class="n">inc</span><span class="p">();</span>
    <span class="n">writeln</span><span class="p">(</span><span class="n">a</span><span class="p">);</span>         <span class="c1">// 2</span>
<span class="p">}</span>
</code></pre></div>
<h2>関数ポインタ</h2>

<p>関数を変数に代入して持ち運べたり、違う関数に渡せると嬉しくないですか？
実は、関数ポインタ型というデータ型が存在し、この型へ関数へのポインタを格納しておけば、関数への参照を持ち運ぶことができます。
関数ポインタの型は、<code>ReturnType function(ParameterList)</code>となります。</p>
<div class="highlight"><pre><code class="language-d" data-lang="d"><span class="kt">void</span> <span class="n">foo</span><span class="p">(</span><span class="kt">int</span> <span class="n">a</span><span class="p">){</span> <span class="n">writeln</span><span class="p">(</span><span class="s">&quot;foo !!!&quot;</span><span class="p">);</span> <span class="p">}</span>
<span class="kt">void</span> <span class="n">bar</span><span class="p">(</span><span class="kt">int</span> <span class="n">b</span><span class="p">){</span> <span class="n">writeln</span><span class="p">(</span><span class="s">&quot;bar !!!&quot;</span><span class="p">);</span> <span class="p">}</span>

<span class="kt">void</span> <span class="n">main</span><span class="p">()</span>
<span class="p">{</span>
    <span class="c1">// intを受け取る関数を参照する型</span>
    <span class="kt">void</span> <span class="k">function</span><span class="p">(</span><span class="kt">int</span><span class="p">)</span> <span class="n">fptr</span> <span class="p">=</span> <span class="p">&amp;</span><span class="n">foo</span><span class="p">;</span>

    <span class="n">fptr</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>                    <span class="c1">// foo !!!</span>

    <span class="n">fptr</span> <span class="p">=</span> <span class="p">&amp;</span><span class="n">bar</span><span class="p">;</span>
    <span class="n">fptr</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>                    <span class="c1">// bar !!!</span>
<span class="p">}</span>
</code></pre></div>
<p>関数ポインタを使用すれば、関数を値として扱えます。
そのため、条件によって実行する関数を変えたり、関数に関数を渡せたり、関数から関数を返すことも作成可能です。</p>
<div class="highlight"><pre><code class="language-d" data-lang="d"><span class="k">import</span> <span class="n">std</span><span class="p">.</span><span class="n">stdio</span><span class="p">;</span>

<span class="kt">int</span> <span class="n">sum</span><span class="p">(</span><span class="kt">int</span> <span class="n">a</span><span class="p">,</span> <span class="kt">int</span> <span class="n">b</span><span class="p">){</span> <span class="k">return</span> <span class="n">a</span> <span class="p">+</span> <span class="n">b</span><span class="p">;</span> <span class="p">}</span>
<span class="kt">int</span> <span class="n">prd</span><span class="p">(</span><span class="kt">int</span> <span class="n">a</span><span class="p">,</span> <span class="kt">int</span> <span class="n">b</span><span class="p">){</span> <span class="k">return</span> <span class="n">a</span> <span class="p">*</span> <span class="n">b</span><span class="p">;</span> <span class="p">}</span>


<span class="c1">/// std.algorithm.reduceと同じような関数</span>
<span class="kt">int</span> <span class="n">reduce</span><span class="p">(</span><span class="kt">int</span> <span class="n">ini</span><span class="p">,</span> <span class="kt">int</span><span class="p">[]</span> <span class="n">arr</span><span class="p">,</span> <span class="kt">int</span> <span class="k">function</span><span class="p">(</span><span class="kt">int</span><span class="p">,</span> <span class="kt">int</span><span class="p">)</span> <span class="n">f</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">while</span><span class="p">(</span><span class="n">arr</span><span class="p">.</span><span class="n">length</span><span class="p">){</span>
        <span class="n">ini</span> <span class="p">=</span> <span class="n">f</span><span class="p">(</span><span class="n">ini</span><span class="p">,</span> <span class="n">arr</span><span class="p">[</span><span class="mi">0</span><span class="p">]);</span>
        <span class="n">arr</span> <span class="p">=</span> <span class="n">arr</span><span class="p">[</span><span class="mi">1</span> <span class="p">..</span> <span class="p">$];</span>
    <span class="p">}</span>

    <span class="k">return</span> <span class="n">ini</span><span class="p">;</span>
<span class="p">}</span>


<span class="c1">// 状態stateによって、返す関数を変える関数</span>
<span class="kt">int</span> <span class="k">function</span><span class="p">(</span><span class="kt">int</span><span class="p">,</span> <span class="kt">int</span><span class="p">)</span> <span class="n">getFunc</span><span class="p">(</span><span class="kt">bool</span> <span class="n">state</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">if</span><span class="p">(!</span><span class="n">state</span><span class="p">)</span>      <span class="c1">// falseのとき</span>
        <span class="k">return</span> <span class="p">&amp;</span><span class="n">sum</span><span class="p">;</span>
    <span class="k">else</span>
        <span class="k">return</span> <span class="p">&amp;</span><span class="n">prd</span><span class="p">;</span>
<span class="p">}</span>


<span class="kt">void</span> <span class="n">main</span><span class="p">()</span>
<span class="p">{</span>
    <span class="n">writeln</span><span class="p">(</span><span class="n">reduce</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">],</span> <span class="p">&amp;</span><span class="n">sum</span><span class="p">));</span>     <span class="c1">// 10</span>
                                                <span class="c1">// 総和</span>

    <span class="n">writeln</span><span class="p">(</span><span class="n">reduce</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">],</span> <span class="p">&amp;</span><span class="n">prd</span><span class="p">));</span>     <span class="c1">// 24</span>
                                                <span class="c1">// 総乗</span>

    <span class="n">writeln</span><span class="p">(</span><span class="n">getFunc</span><span class="p">(</span><span class="kc">false</span><span class="p">)</span> <span class="p">==</span> <span class="p">&amp;</span><span class="n">sum</span><span class="p">);</span>
    <span class="n">writeln</span><span class="p">(</span><span class="n">getFunc</span><span class="p">(</span><span class="kc">true</span><span class="p">)</span> <span class="p">==</span> <span class="p">&amp;</span><span class="n">prd</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div>
<p>すべての関数に対して、<code>&amp;&lt;function&gt;</code>が関数ポインタを返すわけではありません。
非<code>static</code>なネスト関数やメンバ関数(メソッド)についてはデリゲートというものを返します。</p>

<h2>デリゲート<code>delegate</code></h2>

<p>関数ポインタを使えば、たしかに関数から関数を返すことは可能です。
では、引数<code>int a</code>を取り、「引数<code>int b</code>を取って、<code>a</code>と<code>b</code>の和を返す関数」を返す関数<code>accum</code>を作れるでしょうか？
つまり、次のようなコードを満たす関数です。</p>
<div class="highlight"><pre><code class="language-d" data-lang="d"><span class="c1">// accum関数は引数を一つ取って、関数を返す</span>
<span class="k">auto</span> <span class="n">func1</span> <span class="p">=</span> <span class="n">accum</span><span class="p">(</span><span class="mi">5</span><span class="p">);</span>
<span class="n">writeln</span><span class="p">(</span><span class="n">func1</span><span class="p">(</span><span class="mi">3</span><span class="p">));</span>          <span class="c1">// 8</span>
                            <span class="c1">// 5 + 3</span>

<span class="k">auto</span> <span class="n">func2</span> <span class="p">=</span> <span class="n">accum</span><span class="p">(</span><span class="mi">8</span><span class="p">);</span>
<span class="n">writeln</span><span class="p">(</span><span class="n">func2</span><span class="p">(</span><span class="mi">12</span><span class="p">));</span>         <span class="c1">// 20</span>
                            <span class="c1">// 12 + 8</span>

<span class="n">writeln</span><span class="p">(</span><span class="n">func1</span><span class="p">(</span><span class="mi">3</span><span class="p">));</span>          <span class="c1">// 8</span>
                            <span class="c1">// 5 + 3</span>
                            <span class="c1">// func1の状態は、func2に影響されない</span>
</code></pre></div>
<p>グローバル変数に最初の引数の値を保存すれば実現できそうですが、<code>func1</code>の状態が<code>func2</code>に影響されてしまします。</p>
<div class="highlight"><pre><code class="language-d" data-lang="d"><span class="k">import</span> <span class="n">std</span><span class="p">.</span><span class="n">stdio</span><span class="p">;</span>


<span class="kt">int</span> <span class="n">a</span><span class="p">;</span>  <span class="c1">// accumで、第一引数を保存する変数</span>


<span class="k">auto</span> <span class="n">accum</span><span class="p">(</span><span class="kt">int</span> <span class="n">a</span><span class="p">)</span>
<span class="p">{</span>
    <span class="c1">// グローバルなaにローカルなaを代入</span>
    <span class="p">.</span><span class="n">a</span> <span class="p">=</span> <span class="n">a</span><span class="p">;</span>

    <span class="c1">// accumImplへの関数ポインタを返す</span>
    <span class="k">return</span> <span class="p">&amp;</span><span class="n">accumImpl</span><span class="p">;</span>
<span class="p">}</span>


<span class="kt">int</span> <span class="n">accumImpl</span><span class="p">(</span><span class="kt">int</span> <span class="n">b</span><span class="p">)</span>
<span class="p">{</span>
    <span class="c1">// グローバルなaとローカルのbの和を返す</span>
    <span class="k">return</span> <span class="p">.</span><span class="n">a</span> <span class="p">+</span> <span class="n">b</span><span class="p">;</span>
<span class="p">}</span>


<span class="kt">void</span> <span class="n">main</span><span class="p">()</span>
<span class="p">{</span>
    <span class="c1">// accum関数は引数を一つ取って、関数を返す</span>
    <span class="k">auto</span> <span class="n">func1</span> <span class="p">=</span> <span class="n">accum</span><span class="p">(</span><span class="mi">5</span><span class="p">);</span>
    <span class="n">writeln</span><span class="p">(</span><span class="n">func1</span><span class="p">(</span><span class="mi">3</span><span class="p">));</span>          <span class="c1">// 8</span>
                                <span class="c1">// 5 + 3</span>

    <span class="k">auto</span> <span class="n">func2</span> <span class="p">=</span> <span class="n">accum</span><span class="p">(</span><span class="mi">8</span><span class="p">);</span>
    <span class="n">writeln</span><span class="p">(</span><span class="n">func2</span><span class="p">(</span><span class="mi">12</span><span class="p">));</span>         <span class="c1">// 20</span>
                                <span class="c1">// 8 + 12</span>

    <span class="n">writeln</span><span class="p">(</span><span class="n">func1</span><span class="p">(</span><span class="mi">3</span><span class="p">));</span>          <span class="c1">// 11</span>
                                <span class="c1">// 5 + 3 = 8 なのに、func2の影響を受けて、</span>
                                <span class="c1">// 8 + 3 = 11 になってしまった。</span>
<span class="p">}</span>
</code></pre></div>
<p>グローバル変数の代わりに<code>static</code>変数を使ってもこのような関数は作れないのですが、では関数のローカル変数を触れるネスト関数を作り、その関数ポインタを返すのはどうでしょう？この実装だと、仕様を満たす関数になります。</p>
<div class="highlight"><pre><code class="language-d" data-lang="d"><span class="k">auto</span> <span class="n">accum</span><span class="p">(</span><span class="kt">int</span> <span class="n">a</span><span class="p">)</span>
<span class="p">{</span>
    <span class="kt">int</span> <span class="n">accumImpl</span><span class="p">(</span><span class="kt">int</span> <span class="n">b</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="k">return</span> <span class="n">a</span> <span class="p">+</span> <span class="n">b</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="k">return</span> <span class="p">&amp;</span><span class="n">accumImpl</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div>
<p>実は、<code>accum</code>は関数ポインタを返すのではなくて、<b>デリゲート</b>(delegate)というものを返しています。
試しに、返り値の推論をやめて<code>int function(int) accum(int a)</code>と書けばコンパイルエラーになりますね。</p>
<div class="highlight"><pre><code class="language-text" data-lang="text">Error: cannot implicitly convert expression (&amp;accumImpl) of type int delegate(int b) to int function(int)
</code></pre></div>
<p>コンパイラがいうには、「<code>(&amp;accumImpl)</code>は<code>int delegate(int)</code>型であって、<code>int function(int)</code>型には暗黙変換できませんよ」ということなのです。
<code>int delegate(int)</code>型は<code>int</code>を受け取って<code>int</code>を返すデリゲート型のことです。</p>

<p>デリゲートは、関数ポインタと、それが作られた環境についての情報(スタックポインタ)を併せて持っています。
そのため、<code>accumImpl</code>から作られたデリゲートは<code>accum</code>の<code>a</code>の値を参照できるのです。
この<code>a</code>の寿命は、<code>accum</code>関数が終了しても継続し続け、<code>accumImpl</code>から作られたデリゲートや、そのデリゲートのコピーがすべて無くなったら、次のガベージコレクタの回収時に回収されます。<br>
<small>(このようなデリゲートをクロージャ(closure)と呼びます。)</small></p>

<p><code>accum</code>を2回呼び出し、その2つの返り値のデリゲートが持っているスタックポインタを比較すると、それらは異なります。
つまり、<code>accum</code>の環境(スタック)の複製をデリゲートは持ちます。
このような性質により、<code>accum</code>を何回呼び出したとしてもメモリがある限り、返されるデリゲートは独立します。</p>

<p>「<code>A</code>型を受け取り、<code>B</code>型を返すデリゲート」の型は<code>B delegate(A)</code>となります。</p>

<p>関数オブジェクト(関数ポインタや、<code>opCall</code>の定義
されている構造体やクラス)をデリゲートに変換したい場合には、<code>std.functional.toDelegate</code>を使います。</p>
<div class="highlight"><pre><code class="language-d" data-lang="d"><span class="k">import</span> <span class="n">std</span><span class="p">.</span><span class="n">functional</span><span class="p">;</span>

<span class="kt">int</span> <span class="n">foo</span><span class="p">(</span><span class="kt">int</span> <span class="n">a</span><span class="p">){</span> <span class="k">return</span> <span class="n">a</span><span class="p">;</span> <span class="p">}</span>

<span class="kt">void</span> <span class="n">main</span><span class="p">()</span>
<span class="p">{</span>
    <span class="kt">int</span> <span class="k">delegate</span><span class="p">(</span><span class="kt">int</span><span class="p">)</span> <span class="n">dlg</span> <span class="p">=</span> <span class="n">toDelegate</span><span class="p">(&amp;</span><span class="n">foo</span><span class="p">);</span>   <span class="c1">// 関数ポインタ -&gt; デリゲート</span>
    <span class="n">writeln</span><span class="p">(</span><span class="n">dlg</span><span class="p">(</span><span class="mi">3</span><span class="p">));</span>                            <span class="c1">// 3</span>
<span class="p">}</span>
</code></pre></div>
<p><a href="#Q7">Goto: 問題7 「カウンター」</a>  </p>

<h2>関数のリテラルとラムダ</h2>

<p>先の例では、関数内にネスト関数を宣言し、そのネスト関数から作られるデリゲートを返していました。
しかし、関数(関数ポインタやデリゲート)がリテラルとしてソースコード中に表現できるなら、わざわざネスト関数を宣言する必要はありませんね。</p>

<p>今回は先ほどの<code>accum</code>をなるべく短く実装していきましょう。
ネスト関数を使った<code>accum</code>を以下にもう一度示しておきます。</p>
<div class="highlight"><pre><code class="language-d" data-lang="d"><span class="kt">int</span> <span class="k">delegate</span><span class="p">(</span><span class="kt">int</span><span class="p">)</span> <span class="n">accum</span><span class="p">(</span><span class="kt">int</span> <span class="n">a</span><span class="p">)</span>
<span class="p">{</span>
    <span class="kt">int</span> <span class="n">accumImpl</span><span class="p">(</span><span class="kt">int</span> <span class="n">b</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="k">return</span> <span class="n">a</span> <span class="p">+</span> <span class="n">b</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="k">return</span> <span class="p">&amp;</span><span class="n">accumImpl</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div>
<p>まず、<code>accumImpl</code>をリテラルで表現してみると次のようになります。</p>
<div class="highlight"><pre><code class="language-d" data-lang="d"><span class="kt">int</span> <span class="k">delegate</span><span class="p">(</span><span class="kt">int</span><span class="p">)</span> <span class="n">accum</span><span class="p">(</span><span class="kt">int</span> <span class="n">a</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">return</span> <span class="k">delegate</span> <span class="kt">int</span><span class="p">(</span><span class="kt">int</span> <span class="n">b</span><span class="p">){</span> <span class="k">return</span> <span class="n">a</span> <span class="p">+</span> <span class="n">b</span><span class="p">;</span> <span class="p">};</span>
<span class="p">}</span>
</code></pre></div>
<p>行数が極端に減りましたね。
もし、関数ポインタを返したいなら、<code>delegate</code>を<code>function</code>にしますが、関数ポインタでは外部の環境(<code>a</code>)へアクセスできないので、今回の場合は関数ポインタにできません。</p>

<p>リテラル表現では、<code>delegate</code>や返り値の<code>int</code>を省くことができます。
すると、次のようにさらに短くなります。</p>
<div class="highlight"><pre><code class="language-d" data-lang="d"><span class="kt">int</span> <span class="k">delegate</span><span class="p">(</span><span class="kt">int</span><span class="p">)</span> <span class="n">accum</span><span class="p">(</span><span class="kt">int</span> <span class="n">a</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">return</span> <span class="p">(</span><span class="kt">int</span> <span class="n">b</span><span class="p">){</span> <span class="k">return</span> <span class="n">a</span> <span class="p">+</span> <span class="n">b</span><span class="p">;</span> <span class="p">}</span>
<span class="p">}</span>
</code></pre></div>
<p>このようなリテラルの場合には、関数ポインタかデリゲートかどうかが推論されます。
今回の場合には、外部の<code>a</code>をリテラル内で触っているので、もちろんデリゲートになります。</p>

<p>さらに、ラムダという記法を用いると、もっと短くなります。</p>
<div class="highlight"><pre><code class="language-d" data-lang="d"><span class="kt">int</span> <span class="k">delegate</span><span class="p">(</span><span class="kt">int</span><span class="p">)</span> <span class="n">accum</span><span class="p">(</span><span class="kt">int</span> <span class="n">a</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">return</span> <span class="p">(</span><span class="kt">int</span> <span class="n">b</span><span class="p">)</span> <span class="p">=&gt;</span> <span class="n">a</span> <span class="p">+</span> <span class="n">b</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div>
<p>さて、最終の仕上げですが、引数の型も推論してもらいましょう。</p>
<div class="highlight"><pre><code class="language-d" data-lang="d"><span class="kt">int</span> <span class="k">delegate</span><span class="p">(</span><span class="kt">int</span><span class="p">)</span> <span class="n">accum</span><span class="p">(</span><span class="kt">int</span> <span class="n">a</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">return</span> <span class="n">b</span> <span class="p">=&gt;</span> <span class="n">a</span> <span class="p">+</span> <span class="n">b</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div>
<p>おまけとして、<code>accum</code>をもっと短くすると、次のような面白い書き方になります。</p>
<div class="highlight"><pre><code class="language-d" data-lang="d"><span class="k">enum</span> <span class="n">accum</span> <span class="p">=</span> <span class="p">(</span><span class="kt">int</span> <span class="n">a</span><span class="p">)</span> <span class="p">=&gt;</span> <span class="p">(</span><span class="kt">int</span> <span class="n">b</span><span class="p">)</span> <span class="p">=&gt;</span> <span class="n">a</span> <span class="p">+</span> <span class="n">b</span><span class="p">;</span>
</code></pre></div>
<p>もっとも短い関数を表すリテラルは<code>{}</code>でしょう。
次いで<code>{;}</code>、<code>(){}</code>になります。</p>
<div class="highlight"><pre><code class="language-d" data-lang="d"><span class="kt">void</span> <span class="k">function</span><span class="p">()</span> <span class="n">f1</span> <span class="p">=</span> <span class="p">{},</span>
                <span class="n">f2</span> <span class="p">=</span> <span class="p">{;},</span>
                <span class="n">f3</span> <span class="p">=</span> <span class="p">(){};</span>

<span class="kt">void</span> <span class="k">delegate</span><span class="p">()</span> <span class="n">d1</span> <span class="p">=</span> <span class="p">{},</span>
                <span class="n">d2</span> <span class="p">=</span> <span class="p">{;},</span>
                <span class="n">d3</span> <span class="p">=</span> <span class="p">(){};</span>
</code></pre></div>
<p>ラムダでも<code>function</code>や<code>delegate</code>の指定ができます。</p>
<div class="highlight"><pre><code class="language-d" data-lang="d"><span class="kt">int</span> <span class="k">delegate</span><span class="p">(</span><span class="kt">int</span><span class="p">)</span> <span class="n">accum</span><span class="p">(</span><span class="kt">int</span> <span class="n">a</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">return</span> <span class="k">delegate</span> <span class="p">(</span><span class="kt">int</span> <span class="n">b</span><span class="p">)</span> <span class="p">=&gt;</span> <span class="n">a</span> <span class="p">+</span> <span class="n">b</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div>
<p><code>pure</code>や<code>nothrow</code>, <code>@safe</code>などの関数属性は、リテラル表現では推論されますが、次のように指定することも可能です。</p>
<div class="highlight"><pre><code class="language-d" data-lang="d"><span class="kt">int</span> <span class="k">delegate</span><span class="p">(</span><span class="kt">int</span><span class="p">)</span> <span class="n">accum</span><span class="p">(</span><span class="kt">int</span> <span class="n">a</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">return</span> <span class="k">delegate</span> <span class="kt">int</span><span class="p">(</span><span class="kt">int</span> <span class="n">b</span><span class="p">)</span> <span class="k">nothrow</span> <span class="nd">@safe</span> <span class="p">{</span> <span class="k">return</span> <span class="n">a</span> <span class="p">+</span> <span class="n">b</span><span class="p">;</span> <span class="p">};</span>
    <span class="k">return</span> <span class="k">delegate</span> <span class="p">(</span><span class="kt">int</span> <span class="n">b</span><span class="p">)</span> <span class="k">nothrow</span> <span class="nd">@safe</span> <span class="p">{</span> <span class="k">return</span> <span class="n">a</span> <span class="p">+</span> <span class="n">b</span><span class="p">;</span> <span class="p">};</span>
    <span class="k">return</span> <span class="p">(</span><span class="kt">int</span> <span class="n">b</span><span class="p">)</span> <span class="k">nothrow</span> <span class="nd">@safe</span> <span class="p">{</span> <span class="k">return</span> <span class="n">a</span> <span class="p">+</span> <span class="n">b</span><span class="p">;</span> <span class="p">};</span>
    <span class="k">return</span> <span class="p">(</span><span class="kt">int</span> <span class="n">b</span><span class="p">)</span> <span class="k">nothrow</span> <span class="nd">@safe</span> <span class="p">=&gt;</span> <span class="n">a</span> <span class="p">+</span> <span class="n">b</span><span class="p">;</span>
    <span class="k">return</span> <span class="p">(</span><span class="n">b</span><span class="p">)</span> <span class="k">nothrow</span> <span class="nd">@safe</span> <span class="p">=&gt;</span> <span class="n">a</span> <span class="p">+</span> <span class="n">b</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div>
<p>セーフ関数の中でメモリセーフでない関数や機能を使いたい場合には、<code>@trusted</code>付きのリテラルを使うのが習慣のようです。</p>
<div class="highlight"><pre><code class="language-d" data-lang="d"><span class="kt">int</span> <span class="n">unsafe</span><span class="p">();</span>           <span class="c1">// セーフでない操作</span>

<span class="kt">void</span> <span class="n">foo</span><span class="p">()</span> <span class="cm">/*@safe*/</span>    <span class="c1">// 関数全体でみるとメモリ安全なのに、unsafeがあるから@safeになれない</span>
<span class="p">{</span>
    <span class="c1">//... unsafeの操作がメモリ安全になるような操作</span>

    <span class="k">auto</span> <span class="n">a</span> <span class="p">=</span> <span class="n">unsafe</span><span class="p">();</span>

    <span class="c1">//... unsafeの操作がメモリ安全になるような操作</span>
<span class="p">}</span>


<span class="kt">void</span> <span class="n">bar</span><span class="p">()</span> <span class="nd">@safe</span>        <span class="c1">// メモリ安全でない操作を行ってても、関数全体でみればメモリ安全だからOK</span>
<span class="p">{</span>
    <span class="c1">//... unsafeの操作がメモリ安全になるような操作</span>

    <span class="k">auto</span> <span class="n">a</span> <span class="p">=</span> <span class="p">()</span> <span class="nd">@trusted</span> <span class="p">=&gt;</span> <span class="n">unsafe</span><span class="p">();</span>

    <span class="c1">//... unsafeの操作がメモリ安全になるような操作</span>
<span class="p">}</span>
</code></pre></div>
<p><a href="#Q8">Goto: 問題8 「関数型スタイルなD」</a>  </p>

<h2>UFCS(Uniform Function Call Syntax)</h2>

<p>関数は通常<code>func(a, b, c)</code>のように呼び出しますが、UFCSという糖衣構文を使うことで、<code>a.func(b, c)</code>というように、<code>func</code>が<code>a</code>のメンバ関数であるかのように記述できます。
たとえば、<code>std.conv.to</code>は、様々な型から他の型への変換を提供しますが、<code>to!string(a)</code>と書くよりも、<code>a.to!string()</code>の方がより英文みたいになってわかりやすくなります。
さらに、<code>f1(f2(f3(a)))</code>と書くよりも、<code>a.f3().f2().f1()</code>と書くほうが、<code>a</code>がどのような順番でどのような処理を受けるかがすぐにわかります。</p>

<p>スライスがレンジとして機能する理由は、UFCSによって<code>std.array</code>の関数が<code>arr.front</code>, <code>arr.popFront()</code>, <code>arr.empty</code>というように呼び出せるからです。</p>

<p>もちろん、<code>a.f()</code>の<code>()</code>はプロパティの記法によって省略できるので、<code>a.f3.f2.f1</code>とも書けます。
素晴らしいですね。</p>
<div class="highlight"><pre><code class="language-d" data-lang="d"><span class="k">import</span> <span class="n">std</span><span class="p">.</span><span class="n">algorithm</span><span class="p">;</span>
<span class="k">import</span> <span class="n">std</span><span class="p">.</span><span class="n">array</span><span class="p">;</span>
<span class="k">import</span> <span class="n">std</span><span class="p">.</span><span class="n">random</span><span class="p">;</span>
<span class="k">import</span> <span class="n">std</span><span class="p">.</span><span class="n">range</span><span class="p">;</span>
<span class="k">import</span> <span class="n">std</span><span class="p">.</span><span class="n">stdio</span><span class="p">;</span>


<span class="kt">void</span> <span class="n">main</span><span class="p">()</span>
<span class="p">{</span>
    <span class="k">auto</span> <span class="n">gen</span> <span class="p">=</span> <span class="n">Random</span><span class="p">(</span><span class="n">unpredictableSeed</span><span class="p">),</span>   <span class="c1">// 乱数生成器を作る</span>
         <span class="n">r</span> <span class="p">=</span> <span class="n">iota</span><span class="p">(</span><span class="mi">100</span><span class="p">).</span><span class="n">randomCover</span><span class="p">(</span><span class="n">gen</span><span class="p">);</span>    <span class="c1">// 0 ~ 99までをランダムな順番にする。</span>

    <span class="c1">// ランダムに並んだ0 ~ 99のうち、偶数のみを抜き取り(filter!&quot;!(a&amp;1)&quot;), 文字列に変換(map!&quot;a.to!string()&quot;)して、それを表示</span>
    <span class="n">writeln</span><span class="p">(</span><span class="n">r</span><span class="p">.</span><span class="n">filter</span><span class="p">!</span><span class="s">&quot;!(a&amp;1)&quot;</span><span class="p">().</span><span class="n">map</span><span class="p">!</span><span class="s">&quot;a.to!string()&quot;</span><span class="p">());</span>


    <span class="kt">int</span> <span class="n">a</span> <span class="p">=</span> <span class="mi">5</span><span class="p">;</span>

    <span class="c1">// 狂気の如く連ねることも可能</span>
    <span class="n">a</span><span class="p">.</span><span class="n">identity</span><span class="p">.</span><span class="n">identity</span><span class="p">.</span><span class="n">identity</span><span class="p">.</span><span class="n">identity</span><span class="p">.</span><span class="n">identity</span><span class="p">.</span><span class="n">identity</span><span class="p">.</span><span class="n">identity</span><span class="p">.</span><span class="n">writeln</span><span class="p">;</span>
<span class="p">}</span>


<span class="c1">// そのまま返す関数</span>
<span class="k">auto</span> <span class="k">ref</span> <span class="n">T</span> <span class="n">identity</span><span class="p">(</span><span class="n">T</span><span class="p">)(</span><span class="k">auto</span> <span class="k">ref</span> <span class="n">T</span> <span class="n">a</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">return</span> <span class="n">a</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div>
<h2>CTFE(Compile Time Function Execution)</h2>

<p>関数は、ある程度の条件を満たせばコンパイル時に実行することができます。
コンパイル時とは、そのままの意味で、実行時ではなくてコンパイルしている段階ということです。
C++のテンプレートを用いたテンプレートメタプログラミング(TMP)や、<code>constexpr</code>を使用した経験がある人にとっては、D言語のCTFEは素晴らしい機能だとわかるでしょう。
コンパイル時プログラミングの経験がない人にとっては、コンパイル時に関数が走ってなにが嬉しいのだろうと思うでしょう。</p>

<p>もし、定数を事前に(コンパイル時に)計算できるなら？
もし、コンパイル時に関数がプログラムを生成してくれたら？</p>

<p>D言語では、CTFE以外にも快適なコンパイル時プログラミングを支援する機能が揃っています。</p>

<p>さて、話はCTFEに戻って、関数がCTFEableであるためには、以下の制約を満たす必要があります。
これらの制約はそのうち緩和される可能性があります。</p>

<ul>
<li>関数本体がD言語のソースコードとしてある</li>
<li>関数の中で実行する式や文では以下の操作は行えない(実行されない式や文が、以下の操作を行うかもしれなくても、OK)

<ul>
<li>グローバル変数や、ローカルstatic変数の参照</li>
<li>インラインアセンブラ(<code>asm</code>文)</li>
<li>プラットフォーム依存なキャスト(<code>int[]</code>から<code>float[]</code>や、エンディアン依存なキャスト)</li>
<li>CTFEableでない関数の呼び出し</li>
<li><code>delete</code>文</li>
</ul></li>
</ul>

<p>特別なシンボルとして<code>__ctfe</code>というものがあり、CTFE時には<code>true</code>となり、実行時には<code>false</code>となります。</p>
<div class="highlight"><pre><code class="language-d" data-lang="d"><span class="k">import</span> <span class="n">std</span><span class="p">.</span><span class="n">regex</span><span class="p">;</span>
<span class="k">import</span> <span class="n">std</span><span class="p">.</span><span class="n">stdio</span><span class="p">;</span>


<span class="k">pragma</span><span class="p">(</span><span class="n">msg</span><span class="p">,</span> <span class="n">ctEvaluated</span><span class="p">());</span>                     <span class="c1">// true</span>


<span class="c1">/// コンパイル時と、実行時で値が変わる関数。trueならコンパイルに評価された</span>
<span class="kt">bool</span> <span class="n">ctEvaluated</span><span class="p">()</span>
<span class="p">{</span>
    <span class="k">if</span><span class="p">(!</span><span class="n">__ctfe</span><span class="p">){</span>
        <span class="kt">int</span><span class="p">[]</span> <span class="n">arr</span> <span class="p">=</span> <span class="k">new</span> <span class="kt">int</span><span class="p">[</span><span class="mi">10</span><span class="p">];</span>
        <span class="k">delete</span> <span class="n">arr</span><span class="p">;</span>                 <span class="c1">// コンパイル時には絶対に実行されないのでOK</span>
    <span class="p">}</span>

    <span class="k">return</span> <span class="n">__ctfe</span><span class="p">;</span>
<span class="p">}</span>


<span class="kt">void</span> <span class="n">main</span><span class="p">()</span>
<span class="p">{</span>
    <span class="k">enum</span> <span class="n">enumValue</span> <span class="p">=</span> <span class="n">ctEvaluated</span><span class="p">();</span>
    <span class="k">immutable</span> <span class="n">immValue</span> <span class="p">=</span> <span class="n">ctEvaluated</span><span class="p">();</span>
    <span class="k">const</span> <span class="n">cntValue</span> <span class="p">=</span> <span class="n">ctEvaluated</span><span class="p">();</span>
    <span class="kt">bool</span> <span class="n">mutValue</span> <span class="p">=</span> <span class="n">ctEvaluated</span><span class="p">();</span>

    <span class="k">static</span> <span class="n">staticValue</span> <span class="p">=</span> <span class="n">ctEvaluated</span><span class="p">();</span>

    <span class="n">writeln</span><span class="p">(</span><span class="s">&quot;enum:          &quot;</span><span class="p">,</span> <span class="n">enumValue</span><span class="p">);</span>      <span class="c1">// true</span>
    <span class="n">writeln</span><span class="p">(</span><span class="s">&quot;immutable:     &quot;</span><span class="p">,</span> <span class="n">immValue</span><span class="p">);</span>       <span class="c1">// false</span>
    <span class="n">writeln</span><span class="p">(</span><span class="s">&quot;const:         &quot;</span><span class="p">,</span> <span class="n">cntValue</span><span class="p">);</span>       <span class="c1">// false</span>
    <span class="n">writeln</span><span class="p">(</span><span class="s">&quot;local mutable: &quot;</span><span class="p">,</span> <span class="n">mutValue</span><span class="p">);</span>       <span class="c1">// false</span>
    <span class="n">writeln</span><span class="p">(</span><span class="s">&quot;local static:  &quot;</span><span class="p">,</span> <span class="n">staticValue</span><span class="p">);</span>    <span class="c1">// true</span>
<span class="p">}</span>
</code></pre></div>
<h2>問題</h2>

<p><a href="/dmanual/answer#function">解答</a></p>

<ul>
<li><p><a name = "Q1">問題1 「readIntを実装しよう」</a>  </p>

<p>ユーザーが入力する数字を読み取って、<code>int</code>型で返す関数<code>readInt</code>を書いてください。
<code>readInt</code>の引数や返り値の型は以下のとおりです。</p>
<div class="highlight"><pre><code class="language-d" data-lang="d"><span class="kt">int</span> <span class="n">readInt</span><span class="p">();</span>
</code></pre></div>
<p>ヒント  </p>

<ul>
<li><code>std.conv.to!int</code><br></li>
<li><code>std.stdio.readln</code><br></li>
<li><code>std.string.chomp</code><br></li>
</ul></li>
<li><p><a name = "Q2">問題2 「sumを実装しよう」</a>  </p>

<p>配列<code>int[]</code>を受け取って、その総和を返す関数<code>sum</code>を書いてください。
<code>sum</code>の引数や戻り値の型は以下のとおりです。</p>
<div class="highlight"><pre><code class="language-d" data-lang="d"><span class="kt">int</span> <span class="n">sum</span><span class="p">(</span><span class="kt">int</span><span class="p">[]);</span>
</code></pre></div></li>
<li><p><a name = "Q3">問題3 「コンパイルできない！」</a></p>

<p>次のプログラムをコンパイルしてみると、<code>Deprecation: non-final switch statement without a default is deprecated</code>というメッセージと共にコンパイルエラー
となってしまいます。
エラー文を読んでみると、9行目の普通の<code>switch</code>文で、<code>default</code>が抜けているようです。
<code>idx</code>の値は<code>1, 2, 3</code>しか受け取らないと仮定し、すべての間違いを修正して、コンパイルできるようにしてください。</p>
<div class="highlight"><pre><code class="language-d" data-lang="d"><span class="k">import</span> <span class="n">std</span><span class="p">.</span><span class="n">stdio</span><span class="p">;</span>

<span class="kt">int</span> <span class="n">g1</span> <span class="p">=</span> <span class="mi">1</span><span class="p">,</span>
    <span class="n">g2</span> <span class="p">=</span> <span class="mi">10</span><span class="p">,</span>
    <span class="n">g3</span> <span class="p">=</span> <span class="mi">20</span><span class="p">;</span>

<span class="kt">int</span> <span class="n">getGlobalValue</span><span class="p">(</span><span class="nb">size_t</span> <span class="n">idx</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">switch</span><span class="p">(</span><span class="n">idx</span><span class="p">){</span>
        <span class="k">case</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">g1</span><span class="p">;</span>

        <span class="k">case</span> <span class="mi">2</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">g2</span><span class="p">;</span>

        <span class="k">case</span> <span class="mi">3</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">g3</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="n">main</span><span class="p">()</span>
<span class="p">{</span>
    <span class="n">writeln</span><span class="p">(</span><span class="n">getGlobalValue</span><span class="p">(</span><span class="mi">1</span><span class="p">));</span>
    <span class="n">writeln</span><span class="p">(</span><span class="n">getGlobalValue</span><span class="p">(</span><span class="mi">10</span><span class="p">));</span>
    <span class="n">writeln</span><span class="p">(</span><span class="n">getGlobalValue</span><span class="p">(</span><span class="mi">20</span><span class="p">));</span>
<span class="p">}</span>
</code></pre></div></li>
<li><p><a name = "Q4">問題4 「helpメッセージを表示せよ」</a></p>

<p>コンソールでコマンドを叩くときに、コマンドライン引数に<code>-h</code>とか<code>--help</code>を入れると、そのコマンドに対するメッセージがだいたい出力されますよね。
試しに<code>dmd --help</code>と打ってみると、dmdのコマンド引数の一覧が出力されると思います。(<code>dmd</code>の場合は、<code>dmd</code>だけで表示されるのですが)</p>

<p>以下に示すプログラムは、<code>add --a=12 --b=13</code>というように呼び出すと<code>12 + 13 = 15</code>と表示されるプログラムです。
また、<code>getopt(...);</code>後の変数<code>h_sw</code>には、コマンド引数に<code>-h</code>や<code>--help</code>が出現したかどうかが入っています。
(出現したら<code>true</code>)</p>

<p>このプログラムを少し書き換えて、<code>-h</code>や<code>--help</code>がコマンド引数に現れた場合には<code>writeln(appInfo);</code>をして即座にプログラムが終了するようにしてください。</p>
<div class="highlight"><pre><code class="language-d" data-lang="d"><span class="k">import</span> <span class="n">std</span><span class="p">.</span><span class="n">getopt</span><span class="p">;</span>
<span class="k">import</span> <span class="n">std</span><span class="p">.</span><span class="n">stdio</span><span class="p">;</span>

<span class="k">immutable</span> <span class="n">appInfo</span> <span class="p">=</span> <span class="s">`example:</span>
<span class="s">$ add --a=12 --b=13</span>
<span class="s">a + b = 25</span>

<span class="s">$ add --b=1, --a=3</span>
<span class="s">a + b = 4</span>
<span class="s">`</span><span class="p">;</span>

<span class="kt">void</span> <span class="n">main</span><span class="p">(</span><span class="nb">string</span><span class="p">[]</span> <span class="n">args</span><span class="p">)</span>
<span class="p">{</span>
    <span class="kt">int</span> <span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">;</span>
    <span class="kt">bool</span> <span class="n">h_sw</span><span class="p">;</span>              <span class="c1">// argsに-h, --helpが出現したかどうか</span>

    <span class="n">getopt</span><span class="p">(</span><span class="n">args</span><span class="p">,</span>
        <span class="s">&quot;a&quot;</span><span class="p">,</span> <span class="p">&amp;</span><span class="n">a</span><span class="p">,</span>
        <span class="s">&quot;b&quot;</span><span class="p">,</span> <span class="p">&amp;</span><span class="n">b</span><span class="p">,</span>
        <span class="s">&quot;h|help&quot;</span><span class="p">,</span> <span class="p">&amp;</span><span class="n">h_sw</span><span class="p">);</span>

    <span class="n">writeln</span><span class="p">(</span><span class="s">&quot;a + b = &quot;</span><span class="p">,</span> <span class="n">a</span> <span class="p">+</span> <span class="n">b</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div></li>
<li><p><a name = "Q5">問題5 「Grand Total」</a></p>

<p>関数を呼び出す毎に過去と今の<code>int</code>型引数の総和を返す関数<code>gt</code>を作ってください。
つまり、次のような関数です。</p>
<div class="highlight"><pre><code class="language-d" data-lang="d"><span class="n">writeln</span><span class="p">(</span><span class="n">gt</span><span class="p">(</span><span class="mi">10</span><span class="p">));</span>            <span class="c1">// 10</span>
<span class="n">writeln</span><span class="p">(</span><span class="n">gt</span><span class="p">(</span><span class="mi">1</span><span class="p">));</span>             <span class="c1">// 11</span>
<span class="n">writeln</span><span class="p">(</span><span class="n">gt</span><span class="p">(</span><span class="mi">9</span><span class="p">));</span>             <span class="c1">// 20</span>
<span class="n">writeln</span><span class="p">(</span><span class="n">gt</span><span class="p">(</span><span class="mi">8</span><span class="p">));</span>             <span class="c1">// 28</span>

<span class="n">writeln</span><span class="p">(</span><span class="n">gt</span><span class="p">(</span><span class="mi">5</span><span class="p">,</span> <span class="kc">true</span><span class="p">));</span>       <span class="c1">// 5    第二引数をtrueにすると、0になる</span>
<span class="n">writeln</span><span class="p">(</span><span class="n">gt</span><span class="p">(</span><span class="mi">10</span><span class="p">));</span>            <span class="c1">// 10</span>
</code></pre></div></li>
<li><p><a name = "Q6">問題6 「Tagged Grand Total」</a></p>

<p><a href="#Q5">Q5</a>とほとんど同じですが、今回の関数は新たにもう一つ引数として<code>string</code>型をとります。
この引数<code>string</code>を「タグ」と呼ぶことにしましょう。
<code>taggedGt</code>関数を作ってもらうわけですが、先ほどの<code>gt</code>は関数<code>gt</code>1つにつき、同時に合計が計算できるのは1つでした。
<code>taggedGt</code>では、タグを指定することで、同時に複数の合計を計算できるようにしてください。</p>
<div class="highlight"><pre><code class="language-d" data-lang="d"><span class="n">writeln</span><span class="p">(</span><span class="n">taggedGt</span><span class="p">(</span><span class="s">&quot;A&quot;</span><span class="p">,</span> <span class="mi">10</span><span class="p">));</span>             <span class="c1">// 10</span>
<span class="n">writeln</span><span class="p">(</span><span class="n">taggedGt</span><span class="p">(</span><span class="s">&quot;B&quot;</span><span class="p">,</span> <span class="mi">1</span><span class="p">));</span>              <span class="c1">// 1</span>
<span class="n">writeln</span><span class="p">(</span><span class="n">taggedGt</span><span class="p">(</span><span class="s">&quot;C&quot;</span><span class="p">,</span> <span class="mi">3</span><span class="p">));</span>              <span class="c1">// 3</span>

<span class="n">writeln</span><span class="p">(</span><span class="n">taggedGt</span><span class="p">(</span><span class="s">&quot;A&quot;</span><span class="p">,</span> <span class="mi">100</span><span class="p">));</span>            <span class="c1">// 110</span>
<span class="n">writeln</span><span class="p">(</span><span class="n">taggedGt</span><span class="p">(</span><span class="s">&quot;B&quot;</span><span class="p">,</span> <span class="mi">10</span><span class="p">));</span>             <span class="c1">// 11</span>
<span class="n">writeln</span><span class="p">(</span><span class="n">taggedGt</span><span class="p">(</span><span class="s">&quot;C&quot;</span><span class="p">,</span> <span class="mi">3</span><span class="p">));</span>              <span class="c1">// 6</span>

<span class="n">writeln</span><span class="p">(</span><span class="n">taggedGt</span><span class="p">(</span><span class="s">&quot;A&quot;</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="kc">true</span><span class="p">));</span>        <span class="c1">// 3    第3引数がtrueでクリア</span>

<span class="n">writeln</span><span class="p">(</span><span class="n">taggedGt</span><span class="p">(</span><span class="s">&quot;B&quot;</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="kc">true</span><span class="p">,</span> <span class="kc">true</span><span class="p">));</span>  <span class="c1">// 2    第4引数がtrueなら、そのタグの終了</span>

<span class="n">writeln</span><span class="p">(</span><span class="n">taggedGt</span><span class="p">(</span><span class="s">&quot;A&quot;</span><span class="p">,</span> <span class="mi">3</span><span class="p">));</span>              <span class="c1">// 6</span>
<span class="n">writeln</span><span class="p">(</span><span class="n">taggedGt</span><span class="p">(</span><span class="s">&quot;B&quot;</span><span class="p">,</span> <span class="mi">4</span><span class="p">));</span>              <span class="c1">// 4</span>
<span class="n">writeln</span><span class="p">(</span><span class="n">taggedGt</span><span class="p">(</span><span class="s">&quot;C&quot;</span><span class="p">,</span> <span class="mi">5</span><span class="p">));</span>              <span class="c1">// 11</span>

<span class="n">taggedGt</span><span class="p">(</span><span class="s">&quot;A&quot;</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="kc">true</span><span class="p">,</span> <span class="kc">true</span><span class="p">);</span>           <span class="c1">// 数え上げ終わりのときは、必ず第4引数をtrueにする</span>
<span class="n">taggedGt</span><span class="p">(</span><span class="s">&quot;B&quot;</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="kc">true</span><span class="p">,</span> <span class="kc">true</span><span class="p">);</span>           <span class="c1">// 同上</span>
<span class="n">taggedGt</span><span class="p">(</span><span class="s">&quot;C&quot;</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="kc">true</span><span class="p">,</span> <span class="kc">true</span><span class="p">);</span>           <span class="c1">// 同上</span>
</code></pre></div>
<p>ヒント:</p>

<ul>
<li>連想配列</li>
<li>第4引数がtrueのときは、連想配列からそのタグを削除</li>
</ul></li>
<li><p><a name = "Q7">問題7 「カウンター」</a></p>

<p>次のようなソースコードを満たす、<code>createCounter</code>を実装してください。</p>
<div class="highlight"><pre><code class="language-d" data-lang="d"><span class="k">auto</span> <span class="n">cnt1</span> <span class="p">=</span> <span class="n">createCounter</span><span class="p">();</span>

<span class="n">writeln</span><span class="p">(</span><span class="n">cnt1</span><span class="p">());</span>             <span class="c1">// 1</span>
<span class="n">cnt1</span><span class="p">();</span>
<span class="n">cnt1</span><span class="p">();</span>
<span class="n">writeln</span><span class="p">(</span><span class="n">cnt1</span><span class="p">());</span>             <span class="c1">// 4</span>

<span class="k">auto</span> <span class="n">cnt2</span> <span class="p">=</span> <span class="n">createCounter</span><span class="p">();</span>

<span class="n">writeln</span><span class="p">(</span><span class="n">cnt2</span><span class="p">());</span>            <span class="c1">// 1</span>
<span class="n">writeln</span><span class="p">(</span><span class="n">cnt1</span><span class="p">());</span>            <span class="c1">// 5</span>
<span class="n">writeln</span><span class="p">(</span><span class="n">cnt2</span><span class="p">());</span>            <span class="c1">// 2</span>
</code></pre></div></li>
<li><p><a name = "Q8">問題8 「関数型スタイルなD」</a></p>

<p>関数を関数に渡して処理の内容を変えたりするという技法は、関数型プログラミングというものに属するそうです。
D言語の標準ライブラリPhobosは、基本的にこの技法をベースにして作成されています。</p>

<p>例えば、<code>std.algorithm.map</code>を見てみましょう。</p>
<div class="highlight"><pre><code class="language-d" data-lang="d"><span class="k">import</span> <span class="n">std</span><span class="p">.</span><span class="n">algorithm</span><span class="p">,</span>
       <span class="n">std</span><span class="p">.</span><span class="n">conv</span><span class="p">,</span>
       <span class="n">std</span><span class="p">.</span><span class="n">stdio</span><span class="p">;</span>

<span class="kt">void</span> <span class="n">main</span><span class="p">(){</span>
    <span class="k">auto</span> <span class="n">r</span> <span class="p">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">];</span>

    <span class="n">writeln</span><span class="p">(</span><span class="n">r</span><span class="p">.</span><span class="n">map</span><span class="p">!(</span><span class="n">a</span> <span class="p">=&gt;</span> <span class="n">a</span> <span class="p">+</span> <span class="mi">1</span><span class="p">)());</span>          <span class="c1">// [1, 2, 3]</span>
    <span class="n">writeln</span><span class="p">(</span><span class="n">r</span><span class="p">.</span><span class="n">map</span><span class="p">!(</span><span class="n">a</span> <span class="p">=&gt;</span> <span class="n">a</span><span class="p">.</span><span class="n">to</span><span class="p">!</span><span class="nb">string</span><span class="p">()));</span>    <span class="c1">// [&quot;0&quot;, &quot;1&quot;, &quot;2&quot;]</span>
<span class="p">}</span>
</code></pre></div>
<p><code>map!(a =&gt; a + 1)</code>というシンタックスは見慣れませんね。
(まだ説明してないからなのですが。)
簡単に説明すると、<code>map</code>関数にコンパイル時引数として、ラムダ<code>a =&gt; a + 1</code>を渡しているという意味です。</p>

<p><code>r.map!(a =&gt; a + 1)()</code>は<code>r</code>の全ての要素に1足すという意味で、<code>r.map!(a =&gt; a.to!string())</code>は<code>r</code>のすべての要素を文字列表現に変換するという意味です。</p>

<p><code>filter</code>と<code>reduce</code>という素晴らしいものが<code>std.algorithm</code>にあるのですが、Phobosのドキュメントを読んで、次の関数を作ってください。</p>

<ul>
<li>配列<code>int[] arr</code>を受け取って、<code>arr</code>の要素のうち、偶数の要素の総和を返す関数<code>sumOfEven</code></li>
<li>配列<code>int[] arr</code>と<code>int needle</code>を受け取って、<code>arr</code>の中で最も<code>needle</code>に近い値を返す関数<code>getApprxEqElm</code></li>
</ul>

<p>Phobosのドキュメント:
- filter: <a href="http://dlang.org/phobos/std_algorithm.html#filter">英語</a>, <a href="http://www.kmonos.net/alang/d/phobos/std_algorithm.html#filter">日本語</a>
- reduce: <a href="http://dlang.org/phobos/std_algorithm.html#reduce">英語</a>, <a href="http://www.kmonos.net/alang/d/phobos/std_algorithm.html#reduce">日本語</a></p></li>
<li><p>問題募集中</p></li>
</ul>

<h2>終わりに</h2>

<p>実はこの関数の章は、文章量では、他の章に対して3倍(対：式と演算子)～15倍(対：ポインタ)もの量を誇っています。
それほど関数というのは複雑なのです。
ですが、これからは嫌というほど書いていくことになるので、自然と身につくはずです。</p>

<p>さて、次は「メイン関数」について説明します。</p>

<h2>キーワード</h2>

<ul>
<li>関数(function)</li>
<li>引数(argument, parameter)

<ul>
<li>仮引数(parameter)</li>
<li>実引数(argument)</li>
</ul></li>
<li>戻り値, 返り値(return value)</li>
<li>関数本体</li>
<li>関数プロトタイプ</li>
<li><code>return</code>文</li>
<li><code>assert(0);</code></li>
<li>仮引数のデフォルト値(parameter&#39;s default value)</li>
<li>仮引数の記憶域クラス(parameter storage class)

<ul>
<li><code>in</code></li>
<li><code>out</code></li>
<li><code>ref</code></li>
<li><code>lazy</code></li>
<li><code>const</code></li>
<li><code>immutable</code></li>
<li><code>shared</code></li>
<li><code>inout</code></li>
<li><code>scope</code></li>
<li>(<code>auto ref</code>)</li>
</ul></li>
<li>可変個引数関数(variadic function)</li>
<li><code>auto</code>関数, <code>auto ref</code>関数</li>
<li>関数属性(function attribute)

<ul>
<li><code>@property</code></li>
<li><code>@safe</code>, <code>@trusted</code>, <code>@system</code></li>
<li><code>pure</code></li>
<li><code>nothrow</code></li>
<li>UDA(User Defined Attribute)</li>
<li><code>const</code>, <code>immutable</code>, <code>inout</code>, <code>abstract</code>, <code>final</code></li>
</ul></li>
<li>関数オーバーロード(overload)

<ul>
<li>オーバーロード集合(overload set)</li>
</ul></li>
<li>ローカル<code>static</code>変数(local static variable)</li>
<li>ネスト関数(nested function)</li>
<li>関数ポインタ(function pointer)</li>
<li>デリゲート(delegate)</li>
<li>ラムダ(lambda, λ)</li>
<li>UFCS(Uniform Function Call Syntax)</li>
<li>CTFE(Compile Time Function Execution)</li>
<li>関数型プログラミング(functional programming)</li>
</ul>

<h2>仕様</h2>

<ul>
<li>関数: <a href="http://dlang.org/function.html">英語</a>, <a href="http://www.kmonos.net/alang/d/function.html">日本語</a></li>
</ul>

              </div>
            </div>
          </div>
          <div class="row">
  <div class="col-md-12 col-sm-12 col-xs-12">
    <div class="page-footer">
      <div class="list-group">
        <a href="/archives/#y-2013" class="list-group-item col-md-3 col-sm-4 col-xs-6">
          <i class="fa fa fa-archive fa-lg"></i> 
          <em itemprop="datePublished" content="2013-08-23">
            23 Aug 2013
          </em>
        </a>
        
        <a href="/categories/#dmanual" class="list-group-item col-md-3 col-sm-4 col-xs-6">
          <i class="fa fa-folder-open fa-lg"></i> <em itemprop="keywords">Dmanual</em>
          <span class="badge">0</span>
        </a>
        
        
        <a href="/tags/#dmanual" class="list-group-item col-md-3 col-sm-4 col-xs-6">
          <i class="fa fa-tag fa-lg"></i> <em itemprop="keywords">dmanual</em>
          <span class="badge">2</span>
        </a>
        
    </div>
    <div id="disqus_thread"></div>
    <script type="text/javascript">
        /* * * CONFIGURATION VARIABLES: EDIT BEFORE PASTING INTO YOUR WEBPAGE * * */
        var disqus_shortname = 'dmanual'; // required: replace example with your forum shortname

        /* * * DON'T EDIT BELOW THIS LINE * * */
        (function() {
            var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
            dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
            (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
        })();
    </script>
    <noscript>Please enable JavaScript to view the <a href="http://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
    <a href="http://disqus.com" class="dsq-brlink">comments powered by <span class="logo-disqus">Disqus</span></a>
  </div>
</div>
        </article>
      </div>
    </div>
    
<div class="footer">
  <div class="container">
    <hr/>
    <div class="row">
      <div class="col-md-12 col-sm-12 col-xs-12">
        <ul class="nav nav-pills">
          
          <li>
            <a href="https://www.github.com/k3kaimu">
              <i class="fa fa-github-square fa-lg"></i> GitHub
            </a>
          </li>
          
          
          <li>
            <a href="http://www.twitter.com/k3_kaimu">
              <i class="fa fa-twitter-square fa-lg"></i> Twitter
            </a>
          </li>
          
          
          
          <li>
            <a href="/atom.xml">
              <i class="fa fa-rss-square fa-lg"></i> Rss
            </a>
          </li>
          <li class="pull-right visible-md visible-lg">
            <a href="#top">
              <i class="fa fa-arrow-circle-up fa-lg"></i> Back to top
            </a>
          </li>
        </ul>
      </div>
    </div>
    <div class="row">
      <div class="col-md-12 col-sm-12 col-xs-12">        
        <p>
          &copy; k3-kaimu 2014 
          with help from <a href="https://github.com/ogaclejapan/jekyllstrap" target="_blank" title="jekyllstrap is Jekyll template based on Bootstrap.">Jekyllstrap</a>.
        </p>
        <p>
          Based on <a href="http://jekyllrb.com/" target="_blank">Jekyll</a>. 
          Themes from <a href="http://getbootstrap.com/" target="_blank">Bootstrap</a> and <a href="http://bootswatch.com/" target="_blank">Bootswatch</a>. 
          Icons from <a href="http://fontawesome.io/" target="_blank">Font Awesome</a>.
        </p>
        <p>
        <a href="https://github.com/k3kaimu/k3kaimu.github.io/commits/src/dmanual/function.md">View this page's history on GitHub</a>
        </p>
      </div>
    </div>
    <div class="row">
    <form action="http://www.google.com/cse" id="cse-search-box">
<input type="hidden" name="cx" value="004390249242222246033:d_53xmyptd0" />
<input type="hidden" name="ie" value="UTF-8" />
<input type="text" name="q" size="31" />
<input type="submit" name="sa" value="&#xf00e;" />
</form>
<script type="text/javascript" src="//www.google.com/cse/brand?form=cse-search-box&lang=ja"></script>

    </div>
  </div>
</div>


    
<div id="back-to-top">
  <a href="#top"><i class="fa fa-arrow-circle-up fa-5x"></i></a>
</div>

    
<script src="//code.jquery.com/jquery-2.0.3.min.js"></script>
<script src="//netdna.bootstrapcdn.com/bootstrap/3.0.3/js/bootstrap.min.js"></script>
<script src="/assets/js/all.min.js"></script>



    


  </body>
</html>
