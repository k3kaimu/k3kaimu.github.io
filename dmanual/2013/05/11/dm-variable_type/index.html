<!DOCTYPE html>
<html lang="ja" xmlns="http://www.w3.org/1999/xhtml" prefix="og: http://ogp.me/ns#">
  <head>
    
<meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<meta name="format-detection" content="telephone=no">
<link rel="alternate" type="application/rss+xml" title="RSS Feed" href="http://k3kaimu.github.io/atom.xml">
<link rel="shortcut icon" href="/favicon.ico">

    <title> 02 変数と型 | Go to the future</title>
    
<meta property="og:type" content="blog">
<meta property="og:title" content="02 変数と型">
<meta property="og:description" content="{% tree %}

## 式(Expression)と文(Statement)とは？

D言語のプログラムが関数とデータの集合であることは前の章で説明しましたね。
では、関数は何で構成されているのでしょうか。
その答えは文(statement)です。
`void main(){}`というの...">
<meta property="og:url" content="http://k3kaimu.github.io/dmanual/2013/05/11/dm-variable_type/">

<meta property="og:site_name" content="Go to the future">
<meta property="og:locale" content="ja_JP">
<meta name="twitter:card" content="summary">

<meta name="twitter:site" content="@k3_kaimu">


    
<link rel="stylesheet" href="//netdna.bootstrapcdn.com/bootswatch/3.0.2/cerulean/bootstrap.min.css">
<link rel="stylesheet" href="//netdna.bootstrapcdn.com/font-awesome/4.0.3/css/font-awesome.min.css">
<link rel="stylesheet" href="/assets/css/all.min.css">
<link rel="stylesheet" href="/assets/css/navigation.css">

    
<!--[if lt IE 9]>
  <script src="https://oss.maxcdn.com/libs/html5shiv/3.7.0/html5shiv.js"></script>
  <script src="https://oss.maxcdn.com/libs/respond.js/1.3.0/respond.min.js"></script>
<![endif]-->

  </head>
  <body>
    
<div class="navbar navbar-default navbar-fixed-top" role="navigation">
  <div class="container">
    <div class="navbar-header">
      <a href="/" class="navbar-brand">Go to the future</a>
      <button class="navbar-toggle" type="button" data-toggle="collapse" data-target="#navbar-main">
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
      </button>
    </div>
    <div class="navbar-collapse collapse" id="navbar-main">
      <ul class="nav navbar-nav js_nav">
        <li><a href="/blog/">Blog</a></li>
        <li><a href="/dmanual/">DManual</a></li>
        <li><a href="/dtips/">DTips</a></li>
        <li><a href="/archives/">Index...</a></li>
      </ul>
      <div id="owner" itemprop="author copyrightHolder editor" itemscope itemtype="http://schema.org/Person">
        <ul class="nav navbar-nav navbar-right">
          <li class="dropdown">
            <a href="#" class="dropdown-toggle" data-toggle="dropdown">k3-kaimu <b class="caret"></b></a>
            <ul class="dropdown-menu">
              
              <li>
                
                <a href="https://www.github.com/k3kaimu" itemprop="sameAs" content="https://www.github.com/k3kaimu">
                  <i class="fa fa-github-square fa-lg"></i> GitHub
                </a>
              </li>
              
              
              <li>
                
                <a href="http://www.twitter.com/k3_kaimu" itemprop="sameAs" content="http://www.twitter.com/k3_kaimu">
                  <i class="fa fa-twitter-square fa-lg"></i> Twitter
                </a>
              </li>
              
              
              
              <li>
                <a href="/atom.xml">
                  <i class="fa fa-rss-square fa-lg fa-lg"></i> Rss
                </a>
              </li>
            </ul>
          </li>
        </ul>
      </div>
    </div>
  </div>
</div>

    <div id="content">
      <div class="container">
        <article itemscope itemtype="http://schema.org/Article" itemref="owner">
          
<div class="row">
  <div class="col-md-12 col-sm-12 col-xs-12">
    <div class="page-header">
      <h1 itemprop="url" content="http://k3kaimu.github.io/dmanual/2013/05/11/dm-variable_type/">
        <i class="fa fa-puzzle-piece fa-lg"></i> <span itemprop="name">02 変数と型</span>
      </h1>
    </div>
  </div>
</div>

          <div class="row">
            <div class="col-md-12 col-sm-12 col-xs-12">
              <div itmprop="articleBody">
                <p><h2 class="content_tree">Contents</h2><div class="content_tree_list"><ul><li>式(Expression)と文(Statement)とは？</li><li>変数(Variable)</li><ul><li>変数の宣言(Declaration)</li><li>変数の寿命とスコープ</li><li>左辺値(lvalue)と右辺値(rvalue)</li></ul><li>いろいろな型(Type)</li><ul><li>リテラル(Literal)とシンボル(Symbol)</li><li>デフォルト初期化値(Default Initializer; Type.init)</li><li>void</li><li>論理型(Boolean)</li><li>整数型(Decimal Number)</li><li>浮動小数点型(Floating-Point Number)</li><li>虚数浮動小数点型(Imaginary Floating-Point Number)</li><li>複素浮動小数点型(Complex Floating-Point Number)</li><li>文字型(Charactor)</li><li>文字列型(String)</li><li>派生型(Derived Data Type)</li><li>ユーザー定義型(User Defined Type)</li></ul><li>型修飾子(Type Qualifiers)</li><ul><li>const</li><li>immutable</li><li>shared</li></ul><li>記憶域クラス(Storage Class)</li><ul><li>const</li><li>immutable</li><li>shared</li><li>scope</li><li>関数でのみ有効となる記憶域クラス</li></ul><li>型推論(Type Inference)</li><li>問題 -&gt; <a href="%7B%7B%20site.baseurl%20%7D%7D/dmanual/answer#variable_type">解答</a></li><li>おわりに</li><li>キーワード</li></ul></ul></div></p>

<h2>式(Expression)と文(Statement)とは？</h2>

<p>D言語のプログラムが関数とデータの集合であることは前の章で説明しましたね。
では、関数は何で構成されているのでしょうか。
その答えは文(statement)です。
<code>void main(){}</code>というのも実際には宣言文(Declaration Statement)ですし、<code>import std.stdio;</code>もインポート宣言(Import Declaration)という文です。
さらに、<code>writeln(&quot;Hello, World!&quot;);</code>も文です。
ということで、D言語のプログラムは文の集合だったりします
また、文は文で構成されたり、式(expression)で構成されます。
たとえば、<code>writeln(&quot;Hello, World!&quot;)</code>は式ですが、<code>;</code>を付けることで<code>writeln(&quot;Hello, World!&quot;);</code>となり文となります。
<code>&quot;Hello, World!&quot;</code>も式ですし、<code>123</code>も式です。</p>

<h2>変数(Variable)</h2>

<p>電卓にはメモリー機能というのがありますね。
使ったことがないなら、これからは使ってみることをオススメします、便利ですよ。
さて、プログラムでもメモリー機能が使えます。
それが変数です。
式の値は変数に格納しておくことができます。
また、変数は電卓のメモリ機能と違い、宣言しないと使えませんが、たくさん使用することが可能です。</p>
<div class="highlight"><pre><code class="language-d" data-lang="d"><span class="c1">///src.d</span>
<span class="k">import</span> <span class="n">std</span><span class="p">.</span><span class="n">stdio</span><span class="p">;</span>

<span class="kt">void</span> <span class="n">main</span><span class="p">()</span>
<span class="p">{</span>
    <span class="kt">int</span> <span class="n">a</span> <span class="p">=</span> <span class="mi">1</span> <span class="p">+</span> <span class="mi">2</span><span class="p">;</span>
    <span class="n">writeln</span><span class="p">(</span><span class="n">a</span><span class="p">);</span>

    <span class="n">a</span> <span class="p">=</span> <span class="mi">3</span> <span class="p">+</span> <span class="mi">1</span><span class="p">;</span>
    <span class="n">writeln</span><span class="p">(</span><span class="n">a</span><span class="p">);</span>

    <span class="n">a</span> <span class="p">=</span> <span class="n">a</span> <span class="p">+</span> <span class="mi">2</span><span class="p">;</span>
    <span class="n">writeln</span><span class="p">(</span><span class="n">a</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div><div class="highlight"><pre><code class="language-text" data-lang="text">$ rdmd src.d
3
4
6
</code></pre></div>
<p>変数は宣言した場所以降から有効になります。
例では、<code>int a = 1 + 2;</code>というのが変数の宣言の部分で、<code>int</code>型の変数<code>a</code>を宣言しています。
次の行の<code>writeln(a);</code>では<code>a</code>の値である<code>3</code>を表示します。
また、<code>a</code>は宣言したあとは自由に書き換えられます。
<code>=</code>は代入演算子で、右辺(rhs)の値を左辺(lhs)にセットします。
3つめの<code>a = a + 2;</code>は奇妙かもしれませんが、<code>a + 2</code>が6ですから<code>a = 6;</code>と同じです。</p>

<h3>変数の宣言(Declaration)</h3>

<p>変数の宣言は<code>Type identifier;</code>、もしくは初期化する場合は<code>Type identifier = initializer;</code>となります。
また、一度に複数宣言することもできて、<code>T a, b, c;</code>と書いたり、初期化したい場合には、</p>
<div class="highlight"><pre><code class="language-d" data-lang="d"><span class="kt">int</span> <span class="n">a</span> <span class="p">=</span> <span class="mi">12</span><span class="p">,</span>
    <span class="n">b</span> <span class="p">=</span> <span class="n">a</span> <span class="p">+</span> <span class="mi">1</span><span class="p">,</span>
    <span class="n">c</span> <span class="p">=</span> <span class="n">a</span> <span class="p">+</span> <span class="n">b</span><span class="p">,</span>
    <span class="n">d</span><span class="p">;</span>
</code></pre></div>
<p>という風にも書けます。</p>

<p>初期化の話が出ましたが、D言語では変数は宣言されたら自動的に初期化されます。
この初期化される値をデフォルト初期化値(デフォルト値, デフォルト初期化子; Default Initializer)といいます(後述)。</p>

<h3>変数の寿命とスコープ</h3>

<p>変数には寿命があり、そのスコープ内でのみ有効です。
ここでいうスコープとは、静的スコープ(Static Scope)や構文スコープ(Lexical Scope)と呼ばれるもののことです。
簡単にいうと、<code>{</code>から、それに対応する<code>}</code>までがスコープになります。
特に、最も外のスコープであるスコープはグローバルスコープ(Global Scope)と呼ばれます。</p>

<p>スコープは<code>{}</code>などによってネスト(nest; 入れ子状態のこと)されます。
宣言された変数などをシンボル(Symbol)と呼びますが、外側のスコープから内側のスコープのシンボルを覗くことはできません。
しかし、内側のスコープから外側のスコープのシンボルを覗くことは可能です。
ですので、外側のスコープで宣言されたシンボルと同じ名称のシンボルを内側のスコープで宣言できません。</p>

<p>例外は2つあり、1つ目は、グローバルなシンボルと同じ名称のシンボルを、より内側のスコープで宣言することは可能です。
この場合、<code>.&lt;symbol&gt;</code>というように書くことで、グローバルなシンボルを指すことができます。</p>

<p>2つ目はまだ説明していない内容も含まれるので今回は無視していただいても構いません。
未説明なことを承知で言うと、ユーザー定義型のスコープではグローバルでない外側のシンボルを上書きできます。
こちらのケースでは、上書きされた外側のシンボルにアクセスできなくなります。
(全てのパターンで完全に消えるわけではありません。あくまでも、<code>&lt;symbol&gt;</code>の形式でアクセスできなくなるということです。)</p>
<div class="highlight"><pre><code class="language-d" data-lang="d"><span class="k">import</span> <span class="n">std</span><span class="p">.</span><span class="n">stdio</span><span class="p">;</span>

<span class="c1">// ここはグローバルスコープ</span>

<span class="kt">int</span> <span class="n">a</span> <span class="p">=</span> <span class="mi">0</span><span class="p">;</span>

<span class="kt">void</span> <span class="n">main</span><span class="p">()</span>
<span class="p">{</span>
    <span class="c1">// ここはmain関数のスコープ</span>

    <span class="kt">double</span> <span class="n">a</span> <span class="p">=</span> <span class="mi">1</span><span class="p">;</span>       <span class="c1">// グローバルなシンボルを上書きすることは可能</span>

    <span class="n">writeln</span><span class="p">(</span><span class="n">a</span><span class="p">);</span>         <span class="c1">// 1; このスコープのa</span>
    <span class="n">writeln</span><span class="p">(.</span><span class="n">a</span><span class="p">);</span>        <span class="c1">// 0; グローバルなa</span>

    <span class="p">{</span>
        <span class="c1">//ここはmainより1つ内側のスコープ</span>

        <span class="c1">//string a;     // グローバルでないシンボルを上書きすることはできない</span>
        <span class="nb">string</span> <span class="n">b</span> <span class="p">=</span> <span class="s">&quot;foo&quot;</span><span class="p">;</span>

        <span class="n">writeln</span><span class="p">(</span><span class="n">a</span><span class="p">);</span>     <span class="c1">// 1</span>
        <span class="n">writeln</span><span class="p">(.</span><span class="n">a</span><span class="p">);</span>    <span class="c1">// 0</span>
        <span class="n">writeln</span><span class="p">(</span><span class="n">b</span><span class="p">);</span>     <span class="c1">// foo</span>

        <span class="c1">// string型のbの寿命はここまで</span>
    <span class="p">}</span>

    <span class="p">{</span>
        <span class="c1">//writeln(b);   // このスコープから、上のスコープのbを見ることはできない</span>
    <span class="p">}</span>

    <span class="c1">//writeln(b);       // 外側のスコープから、内側のbは見れない</span>
    <span class="kt">uint</span> <span class="n">b</span><span class="p">;</span>             <span class="c1">// 内側のbは見えないから、bをシンボルとして定義してもよい</span>

    <span class="n">foo</span><span class="p">();</span>              <span class="c1">// グローバルスコープにあるシンボルは、ソースコードで下にあっても使える</span>
    <span class="n">writeln</span><span class="p">(</span><span class="n">bar</span><span class="p">);</span>       <span class="c1">// 同上</span>

    <span class="c1">// double型のaやuint型のbの寿命はここまで</span>
<span class="p">}</span>


<span class="kt">int</span> <span class="n">bar</span> <span class="p">=</span> <span class="mi">12</span><span class="p">;</span>


<span class="kt">void</span> <span class="n">foo</span><span class="p">()</span>
<span class="p">{</span>
    <span class="c1">//writeln(b);       // 0; main関数のuint型のbも、string型のbも見えない</span>
<span class="p">}</span>
</code></pre></div>
<h3>左辺値(lvalue)と右辺値(rvalue)</h3>

<p>次のプログラムがおかしいことはすぐにわかると思います。</p>
<div class="highlight"><pre><code class="language-d" data-lang="d"><span class="kt">int</span> <span class="n">a</span><span class="p">;</span>

<span class="n">a</span> <span class="p">=</span> <span class="mi">12</span><span class="p">;</span>         <span class="c1">// OK</span>

<span class="p">(</span><span class="n">a</span> <span class="p">+</span> <span class="mi">3</span><span class="p">)</span> <span class="p">=</span> <span class="mi">4</span><span class="p">;</span>    <span class="c1">// NG</span>
</code></pre></div>
<p>変数である<code>a</code>には代入できるのに、<code>(a + 3)</code>には代入できません。
というのも、変数の評価結果は左辺値(lvalue; left value)となるからです。
左辺値というのは、「<code>=</code>の左側に置ける値」という意味で理解しても構いません。</p>

<p>逆に、<code>(a + 3)</code>は右辺値(rvalue)といい、<code>=</code>の左側には置くことができません。</p>

<p>(左辺値であったとしても代入できるとは限りません。<code>const</code>や<code>immutable</code>で型修飾されていれば代入は不可能です)</p>

<h2>いろいろな型(Type)</h2>

<p>D言語のデータには型があることも前の記事で書きましたが、ここではどんな型があるかを紹介します。
また、リテラルやデフォルト初期化値についても言及します。
文字型や文字列型は難しい内容が含まれているので、わからなければ読み飛ばしてもらって構いません。</p>

<h3>リテラル(Literal)とシンボル(Symbol)</h3>

<p>リテラルとは、ソースコードに直接、値を記したもののことです。
プログラムが動いている間、変数は書き換えられるのに対して、リテラルはソースコードを編集しないと変更できません。
たとえば<code>int a = 1;</code>での<code>1</code>はリテラルです。</p>

<p>逆に、<code>int a = 1;</code>での<code>a</code>はシンボルと呼ばれます。</p>

<h3>デフォルト初期化値(Default Initializer; Type.init)</h3>

<p>D言語の変数は宣言した際に初期化されます。
その際の値をデフォルト初期化値といいます。
この初期化をしてほしくない場合には、<code>Type iden = void;</code>というように<code>= void</code>とします。</p>
<div class="highlight"><pre><code class="language-d" data-lang="d"><span class="kt">int</span> <span class="n">a</span><span class="p">;</span>
<span class="n">writeln</span><span class="p">(</span><span class="n">a</span><span class="p">);</span>         <span class="c1">// 0; intのデフォルト初期化値は 0</span>

<span class="n">writeln</span><span class="p">(</span><span class="kt">int</span><span class="p">.</span><span class="n">init</span><span class="p">);</span>  <span class="c1">// Type.init でデフォルト初期化値を取得できる</span>

<span class="kt">int</span> <span class="n">b</span> <span class="p">=</span> <span class="kt">void</span><span class="p">;</span>       <span class="c1">// 初期化を阻止</span>
<span class="n">writeln</span><span class="p">(</span><span class="n">b</span><span class="p">);</span>         <span class="c1">// 何が表示されるかわからない</span>
</code></pre></div>
<h3>void</h3>
<div class="highlight"><pre><code class="language-text" data-lang="text">* void      : 値(または型)なし。
</code></pre></div>
<p>値がない、もしくは型がないときに<code>void</code>と書きます。
前の記事でのmain関数では、<code>void main()</code>と書いていましたが、そこではmain関数の返り値が無いことを意味しています。</p>

<p>(厳密には、<code>void main()</code>は、プログラムが成功し正常に終了すれば<code>0</code>を返しますが、これについてはmain関数の項で説明します。)</p>

<h3>論理型(Boolean)</h3>
<div class="highlight"><pre><code class="language-text" data-lang="text">* bool      : 真偽値(`true`, `false`)
</code></pre></div>
<p>真か偽かを判別するための型です。
デフォルト初期化値は<code>false</code>です。</p>
<div class="highlight"><pre><code class="language-d" data-lang="d"><span class="kt">bool</span> <span class="n">b</span><span class="p">;</span>

<span class="n">writeln</span><span class="p">(</span><span class="n">b</span><span class="p">);</span> <span class="c1">// false</span>
<span class="n">b</span> <span class="p">=</span> <span class="p">!</span><span class="n">b</span><span class="p">;</span>
<span class="n">writeln</span><span class="p">(</span><span class="n">b</span><span class="p">);</span> <span class="c1">// true</span>

<span class="n">b</span> <span class="p">=</span> <span class="kc">true</span><span class="p">;</span>
<span class="n">writeln</span><span class="p">(</span><span class="n">b</span><span class="p">);</span> <span class="c1">// true</span>

<span class="n">b</span> <span class="p">=</span> <span class="kc">false</span><span class="p">;</span>
<span class="n">writeln</span><span class="p">(</span><span class="n">b</span><span class="p">);</span> <span class="c1">// false</span>
</code></pre></div>
<h3>整数型(Decimal Number)</h3>
<div class="highlight"><pre><code class="language-text" data-lang="text">* byte      :  8bitの符号あり(signed)な整数
* ubyte     :  8bitの符号なし(unsigned)な整数
* short     : 16bitの符号あり整数
* ushort    : 16bitの符号なし整数
* int       : 32bitの符号あり整数
* uint      : 32bitの符号なし整数
* long      : 64bitの符号あり整数
* ulong     : 64bitの符号なし整数
* cent      : 128bitの符号あり整数(将来のために名前だけ付けられてる)
* ucent     : 128bitの符号なし整数(将来のために名前だけ付けられてる)

* size_t    : ポインタ値が十分に入る大きさの符号なし整数型
              32bit環境だと32bit(uint), 64bit環境だと64bit(ulong)

* ptrdiff_t : size_tと同じ大きさの符号あり整数型
</code></pre></div>
<p>整数型には、8bitから倍々に64bitまであります(128bit型は今は使えない)。
符号あり整数型の前に<code>&#39;u&#39;</code>をつけると符号なし整数型になります。</p>

<p>また、<code>size_t</code>や<code>ptrdiff_t</code>という変わり種の整数型もあります。
整数型は、どれも<code>0</code>で初期化され、算術演算やビット演算が可能です。</p>
<div class="highlight"><pre><code class="language-d" data-lang="d"><span class="kt">int</span> <span class="n">a</span><span class="p">;</span>

<span class="n">writeln</span><span class="p">(</span><span class="n">a</span><span class="p">);</span>             <span class="c1">// 0</span>

<span class="kt">ulong</span> <span class="n">b</span> <span class="p">=</span> <span class="p">-</span><span class="mi">1</span><span class="p">;</span>

<span class="n">writeln</span><span class="p">(</span><span class="n">b</span><span class="p">);</span>             <span class="c1">// 18446744073709551615</span>
                        <span class="c1">// -1 は int型 だが、int -&gt; long -&gt; ulongと暗黙に変換される。</span>
                        <span class="c1">// longからulongへの変換によってこのようになる。</span>

<span class="n">writeln</span><span class="p">(</span><span class="mi">1u</span><span class="n">L</span> <span class="p">-</span> <span class="mi">2u</span><span class="n">L</span><span class="p">);</span>     <span class="c1">// 18446744073709551615</span>
                        <span class="c1">// 1uL は ulong型の1なので、</span>
                        <span class="c1">// 上のbと同様に負の数を表せず、このようになる。</span>

<span class="n">writeln</span><span class="p">(</span><span class="mi">1u</span><span class="p">);</span>            <span class="c1">// 数値の後ろに u とつけると uint型</span>
<span class="n">writeln</span><span class="p">(</span><span class="mi">1U</span><span class="p">);</span>            <span class="c1">// 大文字で U とつけても同じ</span>

<span class="n">writeln</span><span class="p">(</span><span class="mi">1L</span><span class="p">);</span>            <span class="c1">// 大文字の L をつければ long型</span>

<span class="n">writeln</span><span class="p">(</span><span class="mi">1u</span><span class="n">L</span><span class="p">);</span>           <span class="c1">// uL や、UL は ulong型</span>
</code></pre></div>
<h3>浮動小数点型(Floating-Point Number)</h3>
<div class="highlight"><pre><code class="language-text" data-lang="text">()の中の3つの数字は、(符号部bit数, 指数部bit数, 仮数部bit数)
* float     : 32bitの浮動小数点の実数(1, 8, 23)
* double    : 64bitの浮動小数点の実数(1, 11, 52)
* real      : 64bit以上(システムによって違う)の浮動小数点の実数
</code></pre></div>
<p>浮動小数点とは、コンピュータで実数値を表す方式のことです。
演算によって小数点が動くのでこのような名前になっています。
D言語の浮動小数点数はIEEE 754という規格に沿っています。
この型は、<code>float</code>なら<code>float.nan</code>, <code>double</code>なら<code>double.nan</code>, <code>real</code>なら<code>real.nan</code>で初期化されます。</p>

<p>なお、real型については64bit以上という言語仕様ですが、これは最低限保証するビット数であり、例えばIntelのCPUでは79bitの精度となっています。
(x87の拡張浮動小数点数では80bit(1, 15, 64)であるものの、IEEE 754では表されない整数部の1bitを無駄に使用しているため、精度で言えば79bit(1, 15, 63)相当となります)</p>
<div class="highlight"><pre><code class="language-d" data-lang="d"><span class="kt">float</span>  <span class="n">f</span> <span class="p">=</span> <span class="mf">1.0f</span><span class="p">;</span>        <span class="c1">// 数値の後に f をつければ float型</span>
<span class="kt">double</span> <span class="n">d</span> <span class="p">=</span> <span class="mf">1.0</span><span class="p">;</span>         <span class="c1">// 少数点のある数値は double型</span>
<span class="kt">real</span>   <span class="n">r</span> <span class="p">=</span> <span class="mf">1.0L</span><span class="p">;</span>        <span class="c1">// 少数点があり、最後に L が付いていると real型</span>

<span class="n">writeln</span><span class="p">(</span><span class="n">f</span> <span class="p">/</span> <span class="mi">0</span><span class="p">);</span>         <span class="c1">// inf</span>
<span class="n">writeln</span><span class="p">(</span><span class="mf">0.0</span> <span class="p">/</span> <span class="mf">0.0</span><span class="p">);</span>     <span class="c1">// -nan</span>
</code></pre></div>
<h3>虚数浮動小数点型(Imaginary Floating-Point Number)</h3>
<div class="highlight"><pre><code class="language-text" data-lang="text">* ifloat    : 32bitの浮動小数点の虚数
* idouble   : 64bitの浮動小数点の虚数
* ireal     : 64bit以上(システムによって違う)の浮動小数点の虚数
</code></pre></div>
<p>プログラミング言語では珍しい、虚数を表す型です。
それぞれ、<code>ifloat</code>なら<code>float.nan * 1.0i</code>というように初期化されます。</p>
<div class="highlight"><pre><code class="language-d" data-lang="d"><span class="kt">ifloat</span> <span class="n">f</span> <span class="p">=</span> <span class="mf">1.0fi</span><span class="p">;</span>       <span class="c1">//  i を末尾につければ虚数型</span>
</code></pre></div>
<h3>複素浮動小数点型(Complex Floating-Point Number)</h3>
<div class="highlight"><pre><code class="language-text" data-lang="text">* cfloat    : 32bitの浮動小数点の複素数, 64bit
* cdouble   : 64bitの浮動小数点の複素数, 128bit
* creal     : 64bit以上(システムによって違う)の浮動小数点の複素数(64bit以上 * 2の大きさ)
</code></pre></div>
<p>実部と虚部を持つ型です。これもプログラミング言語では珍しいです。
それぞれ、<code>cfloat</code>なら<code>float.nan + float.nan * 1.0i</code>という値で初期化されます。</p>

<h3>文字型(Charactor)</h3>
<div class="highlight"><pre><code class="language-text" data-lang="text">* char      : UTF-8でエンコードされた文字(8bit)
* wchar     : UTF-16でエンコードされた文字(16bit)
* dchar     : UTF-32でエンコードされた文字(32bit)
</code></pre></div>
<p>D言語で文字型を使用すると、その文字はUTF-8かUTF-16, UTF-32でエンコードされていると認識されます。
もし、Unicode以外でエンコーディングされた文字を格納する場合には、<code>ubyte</code>や<code>ushort</code>, <code>uint</code>を使用するべきです(邦訳TDPL 118ページ参照)。
また、デフォルト初期化値はそれぞれ、<code>0xFF</code>, <code>0xFFFF</code>, <code>0x0000FFFF</code>です。</p>

<h3>文字列型(String)</h3>
<div class="highlight"><pre><code class="language-text" data-lang="text">* string    : 文字列型(immutable(char)[])
* wstring   : 文字列型(immutable(wchar)[])
* dstring   : 文字列型(immutable(dchar)[])
</code></pre></div>
<p>こちらも文字型を同じようにUTF-8, UTF-16, UTF-32でエンコードされていると仮定されます。
ですから、Unicode以外でエンコーディングされた文字列を格納するなら、<code>ubyte[]</code>や<code>immutable(ubyte)[]</code>, <code>ushort[]</code>, <code>immutable(ushort)[]</code>, <code>uint[]</code>, <code>immutable(uint)[]</code>を使用するべきなのです。
(例えば <code>std.encoding</code> モジュールでは、ASCIIコードの文字列を表現するのに <code>immutable(ubyte)[]</code> が使用されています)</p>
<div class="highlight"><pre><code class="language-d" data-lang="d"><span class="c1">//import std.utf;       追加でこの2つをimportする</span>
<span class="c1">//import std.range;</span>

<span class="nb">string</span>  <span class="n">utf8</span>  <span class="p">=</span> <span class="s">&quot;ほげほげ&quot;</span><span class="p">;</span>
<span class="nb">wstring</span> <span class="n">utf16</span> <span class="p">=</span> <span class="s">&quot;ほげほげ&quot;w</span><span class="p">;</span>
<span class="nb">dstring</span> <span class="n">utf32</span> <span class="p">=</span> <span class="s">&quot;ほげほげ&quot;d</span><span class="p">;</span>

<span class="n">writeln</span><span class="p">(</span><span class="n">utf8</span><span class="p">);</span>                                  <span class="c1">// ほげほげ</span>
<span class="n">writeln</span><span class="p">(</span><span class="n">utf16</span><span class="p">);</span>                                 <span class="c1">// ほげほげ</span>
<span class="n">writeln</span><span class="p">(</span><span class="n">utf32</span><span class="p">);</span>                                 <span class="c1">// ほげほげ</span>

<span class="n">writeln</span><span class="p">(</span> <span class="n">utf8</span><span class="p">[</span><span class="n">std</span><span class="p">.</span><span class="n">utf</span><span class="p">.</span><span class="n">stride</span><span class="p">(</span> <span class="n">utf8</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span> <span class="p">..</span> <span class="p">$]);</span>  <span class="c1">// げほげ</span>
<span class="n">writeln</span><span class="p">(</span><span class="n">utf16</span><span class="p">[</span><span class="n">std</span><span class="p">.</span><span class="n">utf</span><span class="p">.</span><span class="n">stride</span><span class="p">(</span><span class="n">utf16</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span> <span class="p">..</span> <span class="p">$]);</span>  <span class="c1">// げほげ</span>
<span class="n">writeln</span><span class="p">(</span><span class="n">utf32</span><span class="p">[</span><span class="mi">1</span> <span class="p">..</span> <span class="p">$]);</span>                         <span class="c1">// げほげ</span>

<span class="n">writeln</span><span class="p">(</span><span class="n">std</span><span class="p">.</span><span class="n">range</span><span class="p">.</span><span class="n">drop</span><span class="p">(</span> <span class="n">utf8</span><span class="p">,</span> <span class="mi">2</span><span class="p">));</span>              <span class="c1">// ほげ</span>
<span class="n">writeln</span><span class="p">(</span><span class="n">std</span><span class="p">.</span><span class="n">range</span><span class="p">.</span><span class="n">drop</span><span class="p">(</span><span class="n">utf16</span><span class="p">,</span> <span class="mi">2</span><span class="p">));</span>              <span class="c1">// ほげ</span>
<span class="n">writeln</span><span class="p">(</span><span class="n">std</span><span class="p">.</span><span class="n">range</span><span class="p">.</span><span class="n">drop</span><span class="p">(</span><span class="n">utf32</span><span class="p">,</span> <span class="mi">2</span><span class="p">));</span>              <span class="c1">// ほげ</span>
</code></pre></div>
<h3>派生型(Derived Data Type)</h3>
<div class="highlight"><pre><code class="language-text" data-lang="text">* T*        : T型に対するポインタ型(Pointer)
* T[]       : T型を要素とするスライス(Slice)(動的配列; Dynamic Array)
* T[N]      : T型を連続してN要素集めた型。静的配列(Static Array)
* V[K]      : K型の値に対してV型の値が1:1で対応する型。連想配列(Associative Array)
* R function(T...)
            : T...型を受け取ってR型の値を返す関数ポインタ型
* R delegate(T...)
            : T...型を受け取ってR型の値を返すデリゲート(委譲)型
</code></pre></div>
<p>これらの型については後ほど個々に詳しく書きます。</p>

<h3>ユーザー定義型(User Defined Type)</h3>
<div class="highlight"><pre><code class="language-text" data-lang="text">* enum      : 列挙型
* struct    : 構造体
* union     : 共用体
* class     : クラス
* interface : インターフェース
</code></pre></div>
<p>ユーザー(プログラマ)が、いろいろな型を組み合わせて新しい型を作るための型です。
これらについては各々独立した記事を書きます。</p>

<h2>型修飾子(Type Qualifiers)</h2>

<p>型に修飾子を付けることによって、様々な情報を型に付加させることができます。</p>

<h3>const</h3>

<p><code>const</code>で修飾された型の値は、その参照経由では変更不可能です。
<code>const</code>は推移的であり、修飾された型を構成する型も<code>const</code>型になります。
あくまでも「<code>const</code>な参照経由では変更不可能」なだけなので、ある程度の型であれば<code>const</code>型以外へも暗黙変換可能です。</p>

<p>ここでいう「ある程度の型」とは、値型である<code>int</code>や<code>ulong</code>, 参照を持つがその参照経由で変更ができない<code>const(T)*</code>, <code>immutable(T)*</code>などです。</p>
<div class="highlight"><pre><code class="language-d" data-lang="d"><span class="kt">void</span> <span class="n">main</span><span class="p">()</span>
<span class="p">{</span>
    <span class="kt">int</span> <span class="n">a</span><span class="p">;</span>
    <span class="k">const</span><span class="p">(</span><span class="kt">int</span><span class="p">*)</span> <span class="n">p</span> <span class="p">=</span> <span class="p">&amp;</span><span class="n">a</span><span class="p">;</span>     <span class="c1">// すべての型はconstに暗黙変換可能</span>

    <span class="c1">//*p += 3;              // Error: cannot modify const expression *p</span>
                            <span class="c1">// constは推移的なので、*pはconst(int)型</span>
                            <span class="c1">// constなデータは書き換え不可なのでエラーがでる</span>

    <span class="kt">int</span><span class="p">*</span> <span class="n">q</span> <span class="p">=</span> <span class="p">&amp;</span><span class="n">a</span><span class="p">;</span>            <span class="c1">// constでないポインタ</span>
    <span class="p">*</span><span class="n">q</span> <span class="p">=</span> <span class="mi">13</span><span class="p">;</span>                <span class="c1">// 書き換え可能</span>

    <span class="k">const</span><span class="p">(</span><span class="kt">int</span><span class="p">*)</span> <span class="n">cq</span> <span class="p">=</span> <span class="n">q</span><span class="p">;</span>     <span class="c1">// 非const型からconst型へは暗黙変換可能</span>
    <span class="c1">//q = p;                // 逆は不可能</span>
<span class="p">}</span>
</code></pre></div>
<h3>immutable</h3>

<p><code>immutable</code>型は、生まれたら死ぬまで絶対に書き換わらない型で、<code>const</code>同様に推移的です。
<code>const</code>へ暗黙変換可能ですが、非<code>immutable</code>かつ非<code>const</code>型以外へは暗黙変換不可能です。
また<code>const</code>型と同様に、値型である<code>int</code>や<code>ulong</code>, 参照を持つが<code>immutable</code>への参照である<code>immutable(T)*</code>などは<code>immutable</code>型へ暗黙変換可能です。</p>
<div class="highlight"><pre><code class="language-d" data-lang="d"><span class="kt">int</span> <span class="n">a</span><span class="p">;</span>
<span class="c1">//immutable(int)* p = &amp;a;   //Error: cannot implicitly convert expression (&amp; a) of type int* to immutable(int)*</span>
                            <span class="c1">// &amp;aはint*なのでimmutable型へは暗黙変換不可</span>

<span class="k">immutable</span><span class="p">(</span><span class="kt">int</span><span class="p">)</span> <span class="n">b</span><span class="p">;</span>

<span class="k">immutable</span><span class="p">(</span><span class="kt">int</span><span class="p">*)</span> <span class="n">p</span> <span class="p">=</span> <span class="p">&amp;</span><span class="n">b</span><span class="p">;</span>     <span class="c1">// OK</span>
                            <span class="c1">// immutable(int)*からimmutable(int*)への暗黙変換は可能</span>

<span class="k">immutable</span><span class="p">(</span><span class="kt">int</span><span class="p">)*</span> <span class="n">r</span> <span class="p">=</span> <span class="p">&amp;</span><span class="n">b</span><span class="p">;</span>
<span class="c1">//*r += 3;                  // Error: cannot modify immutable expression *r</span>
                            <span class="c1">// immutable型は変更不可能</span>
</code></pre></div>
<p><code>immutable</code>も<code>const</code>も推移的なので、<code>immutable(const(int)*)</code>は<code>immutable(int*)</code>に等価です。例を示しておきましょう。</p>
<div class="highlight"><pre><code class="language-text" data-lang="text">immutable(immutable(T))     -&gt;      immutable(T)
immutable(const(T))         -&gt;      immutable(T)
const(immutable(T))         -&gt;      immutable(T)
const(const(T))             -&gt;      const(T)

immutable(immutable(T)*)    -&gt;      immutable(T*)
immutable(const(T)*)        -&gt;      immutable(T*)
const(immutable(T)*)        -&gt;      変化しない
const(const(T)*)            -&gt;      const(T*)
</code></pre></div>
<h3>shared</h3>

<p>shared型は、複数のスレッドからアクセスされるために、知らぬ間に書き換わっているかもしれない型であることを表します。</p>
<div class="highlight"><pre><code class="language-d" data-lang="d"><span class="kt">int</span> <span class="n">a</span><span class="p">;</span>

<span class="c1">//shared(int)* p = &amp;a;      // Error: cannot implicitly convert expression (&amp; a) of type int* to shared(int)*</span>
<span class="k">shared</span><span class="p">(</span><span class="kt">int</span><span class="p">)*</span> <span class="n">q</span> <span class="p">=</span> <span class="k">cast</span><span class="p">(</span><span class="k">shared</span><span class="p">)&amp;</span><span class="n">a</span><span class="p">;</span>
</code></pre></div>
<h2>記憶域クラス(Storage Class)</h2>

<p>記憶域クラスとは、変数の特性を指定する修飾子のことです。</p>

<h3>const</h3>

<p><code>const(Type)</code>型と等しくなります。</p>
<div class="highlight"><pre><code class="language-d" data-lang="d"><span class="k">const</span> <span class="kt">int</span> <span class="n">a</span> <span class="p">=</span> <span class="mi">12</span><span class="p">;</span>       <span class="c1">// const(int) a = 12;と書くのと等しい</span>
</code></pre></div>
<h3>immutable</h3>

<p><code>immutable(Type)</code>型と等しくなります。</p>
<div class="highlight"><pre><code class="language-d" data-lang="d"><span class="k">immutable</span> <span class="kt">int</span> <span class="n">a</span> <span class="p">=</span> <span class="mi">12</span><span class="p">;</span>   <span class="c1">// immutable(int) a = 12;と等しい</span>
</code></pre></div>
<h3>shared</h3>

<p><code>shared(Type)</code>型と等しくなります。</p>
<div class="highlight"><pre><code class="language-d" data-lang="d"><span class="k">shared</span> <span class="kt">int</span> <span class="n">a</span> <span class="p">=</span> <span class="mi">12</span><span class="p">;</span>
</code></pre></div>
<h3>scope</h3>

<p><code>scope</code>の意味は、その参照がスコープの外に置かれることがないということです。
つまり、グローバル変数への代入や<code>return</code>を使って関数外へ送ることは不正です。</p>

<p>またその仕様から、<code>scope</code>変数を<code>new</code>を用いてクラスのインスタンスで初期化していれば、そのインスタンスはスコープを抜ける際に破棄されるという仕様もありますが、この機能は後ほど非推奨な機能となりますので、クラスの場合には<code>std.typecons.scoped</code>を使いましょう。</p>
<div class="highlight"><pre><code class="language-d" data-lang="d"><span class="k">class</span> <span class="n">Foo</span><span class="p">{</span> <span class="k">this</span><span class="p">(){};</span> <span class="p">}</span>

<span class="k">scope</span> <span class="n">foo</span> <span class="p">=</span> <span class="k">new</span> <span class="n">Foo</span><span class="p">();</span>  <span class="c1">// スタックへ割り当てられる</span>
                        <span class="c1">// スコープを抜けると同時に破棄される</span>

<span class="c1">// クラスに対するscopeは、そのうち「非推奨な機能」となるためstd.typecons.Scopedを使うとよい</span>
<span class="k">import</span> <span class="n">std</span><span class="p">.</span><span class="n">typecons</span><span class="p">;</span>
<span class="k">auto</span> <span class="n">bar</span> <span class="p">=</span> <span class="n">scoped</span><span class="p">!</span><span class="n">Foo</span><span class="p">();</span>
</code></pre></div>
<h3>関数でのみ有効となる記憶域クラス</h3>

<p>その他にも記憶域クラスはありますが、関数引数や関数そのものに対してのみ有効であるので、随時説明していきます。
以下に、そのような記憶域クラスのリストを挙げておきます。</p>

<ul>
<li><code>in</code></li>
<li><code>out</code></li>
<li><code>ref</code></li>
<li><code>lazy</code></li>
<li><code>inout</code></li>
</ul>

<h2>型推論(Type Inference)</h2>

<p>たとえば、<code>int a = 12;</code>という記述は冗長的だと思いませんか？
<code>12</code>は<code>int</code>型のリテラルなのに、<code>int a</code>とちゃんと型を宣言する必要があるでしょうか？</p>

<p>そのようなことから、D言語ではいろいろな部分で型推論なされます。
型推論とは、明示的に型宣言しなくても、その値が生成される式の型から自動的に型を決定する機能です。</p>

<p>もし、初期化子があるのであれば、<code>int</code>の代わりに<code>auto</code>を使うことで、変数の型が(コンパイル時に)自動的に決定されます。</p>
<div class="highlight"><pre><code class="language-d" data-lang="d"><span class="k">auto</span> <span class="n">a</span> <span class="p">=</span> <span class="mi">12</span><span class="p">;</span>
<span class="k">pragma</span><span class="p">(</span><span class="n">msg</span><span class="p">,</span> <span class="k">typeof</span><span class="p">(</span><span class="n">a</span><span class="p">));</span> <span class="c1">// int</span>

<span class="k">auto</span> <span class="n">b</span> <span class="p">=</span> <span class="s">&quot;ほげほげ&quot;</span><span class="p">;</span>
<span class="k">pragma</span><span class="p">(</span><span class="n">msg</span><span class="p">,</span> <span class="k">typeof</span><span class="p">(</span><span class="n">b</span><span class="p">));</span> <span class="c1">// string</span>

<span class="k">auto</span> <span class="n">c</span> <span class="p">=</span> <span class="n">a</span> <span class="p">+</span> <span class="mf">13.5</span><span class="p">;</span>
<span class="k">pragma</span><span class="p">(</span><span class="n">msg</span><span class="p">,</span> <span class="k">typeof</span><span class="p">(</span><span class="n">c</span><span class="p">));</span> <span class="c1">// double</span>

<span class="k">const</span> <span class="n">d</span> <span class="p">=</span> <span class="mi">3</span><span class="p">;</span>
<span class="k">pragma</span><span class="p">(</span><span class="n">msg</span><span class="p">,</span> <span class="k">typeof</span><span class="p">(</span><span class="n">d</span><span class="p">));</span> <span class="c1">// const(int)</span>

<span class="k">immutable</span> <span class="n">e</span> <span class="p">=</span> <span class="mi">4</span><span class="p">;</span>        <span class="c1">// 記憶域クラスのみでも型推論される</span>
<span class="k">pragma</span><span class="p">(</span><span class="n">msg</span><span class="p">,</span> <span class="k">typeof</span><span class="p">(</span><span class="n">e</span><span class="p">));</span> <span class="c1">// immutable(int)</span>
</code></pre></div>
<h2>問題 -&gt; <a href="/dmanual/answer#variable_type">解答</a></h2>

<ul>
<li><p>ビッグエンディアンとリトルエンディアンについて調べてみましょう。</p></li>
<li><p>次のソースコードをコンパイルして、エラーメッセージを読んでみましょう。</p></li>
</ul>
<div class="highlight"><pre><code class="language-d" data-lang="d"><span class="kt">void</span> <span class="n">main</span><span class="p">()</span>
<span class="p">{</span>
    <span class="n">intt</span> <span class="n">a</span><span class="p">;</span>         <span class="c1">// intでないのに注意</span>
<span class="p">}</span>
</code></pre></div>
<ul>
<li>問題募集中</li>
</ul>

<h2>おわりに</h2>

<p>お疲れ様です。
東進の先生の「基礎の基礎が怖いってことを、今日何度も言っておきます」という言葉がありますが、プログラミングは本当にその言葉に当てはまります。
今回と次回は「基礎の基礎」なので、退屈かもしれませんが確実に習得してもらいたい内容です。
しかし、たぶん無理なので、今回と次回の内容はいつでも見れるようにしておきましょう。
ちなみに、次回は「式と演算子」について書くと思います。</p>

<h2>キーワード</h2>

<ul>
<li>式(Expression)</li>
<li>文(Statement)</li>
<li>宣言(Declaration)</li>
<li>変数(Variable)</li>
<li>スコープ(Scope)</li>
<li>シンボル(Symbol)</li>
<li>グローバルスコープ(Global Scope)</li>
<li>値(Value)</li>
<li>型(Type)</li>
<li>リテラル(Literal)</li>
<li>シンボル(Symbol)</li>
<li>デフォルト初期化値(デフォルト値, デフォルト初期化子; Default Initializer)</li>
<li>void</li>
<li>論理型(Boolean); <code>bool, true, false</code></li>
<li>整数型(Decimal Number); <code>byte, ubyte, short, ushort, int, uint, long, ulong, cent, ucent, size_t, ptrdiff_t</code></li>
<li>浮動小数点型(Floating-Point Number); <code>float, double, real</code></li>
<li>虚数浮動小数点型(Imaginary Floating Point); <code>ifloat, idouble, ireal</code></li>
<li>複素数浮動小数点型(Complex Floating-Point Number); <code>cfloat, cdouble, creal</code></li>
<li>文字型(Charactor); <code>char, wchar, dchar</code></li>
<li>文字列型(String); <code>string, wstring, dstring</code></li>
<li>派生型(Derived Data Type); </li>
<li>ユーザー定義型(User Defined Type); <code>enum, struct, union, class, interface</code></li>
<li>型修飾子(Type Qualifiers)</li>
<li>記憶域クラス(Storage Class)</li>
<li>型推論(Type Inference)</li>
</ul>

              </div>
            </div>
          </div>
          <div class="row">
  <div class="col-md-12 col-sm-12 col-xs-12">
    <div class="page-footer">
      <div class="list-group">
        <a href="/archives/#y-2013" class="list-group-item col-md-3 col-sm-4 col-xs-6">
          <i class="fa fa fa-archive fa-lg"></i> 
          <em itemprop="datePublished" content="2013-05-11">
            11 May 2013
          </em>
        </a>
        
        <a href="/categories/#dmanual" class="list-group-item col-md-3 col-sm-4 col-xs-6">
          <i class="fa fa-folder-open fa-lg"></i> <em itemprop="keywords">Dmanual</em>
          <span class="badge">15</span>
        </a>
        
        
        <a href="/tags/#dmanual" class="list-group-item col-md-3 col-sm-4 col-xs-6">
          <i class="fa fa-tag fa-lg"></i> <em itemprop="keywords">dmanual</em>
          <span class="badge">16</span>
        </a>
        
    </div>
    <div id="disqus_thread"></div>
    <script type="text/javascript">
        /* * * CONFIGURATION VARIABLES: EDIT BEFORE PASTING INTO YOUR WEBPAGE * * */
        var disqus_shortname = 'dmanual'; // required: replace example with your forum shortname

        /* * * DON'T EDIT BELOW THIS LINE * * */
        (function() {
            var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
            dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
            (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
        })();
    </script>
    <noscript>Please enable JavaScript to view the <a href="http://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
    <a href="http://disqus.com" class="dsq-brlink">comments powered by <span class="logo-disqus">Disqus</span></a>
  </div>
</div>
        </article>
      </div>
    </div>
    
<div class="footer">
  <div class="container">
    <hr/>
    <div class="row">
      <div class="col-md-12 col-sm-12 col-xs-12">
        <ul class="nav nav-pills">
          
          <li>
            <a href="https://www.github.com/k3kaimu">
              <i class="fa fa-github-square fa-lg"></i> GitHub
            </a>
          </li>
          
          
          <li>
            <a href="http://www.twitter.com/k3_kaimu">
              <i class="fa fa-twitter-square fa-lg"></i> Twitter
            </a>
          </li>
          
          
          
          <li>
            <a href="/atom.xml">
              <i class="fa fa-rss-square fa-lg"></i> Rss
            </a>
          </li>
          <li class="pull-right visible-md visible-lg">
            <a href="#top">
              <i class="fa fa-arrow-circle-up fa-lg"></i> Back to top
            </a>
          </li>
        </ul>
      </div>
    </div>
    <div class="row">
      <div class="col-md-12 col-sm-12 col-xs-12">        
        <p>
          &copy; k3-kaimu 2014 
          with help from <a href="https://github.com/ogaclejapan/jekyllstrap" target="_blank" title="jekyllstrap is Jekyll template based on Bootstrap.">Jekyllstrap</a>.
        </p>
        <p>
          Based on <a href="http://jekyllrb.com/" target="_blank">Jekyll</a>. 
          Themes from <a href="http://getbootstrap.com/" target="_blank">Bootstrap</a> and <a href="http://bootswatch.com/" target="_blank">Bootswatch</a>. 
          Icons from <a href="http://fontawesome.io/" target="_blank">Font Awesome</a>.
        </p>
        <p>
        <a href="https://github.com/k3kaimu/k3kaimu.github.io/commits/src/_posts/2013-05-11-dm-variable_type.md">View this page's history on GitHub</a>
        </p>
      </div>
    </div>
    <div class="row">
    <form action="http://www.google.com/cse" id="cse-search-box">
<input type="hidden" name="cx" value="004390249242222246033:d_53xmyptd0" />
<input type="hidden" name="ie" value="UTF-8" />
<input type="text" name="q" size="31" />
<input type="submit" name="sa" value="&#xf00e;" />
</form>
<script type="text/javascript" src="//www.google.com/cse/brand?form=cse-search-box&lang=ja"></script>

    </div>
  </div>
</div>


    
<div id="back-to-top">
  <a href="#top"><i class="fa fa-arrow-circle-up fa-5x"></i></a>
</div>

    
<script src="//code.jquery.com/jquery-2.0.3.min.js"></script>
<script src="//netdna.bootstrapcdn.com/bootstrap/3.0.3/js/bootstrap.min.js"></script>
<script src="/assets/js/all.min.js"></script>



    


  </body>
</html>
